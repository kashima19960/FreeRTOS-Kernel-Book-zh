
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://kashima19960.github.io/FreeRTOS-Kernel-Book-zh/ch09-%E4%BA%8B%E4%BB%B6%E7%BB%84/">
      
      
        <link rel="prev" href="../ch08-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/">
      
      
        <link rel="next" href="../ch10-%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5/">
      
      
        
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.1">
    
    
      
        <title>9 事件组 - FreeRTOS Kernel Book zh</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.484c7ddc.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#9" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="FreeRTOS Kernel Book zh" class="md-header__button md-logo" aria-label="FreeRTOS Kernel Book zh" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            FreeRTOS Kernel Book zh
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              9 事件组
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="FreeRTOS Kernel Book zh" class="md-nav__button md-logo" aria-label="FreeRTOS Kernel Book zh" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    FreeRTOS Kernel Book zh
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    目录
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../ch01-%E5%89%8D%E8%A8%80/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    1 前言
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../ch02-FreeRTOS%20%E5%86%85%E6%A0%B8%E5%88%86%E5%8F%91%E5%8C%85/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    2 FreeRTOS 内核分发包
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../ch03-%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    3 堆内存管理
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../ch04-%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    4 任务管理
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../ch05-%E9%98%9F%E5%88%97%E7%AE%A1%E7%90%86/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    5 队列管理
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../ch06-%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8%E7%AE%A1%E7%90%86/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    6 软件定时器管理
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../ch07-%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    7 中断管理
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../ch08-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    8 资源管理
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    
  
    9 事件组
  

    
  </span>
  
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    
  
    9 事件组
  

    
  </span>
  
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#91" class="md-nav__link">
    <span class="md-ellipsis">
      
        9.1 章节介绍与范围
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="9.1 章节介绍与范围">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#911" class="md-nav__link">
    <span class="md-ellipsis">
      
        9.1.1 范围
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#92" class="md-nav__link">
    <span class="md-ellipsis">
      
        9.2 事件组的特性
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="9.2 事件组的特性">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#921" class="md-nav__link">
    <span class="md-ellipsis">
      
        9.2.1 事件组、事件标志与事件位
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#922-eventbits_t" class="md-nav__link">
    <span class="md-ellipsis">
      
        9.2.2 EventBits_t 数据类型的更多信息
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#923" class="md-nav__link">
    <span class="md-ellipsis">
      
        9.2.3 多任务访问
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#924" class="md-nav__link">
    <span class="md-ellipsis">
      
        9.2.4 事件组的实际使用示例
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#93" class="md-nav__link">
    <span class="md-ellipsis">
      
        9.3 使用事件组进行事件管理
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="9.3 使用事件组进行事件管理">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#931-xeventgroupcreate-api" class="md-nav__link">
    <span class="md-ellipsis">
      
        9.3.1 xEventGroupCreate() API 函数
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#932-xeventgroupsetbits-api" class="md-nav__link">
    <span class="md-ellipsis">
      
        9.3.2 xEventGroupSetBits() API 函数
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#933-xeventgroupsetbitsfromisr-api" class="md-nav__link">
    <span class="md-ellipsis">
      
        9.3.3 xEventGroupSetBitsFromISR() API 函数
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#934-xeventgroupwaitbits-api" class="md-nav__link">
    <span class="md-ellipsis">
      
        9.3.4 xEventGroupWaitBits() API 函数
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#935-xeventgroupgetstaticbuffer-api" class="md-nav__link">
    <span class="md-ellipsis">
      
        9.3.5 xEventGroupGetStaticBuffer() API 函数
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      
        
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#94" class="md-nav__link">
    <span class="md-ellipsis">
      
        9.4 使用事件组进行任务同步
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="9.4 使用事件组进行任务同步">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#941-xeventgroupsync-api" class="md-nav__link">
    <span class="md-ellipsis">
      
        9.4.1 xEventGroupSync() API 函数
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    <span class="md-ellipsis">
      
        
      
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../ch10-%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    10 任务通知
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../ch11-%E4%BD%8E%E5%8A%9F%E8%80%97%E6%94%AF%E6%8C%81/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    11 低功耗支持
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../ch12-%E5%BC%80%E5%8F%91%E8%80%85%E6%94%AF%E6%8C%81/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    12 开发者支持
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../ch13-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    13 故障排查
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%B9%A6%E5%90%8D/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    书名
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%BC%A9%E7%95%A5%E8%AF%AD%E8%A1%A8/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    缩略语表
  

    
  </span>
  
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#91" class="md-nav__link">
    <span class="md-ellipsis">
      
        9.1 章节介绍与范围
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="9.1 章节介绍与范围">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#911" class="md-nav__link">
    <span class="md-ellipsis">
      
        9.1.1 范围
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#92" class="md-nav__link">
    <span class="md-ellipsis">
      
        9.2 事件组的特性
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="9.2 事件组的特性">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#921" class="md-nav__link">
    <span class="md-ellipsis">
      
        9.2.1 事件组、事件标志与事件位
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#922-eventbits_t" class="md-nav__link">
    <span class="md-ellipsis">
      
        9.2.2 EventBits_t 数据类型的更多信息
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#923" class="md-nav__link">
    <span class="md-ellipsis">
      
        9.2.3 多任务访问
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#924" class="md-nav__link">
    <span class="md-ellipsis">
      
        9.2.4 事件组的实际使用示例
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#93" class="md-nav__link">
    <span class="md-ellipsis">
      
        9.3 使用事件组进行事件管理
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="9.3 使用事件组进行事件管理">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#931-xeventgroupcreate-api" class="md-nav__link">
    <span class="md-ellipsis">
      
        9.3.1 xEventGroupCreate() API 函数
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#932-xeventgroupsetbits-api" class="md-nav__link">
    <span class="md-ellipsis">
      
        9.3.2 xEventGroupSetBits() API 函数
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#933-xeventgroupsetbitsfromisr-api" class="md-nav__link">
    <span class="md-ellipsis">
      
        9.3.3 xEventGroupSetBitsFromISR() API 函数
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#934-xeventgroupwaitbits-api" class="md-nav__link">
    <span class="md-ellipsis">
      
        9.3.4 xEventGroupWaitBits() API 函数
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#935-xeventgroupgetstaticbuffer-api" class="md-nav__link">
    <span class="md-ellipsis">
      
        9.3.5 xEventGroupGetStaticBuffer() API 函数
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      
        
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#94" class="md-nav__link">
    <span class="md-ellipsis">
      
        9.4 使用事件组进行任务同步
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="9.4 使用事件组进行任务同步">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#941-xeventgroupsync-api" class="md-nav__link">
    <span class="md-ellipsis">
      
        9.4.1 xEventGroupSync() API 函数
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    <span class="md-ellipsis">
      
        
      
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="9">9 事件组</h1>
<h2 id="91">9.1 章节介绍与范围</h2>
<p>前文已经指出，实时嵌入式系统必须对事件作出响应。此前章节介绍了 FreeRTOS 中用于
向任务传递事件的特性，如信号量与队列，它们都具有以下属性：</p>
<ul>
<li>
<p>允许任务在 <em>Blocked</em> 状态等待单个事件发生。</p>
</li>
<li>
<p>当事件发生时只唤醒一个任务，即等待该事件的最高优先级任务。</p>
</li>
</ul>
<p>事件组是 FreeRTOS 的另一项特性，用于向任务传递事件。不同于队列与信号量：</p>
<ul>
<li>
<p>事件组允许任务在 <em>Blocked</em> 状态等待一个或多个事件的组合发生。</p>
</li>
<li>
<p>当事件发生时，会唤醒所有等待同一事件或事件组合的任务。</p>
</li>
</ul>
<p>事件组这些独特特性使其适用于：
多任务同步、向多个任务广播事件、让任务等待一组事件中的任意一个发生，以及让任务等待
多个动作完成。</p>
<p>事件组还有助于降低 RAM 占用，因为常常可以用一个事件组替代多个二值信号量。</p>
<p>事件组功能是可选的。要使用事件组功能，请将 FreeRTOS 源文件 event_groups.c
加入工程构建。</p>
<h3 id="911">9.1.1 范围</h3>
<p>本章旨在帮助读者理解：</p>
<ul>
<li>事件组的实际用途。</li>
<li>事件组相对于其他 FreeRTOS 特性的优缺点。</li>
<li>如何在事件组中置位。</li>
<li>如何在 <em>Blocked</em> 状态等待事件组中的位被置位。</li>
<li>如何使用事件组同步一组任务。</li>
</ul>
<h2 id="92">9.2 事件组的特性</h2>
<h3 id="921">9.2.1 事件组、事件标志与事件位</h3>
<p>事件“标志”是一个布尔值（1 或 0），用于指示事件是否发生。事件“组”是一组事件标志。</p>
<p>事件标志只能为 1 或 0，因此可用单个 bit 存储事件标志状态，并用单个变量存储事件组
所有事件标志状态。事件组中每个事件标志由 <code>EventBits_t</code> 类型变量中的一个 bit 表示。
因此事件标志也称为事件“位”。若 <code>EventBits_t</code> 变量中的某 bit 置为 1，则该 bit 所代表
的事件已发生；若置为 0，则该事件未发生。</p>
<p>图 9.1 展示事件标志如何映射到 <code>EventBits_t</code> 变量中的 bit。</p>
<p><a name="fig9.1" title="Figure 9.1 Event flag to bit number mapping in a variable of type EventBits_t"></a></p>
<hr />
<p><img alt="" src="../media/image71.png" />
<strong><em>图 9.1</em></strong> <em>事件标志与 EventBits_t 变量中 bit 编号的映射</em></p>
<hr />
<p>例如，若事件组值为 0x92（二进制 1001 0010），则只有事件位 1、4 和 7 置位，
表示仅这些位对应的事件已发生。图 9.2 展示一个 <code>EventBits_t</code> 变量，其中事件位 1、4、7
置位，其他位清零，因此事件组值为 0x92。</p>
<p><a name="fig9.2" title="Figure 9.2 An event group in which only bits 1, 4 and 7 are set, and all the other event flags are clear, making the event group's value 0x92"></a></p>
<hr />
<p><img alt="" src="../media/image72.png" />
<strong><em>图 9.2</em></strong> <em>仅 1、4、7 位为 1 的事件组，事件组值为 0x92</em></p>
<hr />
<p>事件组中各 bit 的含义由应用编写者定义。例如，可以创建一个事件组并：</p>
<ul>
<li>
<p>定义 bit 0 表示“收到来自网络的消息”。</p>
</li>
<li>
<p>定义 bit 1 表示“有消息可发送到网络”。</p>
</li>
<li>
<p>定义 bit 2 表示“中止当前网络连接”。</p>
</li>
</ul>
<h3 id="922-eventbits_t">9.2.2 EventBits_t 数据类型的更多信息</h3>
<p>事件组中事件位数量取决于 FreeRTOSConfig.h 中的编译期常量
<code>configTICK_TYPE_WIDTH_IN_BITS</code><sup id="fnref:24"><a class="footnote-ref" href="#fn:24">1</a></sup>：</p>
<ul>
<li>
<p>若 <code>configTICK_TYPE_WIDTH_IN_BITS</code> 为 <code>TICK_TYPE_WIDTH_16_BITS</code>，
  每个事件组有 8 个可用事件位。</p>
</li>
<li>
<p>若 <code>configTICK_TYPE_WIDTH_IN_BITS</code> 为 <code>TICK_TYPE_WIDTH_32_BITS</code>，
  每个事件组有 24 个可用事件位。</p>
</li>
<li>
<p>若 <code>configTICK_TYPE_WIDTH_IN_BITS</code> 为 <code>TICK_TYPE_WIDTH_64_BITS</code>，
  每个事件组有 56 个可用事件位。</p>
</li>
</ul>
<h3 id="923">9.2.3 多任务访问</h3>
<p>事件组是独立对象，任何知晓其存在的任务或 ISR 都可访问它。多个任务可以设置同一
事件组的位，也可以从同一事件组读取位。</p>
<h3 id="924">9.2.4 事件组的实际使用示例</h3>
<p>FreeRTOS+TCP 的 TCP/IP 协议栈实现提供了一个事件组用法的实际例子，展示如何
同时简化设计并减少资源使用。</p>
<p>TCP 套接字必须响应多种事件，如 accept、bind、read、close 等。套接字在任一时刻
可能发生的事件取决于其状态。例如，一个套接字已创建但尚未绑定地址，则可能收到 bind
事件，但不会收到 read 事件（因为尚无地址可读数据）。</p>
<p>FreeRTOS+TCP 套接字状态保存在 <code>FreeRTOS_Socket_t</code> 结构体中，该结构体包含一个事件组，
为套接字需要处理的每类事件定义一个事件位。阻塞等待某事件或事件组合的
FreeRTOS+TCP API 调用，会直接阻塞在该事件组上。</p>
<p>该事件组还包含一个 “abort” 位，使 TCP 连接可在任何等待事件时刻被中止。</p>
<h2 id="93">9.3 使用事件组进行事件管理</h2>
<h3 id="931-xeventgroupcreate-api">9.3.1 xEventGroupCreate() API 函数</h3>
<p>FreeRTOS 还提供 <code>xEventGroupCreateStatic()</code>，用于在编译期静态分配创建事件组
所需内存：事件组在使用前必须显式创建。</p>
<p>事件组通过 <code>EventGroupHandle_t</code> 类型变量引用。<code>xEventGroupCreate()</code> 用于创建
事件组，并返回一个 <code>EventGroupHandle_t</code> 作为句柄。</p>
<p><a name="list9.1" title="Listing 9.1 The xEventGroupCreate() API function prototype"></a></p>
<pre><code class="language-c">EventGroupHandle_t xEventGroupCreate( void );
</code></pre>
<p><strong><em>清单 9.1</em></strong> <em>xEventGroupCreate() API 函数原型</em></p>
<p><strong>xEventGroupCreate() 返回值</strong></p>
<ul>
<li>返回值</li>
</ul>
<p>若返回 NULL，则表示堆内存不足，无法为事件组分配数据结构。第 3 章提供
  更多堆内存管理信息。</p>
<p>若返回非 NULL，则表示事件组创建成功，返回值应保存为该事件组句柄。</p>
<h3 id="932-xeventgroupsetbits-api">9.3.2 xEventGroupSetBits() API 函数</h3>
<p><code>xEventGroupSetBits()</code> 用于在事件组中置位一个或多个 bit，通常用于通知任务
这些 bit 所表示的事件已发生。</p>
<blockquote>
<p><em>注意：不要在 ISR 中调用 <code>xEventGroupSetBits()</code>。应使用其中断安全版本
<code>xEventGroupSetBitsFromISR()</code>。</em></p>
</blockquote>
<p><a name="list9.2" title="Listing 9.2. The xEventGroupSetBits() API function prototype"></a></p>
<pre><code class="language-c">EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,

const EventBits_t uxBitsToSet );
</code></pre>
<p><strong><em>清单 9.2</em></strong> <em>xEventGroupSetBits() API 函数原型</em></p>
<p><strong>xEventGroupSetBits() 参数与返回值</strong></p>
<ul>
<li><code>xEventGroup</code></li>
</ul>
<p>要置位的事件组句柄。该句柄由 <code>xEventGroupCreate()</code> 创建事件组时返回。</p>
<ul>
<li><code>uxBitsToSet</code></li>
</ul>
<p>需置位为 1 的事件位掩码。事件组值通过与 <code>uxBitsToSet</code> 进行按位 OR 更新。</p>
<p>例如，将 <code>uxBitsToSet</code> 设为 0x04（二进制 0100）将使事件位 3 被置位（若原本未置位），
  其他位保持不变。</p>
<ul>
<li>返回值</li>
</ul>
<p><code>xEventGroupSetBits()</code> 返回时事件组的值。注意该返回值不一定包含 <code>uxBitsToSet</code>
  指定的位，因为这些位可能已被其他任务清除。</p>
<h3 id="933-xeventgroupsetbitsfromisr-api">9.3.3 xEventGroupSetBitsFromISR() API 函数</h3>
<p><code>xEventGroupSetBitsFromISR()</code> 是 <code>xEventGroupSetBits()</code> 的中断安全版本。</p>
<p>释放信号量是确定性操作，因为已知最多只有一个任务会离开 <em>Blocked</em> 状态。
而设置事件组位时，无法预知会有多少任务离开 <em>Blocked</em> 状态，因此设置事件位是
非确定性操作。</p>
<p>FreeRTOS 的设计与实现规范不允许在 ISR 或中断禁用状态下执行非确定性操作。
因此 <code>xEventGroupSetBitsFromISR()</code> 不在 ISR 中直接置位，而是将动作延迟到
RTOS 守护任务执行。</p>
<p><a name="list9.3" title="Listing 9.3 The xEventGroupSetBitsFromISR() API function prototype"></a></p>
<pre><code class="language-c">BaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup,
                                                  const EventBits_t uxBitsToSet,
                                                  BaseType_t *pxHigherPriorityTaskWoken );
</code></pre>
<p><strong><em>清单 9.3</em></strong> <em>xEventGroupSetBitsFromISR() API 函数原型</em></p>
<p><strong>xEventGroupSetBitsFromISR() 参数与返回值</strong></p>
<ul>
<li><code>xEventGroup</code></li>
</ul>
<p>要置位的事件组句柄。该句柄由 <code>xEventGroupCreate()</code> 创建事件组时返回。</p>
<ul>
<li><code>uxBitsToSet</code></li>
</ul>
<p>需置位为 1 的事件位掩码。事件组值通过与 <code>uxBitsToSet</code> 进行按位 OR 更新。</p>
<p>例如，将 <code>uxBitsToSet</code> 设为 0x05（二进制 0101）将使事件位 2 与事件位 0 被置位
  （若原本未置位），其他位保持不变。</p>
<ul>
<li><code>pxHigherPriorityTaskWoken</code></li>
</ul>
<p><code>xEventGroupSetBitsFromISR()</code> 不在 ISR 中直接置位，而是通过定时器命令队列发送
  命令，由 RTOS 守护任务完成。若守护任务正阻塞在定时器命令队列上等待数据，
  写队列会使守护任务离开 <em>Blocked</em> 状态。若守护任务优先级高于当前执行任务
  （被中断的任务），则 <code>xEventGroupSetBitsFromISR()</code> 会将
  <code>*pxHigherPriorityTaskWoken</code> 置为 <code>pdTRUE</code>。</p>
<p>若 <code>xEventGroupSetBitsFromISR()</code> 将该值置为 <code>pdTRUE</code>，则应在退出中断前执行
  上下文切换，确保中断直接返回到守护任务（最高优先级 <em>Ready</em> 任务）。</p>
<ul>
<li>返回值</li>
</ul>
<p>有两种可能返回值：</p>
<ul>
<li>
<p><code>pdPASS</code>：仅当成功将数据写入定时器命令队列时返回。</p>
</li>
<li>
<p><code>pdFALSE</code>：若定时器命令队列已满，无法写入“置位”命令，则返回。</p>
</li>
</ul>
<h3 id="934-xeventgroupwaitbits-api">9.3.4 xEventGroupWaitBits() API 函数</h3>
<p><code>xEventGroupWaitBits()</code> 允许任务读取事件组值，并在事件位未置位时可选择在
<em>Blocked</em> 状态等待事件组中的一个或多个位被置位。</p>
<p><a name="list9.4" title="Listing 9.4 The xEventGroupWaitBits() API function prototype"></a></p>
<pre><code class="language-c">EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup,
                                            const EventBits_t uxBitsToWaitFor,
                                            const BaseType_t xClearOnExit,
                                            const BaseType_t xWaitForAllBits,
                                            TickType_t xTicksToWait );
</code></pre>
<p><strong><em>清单 9.4</em></strong> <em>xEventGroupWaitBits() API 函数原型</em></p>
<p>调度器判断任务是否进入 <em>Blocked</em> 状态以及何时离开 <em>Blocked</em> 状态的条件称为
“解除阻塞条件”。解除阻塞条件由 <code>uxBitsToWaitFor</code> 与 <code>xWaitForAllBits</code>
参数组合指定：</p>
<ul>
<li>
<p><code>uxBitsToWaitFor</code> 指定要测试的事件位。</p>
</li>
<li>
<p><code>xWaitForAllBits</code> 指定使用按位 OR 还是按位 AND 测试。</p>
</li>
</ul>
<p>若在调用 <code>xEventGroupWaitBits()</code> 时解除阻塞条件已经满足，则任务不会进入
<em>Blocked</em> 状态。</p>
<p>表 6 给出了导致任务进入或离开 <em>Blocked</em> 状态的示例条件。表 6 仅显示事件组与
<code>uxBitsToWaitFor</code> 值的最低四位，其余位默认为 0。</p>
<p><a name="tbl6" title="Table 6 The Effect of the uxBitsToWaitFor and xWaitForAllBits Parameters"></a></p>
<hr />
<table>
<thead>
<tr>
<th>当前事件组值</th>
<th>uxBitsToWaitFor 值</th>
<th>xWaitForAllBits 值</th>
<th>结果行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>0000</td>
<td>0101</td>
<td>pdFALSE</td>
<td>调用任务进入 <em>Blocked</em> 状态，因为事件组中 bit 0 与 bit 2 都未置位；当 bit 0 或 bit 2 任意一个被置位时离开 <em>Blocked</em> 状态。</td>
</tr>
<tr>
<td>0100</td>
<td>0101</td>
<td>pdTRUE</td>
<td>调用任务进入 <em>Blocked</em> 状态，因为 bit 0 与 bit 2 未同时置位；当 bit 0 与 bit 2 同时置位时离开 <em>Blocked</em> 状态。</td>
</tr>
<tr>
<td>0100</td>
<td>0110</td>
<td>pdFALSE</td>
<td>调用任务不会进入 <em>Blocked</em> 状态，因为 xWaitForAllBits 为 pdFALSE 且 uxBitsToWaitFor 指定的两位中已有一位置位。</td>
</tr>
<tr>
<td>0100</td>
<td>0110</td>
<td>pdTRUE</td>
<td>调用任务进入 <em>Blocked</em> 状态，因为 xWaitForAllBits 为 pdTRUE 且 uxBitsToWaitFor 指定的两位中仅一位置位；当 bit 1 与 bit 2 同时置位时离开 <em>Blocked</em> 状态。</td>
</tr>
</tbody>
</table>
<p><strong><em>表 6</em></strong> <em>uxBitsToWaitFor 与 xWaitForAllBits 参数的影响</em></p>
<hr />
<p>调用任务通过 <code>uxBitsToWaitFor</code> 指定要测试的位，且很可能在解除阻塞条件满足后
需要将这些位清零。事件位可用 <code>xEventGroupClearBits()</code> 清除，但在以下情况下，
手动清除会引入竞争条件：</p>
<ul>
<li>有多个任务使用同一事件组。</li>
<li>事件位由其他任务或 ISR 置位。</li>
</ul>
<p><code>xClearOnExit</code> 参数用于避免潜在竞争条件。若 <code>xClearOnExit</code> 设为 <code>pdTRUE</code>，
则事件位的测试与清除对调用任务而言是原子操作（不可被其他任务或中断打断）。</p>
<p><strong>xEventGroupWaitBits() 参数与返回值</strong></p>
<ul>
<li><code>xEventGroup</code></li>
</ul>
<p>要读取事件位的事件组句柄。该句柄由 <code>xEventGroupCreate()</code> 创建事件组时返回。</p>
<ul>
<li><code>uxBitsToWaitFor</code></li>
</ul>
<p>指定要测试的事件位掩码。</p>
<p>例如，若调用任务希望等待事件位 0 和/或事件位 2 置位，则可将 <code>uxBitsToWaitFor</code>
  设为 0x05（二进制 0101）。更多示例见表 6。</p>
<ul>
<li><code>xClearOnExit</code></li>
</ul>
<p>若调用任务的解除阻塞条件满足且 <code>xClearOnExit</code> 为 <code>pdTRUE</code>，则在调用任务
  退出 <code>xEventGroupWaitBits()</code> 前，会将 <code>uxBitsToWaitFor</code> 指定的事件位清零。</p>
<p>若 <code>xClearOnExit</code> 为 <code>pdFALSE</code>，则 <code>xEventGroupWaitBits()</code> 不改变事件组中的位。</p>
<ul>
<li><code>xWaitForAllBits</code></li>
</ul>
<p><code>uxBitsToWaitFor</code> 指定要测试的事件位，<code>xWaitForAllBits</code> 指定当
  <code>uxBitsToWaitFor</code> 指定的位中任意一个置位即解除阻塞，还是必须全部置位才解除阻塞。</p>
<p>若 <code>xWaitForAllBits</code> 为 <code>pdFALSE</code>，则任务会在 <code>uxBitsToWaitFor</code> 指定的任意一位
  置位时离开 <em>Blocked</em> 状态（或在 <code>xTicksToWait</code> 超时后离开）。</p>
<p>若 <code>xWaitForAllBits</code> 为 <code>pdTRUE</code>，则任务仅在 <code>uxBitsToWaitFor</code> 指定的所有位
  都置位时离开 <em>Blocked</em> 状态（或在 <code>xTicksToWait</code> 超时后离开）。</p>
<p>示例见表 6。</p>
<ul>
<li><code>xTicksToWait</code></li>
</ul>
<p>任务在 <em>Blocked</em> 状态等待解除阻塞条件满足的最长时间。</p>
<p>若 <code>xTicksToWait</code> 为 0，或调用 <code>xEventGroupWaitBits()</code> 时解除阻塞条件已满足，
  则立即返回。</p>
<p>阻塞时间以 tick 为单位，绝对时间取决于 tick 频率。
  可使用 <code>pdMS_TO_TICKS()</code> 将毫秒转换为 tick。</p>
<p>若 FreeRTOSConfig.h 中 <code>INCLUDE_vTaskSuspend</code> 设为 1，将 <code>xTicksToWait</code> 设为
  <code>portMAX_DELAY</code> 会使任务无限期等待（无超时）。</p>
<ul>
<li>返回值</li>
</ul>
<p>若 <code>xEventGroupWaitBits()</code> 因解除阻塞条件满足而返回，则返回值为条件满足时
  的事件组值（若 <code>xClearOnExit</code> 为 <code>pdTRUE</code>，则在自动清零之前）。此时返回值也
  满足解除阻塞条件。</p>
<p>若 <code>xEventGroupWaitBits()</code> 因 <code>xTicksToWait</code> 超时而返回，则返回值为超时发生时
  的事件组值。此时返回值不满足解除阻塞条件。</p>
<h3 id="935-xeventgroupgetstaticbuffer-api">9.3.5 xEventGroupGetStaticBuffer() API 函数</h3>
<p><code>xEventGroupGetStaticBuffer()</code> 提供获取静态创建事件组所用缓冲区指针的方法。
该缓冲区与创建事件组时提供的缓冲区相同。</p>
<p><em>注意：不要在 ISR 中调用 <code>xEventGroupGetStaticBuffer()</code>。</em></p>
<p><a name="list9.5" title="Listing 9.5 The xEventGroupGetStaticBuffer() API function prototype"></a></p>
<pre><code class="language-c">BaseType_t xEventGroupGetStaticBuffer( EventGroupHandle_t xEventGroup,

StaticEventGroup_t ** ppxEventGroupBuffer );
</code></pre>
<p><strong><em>清单 9.5</em></strong> <em>xEventGroupGetStaticBuffer() API 函数原型</em></p>
<p><strong>xEventGroupGetStaticBuffer() 参数与返回值</strong></p>
<ul>
<li><code>xEventGroup</code></li>
</ul>
<p>要获取缓冲区的事件组。该事件组必须由 <code>xEventGroupCreateStatic()</code> 创建。</p>
<ul>
<li><code>ppxEventGroupBuffer</code></li>
</ul>
<p>用于返回事件组数据结构缓冲区指针，即创建时提供的同一缓冲区。</p>
<ul>
<li>返回值</li>
</ul>
<p>有两种可能返回值：</p>
<ul>
<li>
<p><code>pdTRUE</code>：成功获取缓冲区。</p>
</li>
<li>
<p><code>pdFALSE</code>：未能成功获取缓冲区。</p>
</li>
</ul>
<h2 id="_1"><a name="example9.1" title="Example 9.1 Experimenting with event groups"></a></h2>
<p><strong><em>示例 9.1</em></strong> <em>使用事件组进行实验</em></p>
<hr />
<p>该示例演示如何：</p>
<ul>
<li>创建事件组。</li>
<li>在 ISR 中设置事件组位。</li>
<li>在任务中设置事件组位。</li>
<li>在事件组上阻塞等待。</li>
</ul>
<p>通过先将 <code>xEventGroupWaitBits()</code> 的 <code>xWaitForAllBits</code> 设为 <code>pdFALSE</code> 运行示例，
再将 <code>xWaitForAllBits</code> 设为 <code>pdTRUE</code> 运行示例，演示 <code>xWaitForAllBits</code> 参数的效果。</p>
<p>事件位 0 与事件位 1 由任务设置，事件位 2 由 ISR 设置。三个位使用清单 9.6 的
<code>#define</code> 语句赋予描述性名称。</p>
<p><a name="list9.6" title="Listing 9.6 Event bit definitions used in Example 9.1"></a></p>
<pre><code class="language-c">/* 事件组中事件位的定义。 */
#define mainFIRST_TASK_BIT ( 1UL &lt;&lt; 0UL )  /* 事件位 0，由任务置位 */
#define mainSECOND_TASK_BIT ( 1UL &lt;&lt; 1UL ) /* 事件位 1，由任务置位 */
#define mainISR_BIT ( 1UL &lt;&lt; 2UL )         /* 事件位 2，由 ISR 置位 */
</code></pre>
<p><strong><em>清单 9.6</em></strong> <em>示例 9.1 使用的事件位定义</em></p>
<p>清单 9.7 展示设置事件位 0 与事件位 1 的任务实现。任务循环运行，依次设置位，
两次 <code>xEventGroupSetBits()</code> 调用之间延时 200ms。每次置位前都会输出字符串，
便于在控制台观察执行顺序。</p>
<p><a name="list9.7" title="Listing 9.7 The task that sets two bits in the event group in Example 9.1"></a></p>
<pre><code class="language-c">static void vEventBitSettingTask( void *pvParameters )
{
     const TickType_t xDelay200ms = pdMS_TO_TICKS( 200UL );

     for( ;; )
     {
          /* 在开始下一次循环前短暂延时。 */
          vTaskDelay( xDelay200ms );

          /* 打印消息，说明任务即将置位事件位 0，然后置位事件位 0。 */
          vPrintString( &quot;Bit setting task -\t about to set bit 0.\r\n&quot; );
          xEventGroupSetBits( xEventGroup, mainFIRST_TASK_BIT );

          /* 在置位另一个事件位前短暂延时。 */
          vTaskDelay( xDelay200ms );

          /* 打印消息，说明任务即将置位事件位 1，然后置位事件位 1。 */
          vPrintString( &quot;Bit setting task -\t about to set bit 1.\r\n&quot; );
          xEventGroupSetBits( xEventGroup, mainSECOND_TASK_BIT );
     }
}
</code></pre>
<p><strong><em>清单 9.7</em></strong> <em>示例 9.1 中设置两个事件位的任务</em></p>
<p>清单 9.8 展示 ISR 的实现，它设置事件组中的 bit 2。同样，置位前会输出字符串以便
观察执行顺序。但由于不应在 ISR 中直接输出，故使用 <code>xTimerPendFunctionCallFromISR()</code>
将输出延迟到 RTOS 守护任务上下文执行。</p>
<p>与前例一样，ISR 由一个简单的周期任务触发软件中断。本例每 500ms 生成一次中断。</p>
<p><a name="list9.8" title="Listing 9.8 The ISR that sets bit 2 in the event group in Example 9.1"></a></p>
<pre><code class="language-c">static uint32_t ulEventBitSettingISR( void )
{
     /* 该字符串不在中断服务例程中打印，而是发送到 RTOS 守护任务执行打印。
         因此将其声明为 static，以确保编译器不会将字符串分配在 ISR 的栈上，
         因为守护任务打印字符串时 ISR 的栈帧已不存在。 */
     static const char *pcString = &quot;Bit setting ISR -\t about to set bit 2.\r\n&quot;;
     BaseType_t xHigherPriorityTaskWoken = pdFALSE;

     /* 打印消息，说明即将置位 bit 2。消息不能在 ISR 中打印，因此通过挂起
         函数调用将实际输出延迟到 RTOS 守护任务上下文执行。 */
     xTimerPendFunctionCallFromISR( vPrintStringFromDaemonTask,
                                              ( void * ) pcString,
                                              0,
                                              &amp;xHigherPriorityTaskWoken );

     /* 在事件组中置位 bit 2。 */
     xEventGroupSetBitsFromISR( xEventGroup,
                                         mainISR_BIT,
                                         &amp;xHigherPriorityTaskWoken );

     /* xTimerPendFunctionCallFromISR() 和 xEventGroupSetBitsFromISR() 都会
         写定时器命令队列，并且都使用同一个 xHigherPriorityTaskWoken 变量。
         如果写队列导致 RTOS 守护任务离开 Blocked 状态，且守护任务优先级
         高于当前执行任务（被该中断打断的任务），则 xHigherPriorityTaskWoken
         会被置为 pdTRUE。

         xHigherPriorityTaskWoken 用作 portYIELD_FROM_ISR() 的参数。
         若 xHigherPriorityTaskWoken 等于 pdTRUE，则调用
         portYIELD_FROM_ISR() 会请求上下文切换；若仍为 pdFALSE，则调用
         portYIELD_FROM_ISR() 不会产生效果。

         Windows 移植中 portYIELD_FROM_ISR() 的实现包含返回语句，
         因此该函数未显式返回值。 */

     portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
}
</code></pre>
<p><strong><em>清单 9.8</em></strong> <em>示例 9.1 中设置事件位 2 的 ISR</em></p>
<p>清单 9.9 展示调用 <code>xEventGroupWaitBits()</code> 阻塞等待事件组的任务实现。该任务会
对事件组中被置位的每一位输出一条字符串。</p>
<p><code>xEventGroupWaitBits()</code> 的 <code>xClearOnExit</code> 参数设为 <code>pdTRUE</code>，因此导致
<code>xEventGroupWaitBits()</code> 返回的事件位会在返回前自动清除。</p>
<p><a name="list9.9" title="Listing 9.9 The task that blocks to wait for event bits to become set in Example 9.1"></a></p>
<pre><code class="language-c">static void vEventBitReadingTask( void *pvParameters )
{
     EventBits_t xEventGroupValue;
     const EventBits_t xBitsToWaitFor = ( mainFIRST_TASK_BIT  |
                                                      mainSECOND_TASK_BIT |
                                                      mainISR_BIT );

     for( ;; )
     {
          /* 阻塞等待事件组中的事件位置位。 */
          xEventGroupValue = xEventGroupWaitBits( /* 要读取的事件组 */
                                                                xEventGroup,

                                        /* 要测试的事件位 */
                                                                xBitsToWaitFor,

                                        /* 若满足解除阻塞条件则在退出时清除位 */
                                                                pdTRUE,

                                        /* 不必等待全部事件位。本参数在第二次执行时设为 pdTRUE。 */
                                                                pdFALSE,

                                        /* 不超时。 */
                                                                portMAX_DELAY );

          /* 为每个已置位的位打印一条消息。 */
          if( ( xEventGroupValue &amp; mainFIRST_TASK_BIT ) != 0 )
          {
                vPrintString( &quot;Bit reading task -\t Event bit 0 was set\r\n&quot; );
          }

          if( ( xEventGroupValue &amp; mainSECOND_TASK_BIT ) != 0 )
          {
                vPrintString( &quot;Bit reading task -\t Event bit 1 was set\r\n&quot; );
          }

          if( ( xEventGroupValue &amp; mainISR_BIT ) != 0 )
          {
                vPrintString( &quot;Bit reading task -\t Event bit 2 was set\r\n&quot; );
          }
     }
}
</code></pre>
<p><strong><em>清单 9.9</em></strong> <em>示例 9.1 中阻塞等待事件位的任务</em></p>
<p><code>main()</code> 创建事件组与任务后启动调度器。实现见清单 9.10。读取事件组的任务
优先级高于写事件组的任务，确保每次解除阻塞条件满足时读取任务都会抢占写任务。</p>
<p><a name="list9.10" title="Listing 9.10 Creating the event group and tasks in Example 9.1"></a></p>
<pre><code class="language-c">int main( void )
{
     /* 使用事件组前必须先创建。 */
     xEventGroup = xEventGroupCreate();

     /* 创建在事件组中置位事件位的任务。 */
     xTaskCreate( vEventBitSettingTask, &quot;Bit Setter&quot;, 1000, NULL, 1, NULL );

     /* 创建等待事件组事件位置位的任务。 */
     xTaskCreate( vEventBitReadingTask, &quot;Bit Reader&quot;, 1000, NULL, 2, NULL );

     /* 创建周期性产生软件中断的任务。 */
     xTaskCreate( vInterruptGenerator, &quot;Int Gen&quot;, 1000, NULL, 3, NULL );

     /* 安装软件中断处理程序。所需语法取决于所用 FreeRTOS 移植。
         此处语法仅适用于 FreeRTOS Windows 移植，在该移植中这类中断只是模拟的。 */
     vPortSetInterruptHandler( mainINTERRUPT_NUMBER, ulEventBitSettingISR );

     /* 启动调度器，使已创建的任务开始执行。 */
     vTaskStartScheduler();

     /* 按惯例，下面这一行不应被执行。 */
     for( ;; );
     return 0;
}
</code></pre>
<p><strong><em>清单 9.10</em></strong> <em>示例 9.1 中创建事件组与任务</em></p>
<p>当 <code>xEventGroupWaitBits()</code> 的 <code>xWaitForAllBits</code> 参数设为 <code>pdFALSE</code> 时，
示例 9.1 的输出如图 9.3 所示。可见，由于 <code>xWaitForAllBits</code> 设为 <code>pdFALSE</code>，
读取事件组的任务在任何事件位置位时都会立即离开 <em>Blocked</em> 状态并执行。</p>
<p><a name="fig9.3" title="Figure 9.3 The output produced when Example 9.1 is executed with xWaitForAllBits set to pdFALSE"></a></p>
<hr />
<p><img alt="" src="../media/image73.jpg" />
<strong><em>图 9.3</em></strong> <em>xWaitForAllBits= pdFALSE 时示例 9.1 的输出</em></p>
<hr />
<p>当 <code>xEventGroupWaitBits()</code> 的 <code>xWaitForAllBits</code> 参数设为 <code>pdTRUE</code> 时，
示例 9.1 的输出如图 9.4 所示。可见，由于 <code>xWaitForAllBits</code> 设为 <code>pdTRUE</code>，
读取事件组的任务只有在三个事件位全部置位后才离开 <em>Blocked</em> 状态。</p>
<p><a name="fig9.4" title="Figure 9.4 The output produced when Example 9.1 is executed with xWaitForAllBits set to pdTRUE"></a></p>
<hr />
<p><img alt="" src="../media/image74.jpg" />
<strong><em>图 9.4</em></strong> <em>xWaitForAllBits= pdTRUE 时示例 9.1 的输出</em></p>
<hr />
<h2 id="94">9.4 使用事件组进行任务同步</h2>
<p>有时应用设计要求两个或更多任务彼此同步。例如，任务 A 接收到事件后，将部分处理
委派给任务 B、任务 C 与任务 D。若任务 A 在 B、C、D 完成前不能接收下一个事件，
则这四个任务需同步。每个任务在完成自身处理后到达“同步点”，只有当其他任务也
完成处理后才可继续。任务 A 只有在四个任务都到达同步点后才能接收下一事件。</p>
<p>一个更具体的例子来自 FreeRTOS+TCP 的演示工程。该示例让两个任务共享一个 TCP
socket；一个任务向 socket 发送数据，另一个任务从同一 socket 接收数据<sup id="fnref:25"><a class="footnote-ref" href="#fn:25">2</a></sup>。
任一任务在确信对方不再访问 socket 前都不能关闭 socket。若其中任一任务希望关闭
socket，则必须告知另一任务并等待其停止使用 socket 后再继续。清单 9.10 的伪代码
展示了发送任务希望关闭 socket 的场景。</p>
<p>清单 9.10 的场景相对简单，因为只有两个任务需要同步。但可见若其他任务也依赖
socket 打开，则同步场景会更复杂，需要更多任务参与。</p>
<p><a name="list9.11" title="Listing 9.11 Pseudo code for two tasks that synchronize with each other to ensure a shared TCP socket..."></a></p>
<pre><code class="language-c">void SocketTxTask( void *pvParameters )
{
     xSocket_t xSocket;
     uint32_t ulTxCount = 0UL;

     for( ;; )
     {
          /* 创建新的 socket。该任务向该 socket 发送数据，另一个任务从该 socket 接收数据。 */
          xSocket = FreeRTOS_socket( ... );

          /* 连接 socket。 */
          FreeRTOS_connect( xSocket, ... );

          /* 使用队列将 socket 发送给接收数据的任务。 */
          xQueueSend( xSocketPassingQueue, &amp;xSocket, portMAX_DELAY );

          /* 在关闭 socket 前向其发送 1000 条消息。 */
          for( ulTxCount = 0; ulTxCount &lt; 1000; ulTxCount++ )
          {
                if( FreeRTOS_send( xSocket, ... ) &lt; 0 )
                {
                     /* 发生意外错误——退出循环，随后关闭 socket。 */
                     break;
                }
          }

          /* 通知 Rx 任务 Tx 任务要关闭 socket。 */
          TxTaskWantsToCloseSocket();

          /* 这是 Tx 任务的同步点。Tx 任务在此等待 Rx 任务到达同步点。
              Rx 任务只有在不再使用 socket 时才会到达同步点，此时可安全关闭 socket。 */
          xEventGroupSync( ... );

          /* 两个任务均未使用 socket。关闭连接，然后关闭 socket。 */
          FreeRTOS_shutdown( xSocket, ... );
          WaitForSocketToDisconnect();
          FreeRTOS_closesocket( xSocket );
     }
}
/*-----------------------------------------------------------*/

void SocketRxTask( void *pvParameters )
{
     xSocket_t xSocket;

     for( ;; )
     {
          /* 等待接收由 Tx 任务创建并连接的 socket。 */
          xQueueReceive( xSocketPassingQueue, &amp;xSocket, portMAX_DELAY );

          /* 持续从 socket 接收，直到 Tx 任务希望关闭 socket。 */
          while( TxTaskWantsToCloseSocket() == pdFALSE )
          {
              /* 接收并处理数据。 */
              FreeRTOS_recv( xSocket, ... );
              ProcessReceivedData();
          }

          /* 这是 Rx 任务的同步点——只有在不再使用 socket 时才会到达这里，
              因此此时 Tx 任务可安全关闭 socket。 */
          xEventGroupSync( ... );
     }
}
</code></pre>
<p><strong><em>清单 9.11</em></strong> <em>两个任务通过同步确保共享 TCP socket 不再被任一任务使用后再关闭 socket 的伪代码</em></p>
<p>事件组可用于创建同步点：</p>
<ul>
<li>
<p>每个参与同步的任务在事件组中分配一个唯一事件位。</p>
</li>
<li>
<p>每个任务到达同步点时设置自身事件位。</p>
</li>
<li>
<p>设置自身事件位后，各任务阻塞在事件组上等待其他同步任务的事件位也置位。</p>
</li>
</ul>
<p>但在该场景中不能使用 <code>xEventGroupSetBits()</code> 与 <code>xEventGroupWaitBits()</code>。若使用它们，
设置事件位（表示任务到达同步点）与测试事件位（判断其他任务是否到达同步点）将
作为两个独立操作执行。考虑任务 A、B、C 使用事件组同步的场景：</p>
<ol>
<li>
<p>任务 A、任务 B 已到达同步点，其事件位已置位，并在 <em>Blocked</em> 状态等待任务 C 的
    事件位置位。</p>
</li>
<li>
<p>任务 C 到达同步点，调用 <code>xEventGroupSetBits()</code> 置位自身事件位。其事件位置位后，
    任务 A 与任务 B 离开 <em>Blocked</em> 状态，并清除所有三个事件位。</p>
</li>
<li>
<p>任务 C 随后调用 <code>xEventGroupWaitBits()</code> 等待三个事件位，但此时它们已被清除，
    任务 A 与任务 B 已离开同步点，导致同步失败。</p>
</li>
</ol>
<p>要用事件组成功创建同步点，事件位置位与随后的事件位测试必须作为一个不可中断的
原子操作完成。<code>xEventGroupSync()</code> 就是为此目的提供的 API。</p>
<h3 id="941-xeventgroupsync-api">9.4.1 xEventGroupSync() API 函数</h3>
<p><code>xEventGroupSync()</code> 允许两个或多个任务使用事件组进行同步。它允许任务在一个
不可中断的操作中设置事件位，并等待同一事件组中某组合事件位被置位。</p>
<p><code>xEventGroupSync()</code> 的 <code>uxBitsToWaitFor</code> 参数指定调用任务的解除阻塞条件。
若 <code>xEventGroupSync()</code> 因解除阻塞条件满足而返回，则 <code>uxBitsToWaitFor</code> 指定的
事件位会在返回前被清零。</p>
<p><a name="list9.12" title="Listing 9.12 The xEventGroupSync() API function prototype"></a></p>
<pre><code class="language-c">EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup,
                                      const EventBits_t uxBitsToSet,
                                      const EventBits_t uxBitsToWaitFor,
                                      TickType_t xTicksToWait );
</code></pre>
<p><strong><em>清单 9.12</em></strong> <em>xEventGroupSync() API 函数原型</em></p>
<p><strong>xEventGroupSync() 参数与返回值</strong></p>
<ul>
<li><code>xEventGroup</code></li>
</ul>
<p>需要设置与测试事件位的事件组句柄。该句柄由 <code>xEventGroupCreate()</code> 创建事件组时返回。</p>
<ul>
<li><code>uxBitsToSet</code></li>
</ul>
<p>需置位为 1 的事件位掩码。事件组值通过与 <code>uxBitsToSet</code> 进行按位 OR 更新。</p>
<p>例如，将 <code>uxBitsToSet</code> 设为 0x04（二进制 0100）将使事件位 2 被置位（若原本未置位），
  其他位保持不变。</p>
<ul>
<li><code>uxBitsToWaitFor</code></li>
</ul>
<p>指定要测试的事件位掩码。</p>
<p>例如，若调用任务希望等待事件位 0、1、2 置位，则将 <code>uxBitsToWaitFor</code> 设为 0x07
  （二进制 111）。</p>
<ul>
<li><code>xTicksToWait</code></li>
</ul>
<p>任务在 <em>Blocked</em> 状态等待解除阻塞条件满足的最长时间。</p>
<p>若 <code>xTicksToWait</code> 为 0，或调用 <code>xEventGroupSync()</code> 时解除阻塞条件已满足，则立即返回。</p>
<p>阻塞时间以 tick 为单位，绝对时间取决于 tick 频率。
  可使用 <code>pdMS_TO_TICKS()</code> 将毫秒转换为 tick。</p>
<p>若 FreeRTOSConfig.h 中 <code>INCLUDE_vTaskSuspend</code> 设为 1，将 <code>xTicksToWait</code> 设为
  <code>portMAX_DELAY</code> 会使任务无限期等待（无超时）。</p>
<ul>
<li>返回值</li>
</ul>
<p>若 <code>xEventGroupSync()</code> 因解除阻塞条件满足而返回，则返回值为条件满足时的事件组值
  （在自动清零之前）。此时返回值也满足解除阻塞条件。</p>
<p>若 <code>xEventGroupSync()</code> 因 <code>xTicksToWait</code> 超时而返回，则返回值为超时发生时的
  事件组值，此时返回值不满足解除阻塞条件。</p>
<h2 id="_2"><a name="example9.2" title="Example 9.2 Synchronizing tasks"></a></h2>
<p><strong><em>示例 9.2</em></strong> <em>任务同步</em></p>
<hr />
<p>示例 9.2 使用 <code>xEventGroupSync()</code> 同步同一任务实现的三个实例。任务参数用于传入
各实例在调用 <code>xEventGroupSync()</code> 时要设置的事件位。</p>
<p>任务在调用 <code>xEventGroupSync()</code> 前后各输出一次消息，并附带时间戳，便于观察
输出中的执行顺序。使用伪随机延时，以防所有任务同时到达同步点。</p>
<p>任务实现见清单 9.12。</p>
<p><a name="list9.13" title="Listing 9.13 The implementation of the task used in Example 9.2"></a></p>
<pre><code class="language-c">static void vSyncingTask( void *pvParameters )
{
     const TickType_t xMaxDelay = pdMS_TO_TICKS( 4000UL );
     const TickType_t xMinDelay = pdMS_TO_TICKS( 200UL );
     TickType_t xDelayTime;
     EventBits_t uxThisTasksSyncBit;
     const EventBits_t uxAllSyncBits = ( mainFIRST_TASK_BIT  |
                                                     mainSECOND_TASK_BIT |
                                                     mainTHIRD_TASK_BIT );

     /* 创建该任务的三个实例——每个任务在同步中使用不同的事件位。
         使用的事件位通过任务参数传入每个任务实例，并存入 uxThisTasksSyncBit。 */
     uxThisTasksSyncBit = ( EventBits_t ) pvParameters;

     for( ;; )
     {
          /* 通过伪随机延时模拟该任务执行动作所需时间。
              这可防止三个任务实例同时到达同步点，便于观察示例行为。 */
          xDelayTime = ( rand() % xMaxDelay ) + xMinDelay;
          vTaskDelay( xDelayTime );

          /* 打印消息，显示该任务已到达同步点。pcTaskGetTaskName()
              返回创建任务时分配的任务名。 */
          vPrintTwoStrings( pcTaskGetTaskName( NULL ), &quot;reached sync point&quot; );

          /* 等待所有任务都到达各自的同步点。 */
          xEventGroupSync( /* 用于同步的事件组。 */
                                 xEventGroup,

                                 /* 由该任务置位，用于表示到达同步点的事件位。 */
                                 uxThisTasksSyncBit,

                                 /* 等待的事件位，每个参与同步的任务对应一位。 */
                                 uxAllSyncBits,

                                 /* 无限期等待三个任务都到达同步点。 */
                                 portMAX_DELAY );

          /* 打印消息，显示该任务已通过同步点。由于使用了无限期延时，
              下面一行仅在所有任务都到达各自同步点后才会执行。 */
          vPrintTwoStrings( pcTaskGetTaskName( NULL ), &quot;exited sync point&quot; );
     }
}
</code></pre>
<p><strong><em>清单 9.13</em></strong> <em>示例 9.2 使用的任务实现</em></p>
<p><code>main()</code> 创建事件组与三个任务后启动调度器。实现见清单 9.14。</p>
<p><a name="list9.14" title="Listing 9.14 The main() function used in Example 9.2"></a></p>
<pre><code class="language-c">/* 事件组中事件位的定义。 */

#define mainFIRST_TASK_BIT ( 1UL &lt;&lt; 0UL ) /* 事件位 0，由第 1 个任务置位 */
#define mainSECOND_TASK_BIT( 1UL &lt;&lt; 1UL ) /* 事件位 1，由第 2 个任务置位 */
#define mainTHIRD_TASK_BIT ( 1UL &lt;&lt; 2UL ) /* 事件位 2，由第 3 个任务置位 */

/* 声明用于同步三个任务的事件组。 */
EventGroupHandle_t xEventGroup;

int main( void )
{
     /* 使用事件组前必须先创建。 */
     xEventGroup = xEventGroupCreate();

     /* 创建三个任务实例。每个任务赋予不同名称，稍后会打印以直观显示
         当前执行的任务。任务到达同步点时使用的事件位通过任务参数传入。 */
     xTaskCreate( vSyncingTask, &quot;Task 1&quot;, 1000, mainFIRST_TASK_BIT, 1, NULL );
     xTaskCreate( vSyncingTask, &quot;Task 2&quot;, 1000, mainSECOND_TASK_BIT, 1, NULL );
     xTaskCreate( vSyncingTask, &quot;Task 3&quot;, 1000, mainTHIRD_TASK_BIT, 1, NULL );

     /* 启动调度器，使已创建的任务开始执行。 */
     vTaskStartScheduler();

     /* 按惯例，下面这一行不应被执行。 */
     for( ;; );
     return 0;
}
</code></pre>
<p><strong><em>清单 9.14</em></strong> <em>示例 9.2 的 main() 函数</em></p>
<p>示例 9.2 的输出如图 9.5 所示。可见尽管每个任务在不同（伪随机）时间到达同步点，
但它们在同一时刻离开同步点<sup id="fnref:26"><a class="footnote-ref" href="#fn:26">3</a></sup>（即最后一个任务到达同步点的时刻）。</p>
<p><a name="fig9.5" title="Figure 9.5 The output produced when Example 9.2 is executed"></a></p>
<hr />
<p><img alt="" src="../media/image75.jpg" />
<strong><em>图 9.5</em></strong> <em>示例 9.2 的输出</em></p>
<hr />
<div class="footnote">
<hr />
<ol>
<li id="fn:24">
<p><code>configTICK_TYPE_WIDTH_IN_BITS</code> 配置用于保存 RTOS tick 计数的类型，
看似与事件组无关。其对 <code>EventBits_t</code> 类型的影响源于 FreeRTOS 的内部实现。
尽管将 <code>configTICK_TYPE_WIDTH_IN_BITS</code> 设为 <code>TICK_TYPE_WIDTH_16_BITS</code> 是可取的，
但仅应在处理器对 16 位类型效率显著高于 32 位类型时才这么做。&#160;<a class="footnote-backref" href="#fnref:24" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:25">
<p>在撰写本书时，这是单个 FreeRTOS+TCP socket 在任务间共享的唯一方式。&#160;<a class="footnote-backref" href="#fnref:25" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:26">
<p>图 9.5 展示了 FreeRTOS Windows 移植上的运行结果，该移植不具备严格实时性
（尤其在使用 Windows 系统调用向控制台输出时），因此会出现一定时间偏差。&#160;<a class="footnote-backref" href="#fnref:26" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
</ol>
</div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "..", "features": [], "search": "../assets/javascripts/workers/search.2c215733.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../assets/javascripts/bundle.79ae519e.min.js"></script>
      
    
  </body>
</html>