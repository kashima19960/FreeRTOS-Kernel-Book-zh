# 7 中断管理

## 7.1 简介

### 7.1.1 事件

嵌入式实时系统必须对来自外部环境的事件作出响应。例如，以太网外设上收到一个数据包
（事件）可能需要将其传递给 TCP/IP 协议栈处理（动作）。非简单系统通常要同时处理
来自多个来源的事件，而这些事件的处理开销与响应时间要求各不相同。此时需要判断
并选择最佳的事件处理实现策略：

- 如何检测事件？通常使用中断，但也可以轮询输入。

- 若使用中断，应在中断服务例程（ISR）中处理多少工作，多少工作放到中断之外？
	通常希望 ISR 尽可能短。

- 如何把事件传递到主（非 ISR）代码？主代码该如何组织，才能更好地处理
	可能异步出现的事件？

FreeRTOS 不强制应用设计者采用某种特定的事件处理策略，但提供了可使选定策略
以简单、可维护方式实现的功能。

务必区分任务优先级与中断优先级：

- 任务是与硬件无关的软件实体。任务优先级由应用编写者在软件中分配，调度器
	按软件算法决定哪个任务进入 *Running* 状态。

- 中断服务例程虽由软件编写，但它是硬件特性，因为硬件控制哪个 ISR 运行以及
	何时运行。只有当没有 ISR 在运行时任务才会运行，因此最低优先级中断仍可
	打断最高优先级任务，任务无法抢占 ISR。

所有能运行 FreeRTOS 的架构都支持中断，但中断进入方式和中断优先级分配细节
在不同架构间各不相同。


### 7.1.2 范围

本章涵盖：

- 哪些 FreeRTOS API 函数可在 ISR 中使用。
- 将中断处理延迟到任务中的方法。
- 如何创建并使用二值信号量与计数信号量。
- 二值信号量与计数信号量的差异。
- 如何使用队列在 ISR 中传入与传出数据。
- 部分 FreeRTOS 移植提供的中断嵌套模型。


## 7.2 在 ISR 中使用 FreeRTOS API

### 7.2.1 中断安全 API

通常需要在中断服务例程（ISR）中使用 FreeRTOS API 的功能，但许多 FreeRTOS API
函数执行的动作在 ISR 内无效。其中最显著的是将调用该 API 的任务置为 *Blocked*
状态——若从 ISR 调用某 API，就不是由任务调用，因此不存在可置为 *Blocked* 状态
的调用任务。FreeRTOS 通过为部分 API 函数提供两个版本来解决该问题：
一个供任务使用，一个供 ISR 使用。可在 ISR 中使用的函数名末尾带有 “FromISR”。

> *注意：绝不能在 ISR 中调用名称中不带 “FromISR” 的 FreeRTOS API 函数。*


### 7.2.2 使用独立中断安全 API 的好处

为中断提供独立 API 可以让任务代码更高效、ISR 代码更高效，同时中断入口也更简化。
对比之下，若为任务和 ISR 提供同一版本的 API，则：

- API 函数必须增加额外逻辑以判断调用上下文（任务或 ISR）。额外逻辑会引入
	新路径，使函数更长、更复杂、更难测试。

- 一些参数在任务调用时无意义，而另一些参数在 ISR 调用时无意义。

- 每个 FreeRTOS 移植都必须提供区分执行上下文的机制。

- 在不易判断上下文的架构上，需要额外、低效、更加复杂且非标准的中断入口代码，
	让软件提供执行上下文。


### 7.2.3 使用独立中断安全 API 的缺点

为部分 API 提供两个版本能提高任务与 ISR 的效率，但也带来新问题：有时需要
调用某个不属于 FreeRTOS API、但内部使用了 FreeRTOS API 的函数，而且该函数
可能既从任务调用，也从 ISR 调用。

这种情况通常发生在集成第三方代码时，因为那时软件设计不受应用编写者控制。
如果出现此问题，可通过以下方式解决：

- 将中断处理延迟到任务[^12]，使该 API 仅在任务上下文中调用。

- 若使用支持中断嵌套的 FreeRTOS 移植，可直接使用带 “FromISR” 的版本，
	因为该版本既可用于任务也可用于 ISR。（反之不成立：不带 “FromISR” 的 API
	绝不能在 ISR 中调用。）

- 第三方代码通常包含 RTOS 抽象层，可实现上下文检测（任务或中断），并据此
	调用适当的 API 版本。


[^12]: 延迟中断处理将在本书下一节介绍。


### 7.2.4 xHigherPriorityTaskWoken 参数

本节引入 `xHigherPriorityTaskWoken` 参数概念。若暂未完全理解也不必担心，
后续章节会给出实际示例。

若由中断触发上下文切换，则中断退出后运行的任务可能与中断进入前运行的任务不同——
中断打断了一个任务，但返回到了另一个任务。

某些 FreeRTOS API 函数可将任务从 *Blocked* 状态移到 *Ready* 状态。例如
`xQueueSendToBack()`，若队列上有任务等待数据，该函数会解除其阻塞。

如果被解除阻塞的任务优先级高于当前 *Running* 状态任务，根据 FreeRTOS 调度策略，
应切换到更高优先级任务。具体何时切换取决于调用 API 的上下文：

- 若 API 从任务中调用：

	如果 `configUSE_PREEMPTION` 在 FreeRTOSConfig.h 中设为 1，则切换到更高优先级
	任务会在 API 函数内部自动完成，也就是在 API 函数返回前完成。图 6.6 已展示
	过类似情况：写定时器命令队列会在返回前切换到 RTOS 守护任务。

- 若 API 从中断中调用：

	在中断内不会自动切换到更高优先级任务。相反，会设置一个变量，提示应用编写者
	在中断退出前执行上下文切换。中断安全 API（名称以 “FromISR” 结尾）带有指针参数
	`pxHigherPriorityTaskWoken` 用于此目的。

	若需要上下文切换，中断安全 API 会将 `*pxHigherPriorityTaskWoken` 置为 `pdTRUE`。
	为检测这一变化，`pxHigherPriorityTaskWoken` 指向的变量必须在首次使用前初始化为
	`pdFALSE`。

	若应用编写者不请求 ISR 内的上下文切换，则更高优先级任务将保持 *Ready* 状态，
	直到下次调度器运行（最坏情况为下一个 tick 中断）。

	FreeRTOS API 只能将 `*pxHighPriorityTaskWoken` 置为 `pdTRUE`。如果 ISR 调用多个
	FreeRTOS API 函数，可在每次调用中传入同一个变量作为 `pxHigherPriorityTaskWoken`
	参数，该变量只需在首次使用前初始化为 `pdFALSE`。

上下文切换不会在中断安全 API 内自动发生，原因有：

- 避免不必要的上下文切换

	中断可能在任务需要处理前执行多次。例如，任务处理 UART 中断接收的字符串，
	若每收一个字符就从 ISR 切换到任务，会造成浪费，因为任务只需在完整字符串
	接收后处理。

- 控制执行顺序

	中断可能在不可预测的时间发生。资深用户可能希望在特定位置临时避免
	不可预测的任务切换（也可通过调度器锁实现）。

- 可移植性

	这是最简单且跨所有 FreeRTOS 移植可用的机制。

- 效率

	面向小型处理器架构的移植通常仅允许在 ISR 末尾请求上下文切换。
	若打破限制，需要额外复杂代码。该机制也允许在同一 ISR 中多次调用 FreeRTOS API，
	却不产生多次上下文切换请求。

- 在 RTOS tick 中断中执行

	如本书后文所述，可在 RTOS tick 中断中加入应用代码。在 tick 中断内尝试切换
	的结果依赖所用移植；最好的情况也只是一次不必要的调度调用。

`pxHigherPriorityTaskWoken` 的使用是可选的。如不需要，可将其设为 NULL。


### 7.2.5 portYIELD_FROM_ISR() 与 portEND_SWITCHING_ISR() 宏

本节介绍用于从 ISR 请求上下文切换的宏。若暂未完全理解也无妨，后续章节会提供示例。

`taskYIELD()` 是可在任务中调用以请求上下文切换的宏。`portYIELD_FROM_ISR()`
和 `portEND_SWITCHING_ISR()` 是 `taskYIELD()` 的中断安全版本，二者用途相同[^13]。
某些 FreeRTOS 移植只提供其中一个；较新的移植提供两个宏。本书示例使用
`portYIELD_FROM_ISR()`。

[^13]: 历史上，要求中断处理程序使用汇编包装器的移植采用
`portEND_SWITCHING_ISR()`，允许整个中断处理程序用 C 编写的移植采用
`portYIELD_FROM_ISR()`。


<a name="list7.1" title="Listing 7.1 The portEND_SWITCHING_ISR() macros"></a>

```c
portEND_SWITCHING_ISR( xHigherPriorityTaskWoken );
```
***清单 7.1*** *portEND_SWITCHING_ISR() 宏*


<a name="list7.2" title="Listing 7.2 The portYIELD_FROM_ISR() macros"></a>

```c
portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
```
***清单 7.2*** *portYIELD_FROM_ISR() 宏*


从中断安全 API 返回的 `xHigherPriorityTaskWoken` 参数可直接用作
`portYIELD_FROM_ISR()` 的参数。

若 `portYIELD_FROM_ISR()` 的 `xHigherPriorityTaskWoken` 参数为 `pdFALSE`（0），
则不请求上下文切换，宏无效果。若参数非 `pdFALSE`，则请求上下文切换，
*Running* 状态任务可能改变。中断总会返回到 *Running* 状态任务，即便中断执行期间
*Running* 状态任务发生变化。

多数 FreeRTOS 移植允许在 ISR 内任意位置调用 `portYIELD_FROM_ISR()`。
少数移植（多为小型架构）只允许在 ISR 末尾调用该宏。


## 7.3 延迟中断处理

通常认为 ISR 应尽可能短，原因包括：

- 即使任务设置了很高优先级，也只有在硬件不处理任何中断时才会运行。

- ISR 会干扰（增加“抖动”）任务的开始时间与执行时间。

- 取决于 FreeRTOS 运行的架构，ISR 执行期间可能无法接受新中断，或至少无法接受
	某些中断。

- 应用编写者需考虑并防止任务与 ISR 同时访问变量、外设、内存缓冲区等资源。

- 某些 FreeRTOS 移植允许中断嵌套，但嵌套会增加复杂性并降低可预测性。
	ISR 越短，嵌套越不易发生。

ISR 必须记录中断原因并清除中断。其他由中断触发的处理可在任务中执行，
使 ISR 尽快退出。这称为“延迟中断处理”，即将 ISR 触发的处理“延迟”到任务中。

将中断处理延迟到任务还可让应用编写者相对其他任务进行优先级配置，并使用全部
FreeRTOS API 函数。

若承接延迟处理中断的任务优先级高于系统内其他任务，则该处理会立即执行，
效果与在 ISR 内执行等同。图 7.1 中，Task 1 为普通应用任务，Task 2 为延迟处理中断
的任务。


<a name="fig7.1" title="Figure 7.1 Completing interrupt processing in a high priority task"></a>

* * *
![](media/image48.png)
***图 7.1*** *在高优先级任务中完成中断处理*
* * *

在图 7.1 中，中断处理在 t2 开始，到 t4 才真正结束，但 t2 到 t3 之间才在 ISR 内。
若不使用延迟处理，t2 到 t4 全部时间都在 ISR 内。

何时应在 ISR 内完成全部处理、何时应延迟部分处理，并无硬性规则。
延迟处理在以下情况下最有用：

- 中断所需处理不简单。例如仅存储 ADC 转换结果，几乎总应在 ISR 内完成；
	若还需软件滤波，则可能更适合在任务中执行。

- 中断处理中需要执行 ISR 内无法执行的操作，如写控制台或分配内存。

- 中断处理非确定性——即处理耗时不可预知。

以下各节介绍并演示本章到目前为止的概念，包括可用于实现延迟中断处理的
FreeRTOS 功能。


## 7.4 用于同步的二值信号量

二值信号量的中断安全 API 版本可在每次发生特定中断时解除一个任务的阻塞，
实现任务与中断同步。这使大部分中断事件处理可在同步任务中完成，ISR 中仅保留
快速、简短的部分。正如上一节所述，二值信号量可用于“延迟”中断处理[^14]。

[^14]: 通过“直接任务通知”从中断解除任务阻塞，比使用二值信号量更高效。
直接任务通知直到第 10 章“任务通知”才介绍。

如图 7.1 所示，若中断处理时间要求严格，可提高延迟处理任务的优先级，确保其
总能抢占系统内其他任务。ISR 可调用 `portYIELD_FROM_ISR()`，确保 ISR 直接返回到
该任务。这样可确保事件处理在时间上连续执行（无间断），就像全部在 ISR 内执行
一样。图 7.2 与图 7.1 场景相同，但更新了文本以描述如何用信号量控制延迟处理任务。


<a name="fig7.2" title="Figure 7.2 Using a binary semaphore to implement deferred interrupt processing"></a>

* * *
![](media/image49.png)
***图 7.2*** *使用二值信号量实现延迟中断处理*
* * *

延迟处理任务通过对信号量的阻塞式“获取”进入 *Blocked* 状态等待事件发生。
事件发生时，ISR 对同一信号量执行“释放”，解除任务阻塞并继续事件处理。

“获取信号量”和“释放信号量”的含义随使用场景不同而不同。在该中断同步场景中，
可将二值信号量视作长度为 1 的队列。队列一次最多存放一个元素，因此总是“空”或“满”
（二值）。任务调用 `xSemaphoreTake()` 时，等效于带阻塞时间地从队列读取，若队列为空
则进入 *Blocked* 状态。事件发生时，ISR 调用 `xSemaphoreGiveFromISR()` 将一个令牌
（信号量）放入队列，使队列变满。任务退出 *Blocked* 状态并取走令牌，队列再次变空。
任务完成处理后再次尝试读取队列，发现为空后重新进入 *Blocked* 状态等待下一事件。
该流程见图 7.3。

图 7.3 中，中断“释放”信号量但未先“获取”，任务“获取”信号量但从不“归还”。
因此该场景被描述为与向队列写入/读取概念类似。这常引发混淆，因为它不遵循其他
信号量使用场景中“获取者必须归还”的规则——例如第 8 章“资源管理”中的情形。


<a name="fig7.3" title="Figure 7.3 Using a binary semaphore to synchronize a task with an interrupt"></a>

* * *
![](media/image50.png)
***图 7.3*** *使用二值信号量将任务与中断同步*
* * *


### 7.4.1 xSemaphoreCreateBinary() API 函数

FreeRTOS 还提供 `xSemaphoreCreateBinaryStatic()`，用于在编译期静态分配创建二值
信号量所需的内存：各种 FreeRTOS 信号量的句柄均存放在 `SemaphoreHandle_t` 类型变量中。

信号量使用前必须先创建。创建二值信号量可使用 `xSemaphoreCreateBinary()` API 函数[^15]。

[^15]: 一些信号量 API 实际是宏而非函数。为简洁起见，本书统称为函数。


<a name="list7.3" title="Listing 7.3 The xSemaphoreCreateBinary() API function prototype"></a>

```c
SemaphoreHandle_t xSemaphoreCreateBinary( void );
```
***清单 7.3*** *xSemaphoreCreateBinary() API 函数原型*

**xSemaphoreCreateBinary() 返回值**

- 返回值

	若返回 NULL，则表示堆内存不足，无法为信号量数据结构分配内存。

	若返回非 NULL，则表示信号量创建成功，返回值应保存为该信号量的句柄。


### 7.4.2 xSemaphoreTake() API 函数

“获取”信号量意味着“得到”或“接收”信号量。只有当信号量可用时才能获取。

除递归互斥量外，所有 FreeRTOS 信号量都可使用 `xSemaphoreTake()` 获取。

`xSemaphoreTake()` 不得在中断服务例程中使用。


<a name="list7.4" title="Listing 7.4 The xSemaphoreTake() API function prototype"></a>

```c
BaseType_t xSemaphoreTake( SemaphoreHandle_t xSemaphore, TickType_t xTicksToWait );
```
***清单 7.4*** *xSemaphoreTake() API 函数原型*

**xSemaphoreTake() 参数与返回值**

- `xSemaphore`

	被“获取”的信号量。

	信号量由 `SemaphoreHandle_t` 类型变量引用，必须先显式创建。

- `xTicksToWait`

	若信号量不可用，任务在 *Blocked* 状态等待的最大时间。

	若 `xTicksToWait` 为 0，则 `xSemaphoreTake()` 在信号量不可用时立即返回。

	阻塞时间以 tick 为单位，因此绝对时间取决于 tick 频率。
	可用 `pdMS_TO_TICKS()` 将毫秒转换为 tick。

	若 FreeRTOSConfig.h 中 `INCLUDE_vTaskSuspend` 设为 1，则将 `xTicksToWait`
	设为 `portMAX_DELAY` 会使任务无限期等待（无超时）。

- 返回值

	有两种可能返回值：

	- `pdPASS`

		仅当 `xSemaphoreTake()` 成功获取信号量时返回 `pdPASS`。

		若指定了阻塞时间（`xTicksToWait` 非 0），调用任务可能进入 *Blocked* 状态
		等待信号量，但在超时前信号量变为可用。

	- `pdFALSE`

		信号量不可用。

		若指定了阻塞时间（`xTicksToWait` 非 0），调用任务会进入 *Blocked* 状态等待
		信号量，但在超时前仍未可用。


### 7.4.3 xSemaphoreGiveFromISR() API 函数

二值与计数信号量[^16]可通过 `xSemaphoreGiveFromISR()` “释放”。

[^16]: 计数信号量将在本章稍后介绍。

`xSemaphoreGiveFromISR()` 是 `xSemaphoreGive()` 的中断安全版本，因此带有本章开头
介绍的 `pxHigherPriorityTaskWoken` 参数。


<a name="list" title="Listing 7.5 The xSemaphoreGiveFromISR() API function prototype"></a>

```c
BaseType_t xSemaphoreGiveFromISR( SemaphoreHandle_t xSemaphore,
																	BaseType_t *pxHigherPriorityTaskWoken );
```
***清单 7.5*** *xSemaphoreGiveFromISR() API 函数原型*

**xSemaphoreGiveFromISR() 参数与返回值**

- `xSemaphore`

	被“释放”的信号量。

	信号量由 `SemaphoreHandle_t` 类型变量引用，且必须先显式创建。

- `pxHigherPriorityTaskWoken`

	一个信号量可能有一个或多个任务阻塞在其上等待可用。
	调用 `xSemaphoreGiveFromISR()` 会使信号量可用，从而使等待任务离开 *Blocked* 状态。
	若 `xSemaphoreGiveFromISR()` 使某任务离开 *Blocked* 状态，且该任务优先级高于
	当前执行任务（被中断的任务），则 `xSemaphoreGiveFromISR()` 会将
	`*pxHigherPriorityTaskWoken` 置为 `pdTRUE`。

	若 `xSemaphoreGiveFromISR()` 将该值置为 `pdTRUE`，则通常应在退出中断前执行
	上下文切换，以确保中断直接返回到最高优先级 *Ready* 任务。

- 返回值

	有两种可能返回值：

	- `pdPASS`

		仅当 `xSemaphoreGiveFromISR()` 成功时返回 `pdPASS`。

	- `pdFAIL`

		若信号量已可用，则无法再次释放，`xSemaphoreGiveFromISR()` 返回 `pdFAIL`。


<a name="example7.1" title="Example 7.1 Using a binary semaphore to synchronize a task with an interrupt"></a>
---
***示例 7.1*** *使用二值信号量将任务与中断同步*

---

该示例使用二值信号量在中断服务例程中解除任务阻塞，实现任务与中断同步。

一个简单的周期任务每 500ms 产生一次软件中断。为方便起见使用软件中断，因为在某些
目标环境中接入真实中断较复杂。清单 7.6 给出了周期任务的实现。注意该任务在生成
中断前后都会打印字符串，这使得执行顺序可通过示例输出观察。


<a name="list7.6" title="Listing 7.6 Implementation of the task that periodically generates a software interrupt in Example 7.1"></a>

```c
/* 本示例使用的软件中断号。所示代码来自 Windows 工程，0 到 2 由
	 FreeRTOS Windows 移植自身使用，因此 3 是应用可用的第一个编号。 */
#define mainINTERRUPT_NUMBER 3

static void vPeriodicTask( void *pvParameters )
{
		const TickType_t xDelay500ms = pdMS_TO_TICKS( 500UL );

		/* 与多数任务一样，该任务在无限循环中实现。 */
		for( ;; )
		{
				/* 阻塞直到再次生成软件中断的时间到达。 */
				vTaskDelay( xDelay500ms );

				/* 生成中断，在中断生成前后都打印消息，以便从输出中
					 观察执行顺序。

					 生成软件中断的语法取决于所用 FreeRTOS 移植。下面的
					 语法仅适用于 FreeRTOS Windows 移植，在该移植中这类
					 中断只是模拟的。 */
				vPrintString( "Periodic task - About to generate an interrupt.\r\n" );
				vPortGenerateSimulatedInterrupt( mainINTERRUPT_NUMBER );
				vPrintString( "Periodic task - Interrupt generated.\r\n\r\n\r\n" );
		}
}
```
***清单 7.6*** *示例 7.1 中周期性产生软件中断的任务实现*


清单 7.7 展示延迟处理中断的任务实现——该任务通过二值信号量与软件中断同步。
同样，每次任务循环都会打印字符串，以便从输出中观察任务与中断的执行顺序。

需要注意，清单 7.7 的代码仅适用于示例 7.1 的软件中断场景；在由硬件外设
生成中断的场景下，该结构并不合适。后续小节会说明如何调整结构以适用于
硬件中断。


<a name="list7.7." title="Listing 7.7 The implementation of the task to which the interrupt processing is deferred (the task that..."></a>

```c
static void vHandlerTask( void *pvParameters )
{
		/* 与多数任务一样，该任务在无限循环中实现。 */
		for( ;; )
		{
				/* 使用信号量等待事件。信号量在调度器启动前创建，
					 因此在该任务首次运行之前就已存在。任务无限期阻塞，
					 意味着只有在成功获取信号量后该函数才会返回——
					 因此无需检查 xSemaphoreTake() 的返回值。 */
				xSemaphoreTake( xBinarySemaphore, portMAX_DELAY );

				/* 到达此处表示事件已经发生。处理事件（此处仅打印消息）。 */
				vPrintString( "Handler task - Processing event.\r\n" );
		}
}
```
***清单 7.7*** *示例 7.1 中延迟处理中断的任务实现（与中断同步的任务）*


清单 7.8 展示 ISR 的实现。它几乎只做一件事：释放信号量以解除延迟处理任务的阻塞。

注意 `xHigherPriorityTaskWoken` 变量的用法：在调用 `xSemaphoreGiveFromISR()` 之前
设为 `pdFALSE`，然后作为参数传给 `portYIELD_FROM_ISR()`。若
`xHigherPriorityTaskWoken` 为 `pdTRUE`，`portYIELD_FROM_ISR()` 会请求上下文切换。

ISR 原型和用于强制上下文切换的宏均是 FreeRTOS Windows 移植所需的写法；其他移植
可能不同。请参考 FreeRTOS.org 网站上的移植文档，以及 FreeRTOS 下载包中示例，
以获得所用移植的正确语法。

与多数架构不同，FreeRTOS Windows 移植要求 ISR 返回值。Windows 移植中的
`portYIELD_FROM_ISR()` 宏内部包含返回语句，因此清单 7.8 未显式返回值。


<a name="list7.8" title="Listing 7.8 The ISR for the software interrupt used in Example 7.1"></a>

```c
static uint32_t ulExampleInterruptHandler( void )
{
		BaseType_t xHigherPriorityTaskWoken;

		/* xHigherPriorityTaskWoken 参数必须初始化为 pdFALSE，
			 如果需要上下文切换，中断安全 API 会在内部将其置为 pdTRUE。 */
		xHigherPriorityTaskWoken = pdFALSE;

		/* “释放”信号量以解除任务阻塞，并将 xHigherPriorityTaskWoken 的
			 地址作为中断安全 API 的 pxHigherPriorityTaskWoken 参数传入。 */
		xSemaphoreGiveFromISR( xBinarySemaphore, &xHigherPriorityTaskWoken );

		/* 将 xHigherPriorityTaskWoken 传给 portYIELD_FROM_ISR()。
			 若 xSemaphoreGiveFromISR() 在内部将 xHigherPriorityTaskWoken 设为
			 pdTRUE，则调用 portYIELD_FROM_ISR() 会请求上下文切换。
			 若 xHigherPriorityTaskWoken 仍为 pdFALSE，则调用
			 portYIELD_FROM_ISR() 不会产生效果。与多数 FreeRTOS 移植不同，
			 Windows 移植要求 ISR 返回值——返回语句位于 Windows 版本的
			 portYIELD_FROM_ISR() 内部。 */
		portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
}
```
***清单 7.8*** *示例 7.1 中的软件中断 ISR*

`main()` 函数创建二值信号量、创建任务、安装中断处理程序并启动调度器。
其实现见清单 7.9。

安装中断处理程序的函数语法依赖 FreeRTOS Windows 移植；其他移植可能不同。
请参考 FreeRTOS.org 的移植文档与示例以获得正确语法。


<a name="list7.9" title="Listing 7.9 The implementation of main() for Example 7.1"></a>

```c
int main( void )
{
		/* 使用信号量前必须显式创建。本例创建二值信号量。 */
		xBinarySemaphore = xSemaphoreCreateBinary();

		/* 检查信号量是否创建成功。 */
		if( xBinarySemaphore != NULL )
		{
				/* 创建“handler”任务，即延迟处理中断的任务。
					 该任务与中断同步。为确保中断退出后立即运行，
					 handler 任务以较高优先级创建，本例选择优先级 3。 */
				xTaskCreate( vHandlerTask, "Handler", 1000, NULL, 3, NULL );

				/* 创建周期性产生软件中断的任务。该任务优先级低于 handler 任务，
					 以确保每次 handler 任务离开 Blocked 状态时都能抢占该任务。 */
				xTaskCreate( vPeriodicTask, "Periodic", 1000, NULL, 1, NULL );

				/* 安装软件中断处理程序。所需语法取决于所用 FreeRTOS 移植。
					 此处语法仅适用于 FreeRTOS Windows 移植，在该移植中这类
					 中断只是模拟的。 */
				vPortSetInterruptHandler( mainINTERRUPT_NUMBER,
																	ulExampleInterruptHandler );

				/* 启动调度器，使已创建的任务开始执行。 */
				vTaskStartScheduler();
		}

		/* 按惯例，下面这一行不应被执行。 */
		for( ;; );
}
```
***清单 7.9*** *示例 7.1 的 main() 实现*


示例 7.1 的输出如图 7.4 所示。可见，一旦中断生成，`vHandlerTask()` 立即进入
*Running* 状态，因此任务输出将周期任务输出分割开。图 7.5 给出进一步说明。


<a name="fig7.4" title="Figure 7.4 The output produced when Example 7.1 is executed"></a>
<a name="fig7.5" title="Figure 7.5 The sequence of execution when Example 7.1 is executed"></a>

* * *
![](media/image51.jpg)
***图 7.4*** *示例 7.1 的输出*

![](media/image52.png)
***图 7.5*** *示例 7.1 的执行顺序*
* * *


### 7.4.4 改进示例 7.1 的任务实现

示例 7.1 使用二值信号量将任务与中断同步，其执行顺序如下：

1. 发生中断。

1. ISR 执行并“释放”信号量以解除任务阻塞。

1. 任务在 ISR 之后立即执行并“获取”信号量。

1. 任务处理事件，然后再次尝试“获取”信号量——因信号量尚不可用（下次中断
	 未发生）而进入 *Blocked* 状态。

示例 7.1 的延迟处理中断任务结构仅在中断发生频率较低时才适用。要理解原因，考虑
如果第二个、第三个中断在任务完成第一个中断处理之前发生：

- 当第二次 ISR 执行时，信号量为空，因此 ISR 释放信号量，任务在处理完第一个事件后
	立即处理第二个事件。该场景见图 7.6。

- 当第三次 ISR 执行时，信号量已可用，使 ISR 无法再次释放信号量，因此任务不会知道
	第三个事件已发生。该场景见图 7.7。


<a name="fig7.6" title="Figure 7.6 The scenario when one interrupt occurs before the task has finished processing the first event"></a>
<a name="fig7.7" title="Figure 7.7 The scenario when two interrupts occur before the task has finished processing the first event"></a>

* * *
![](media/image53.png)
***图 7.6*** *当任务尚未完成首次事件处理就发生一次中断的场景*

![](media/image54.png)
***图 7.7*** *当任务尚未完成首次事件处理就发生两次中断的场景*
* * *

示例 7.1 的延迟处理中断任务（清单 7.7）结构使其在每次 `xSemaphoreTake()` 之间
只处理一个事件。这对示例 7.1 足够，因为中断由软件触发且发生时间可预测。在实际应用中，
中断由硬件产生且不可预测。因此，为降低漏中断的可能性，延迟处理中断任务应在每次
`xSemaphoreTake()` 之间处理所有已就绪的事件[^17]。清单 7.10 展示了 UART 延迟中断
处理任务的推荐结构，假设 UART 每接收一个字符就产生一次接收中断，并将字符放入硬件 FIFO。

[^17]: 另一种方式是使用计数信号量或直接任务通知来计数事件。计数信号量在下一节
介绍。直接任务通知在第 10 章介绍，并且在运行时间与 RAM 占用方面最为高效。

示例 7.1 的延迟处理中断任务还存在另一个弱点：调用 `xSemaphoreTake()` 时未设置
超时，而是使用 `portMAX_DELAY`，导致任务无限期等待信号量。示例代码常使用无限等待
以简化结构、便于理解，但真实应用中通常不佳，因为会让错误恢复变得困难。例如，
任务等待中断释放信号量，但硬件错误导致中断无法产生：

- 若任务无超时等待，将无法得知错误，永久等待。

- 若任务带超时等待，则 `xSemaphoreTake()` 在超时后返回 `pdFAIL`，任务即可在
	下一次执行时检测并清除错误。该场景亦在清单 7.10 中演示。


<a name="list7.10" title="Listing 7.10 The recommended structure of a deferred interrupt processing task, using a UART receive..."></a>

```c
static void vUARTReceiveHandlerTask( void *pvParameters )
{
		/* xMaxExpectedBlockTime 保存两次中断之间的最大期望时间。 */
		const TickType_t xMaxExpectedBlockTime = pdMS_TO_TICKS( 500 );

		/* 与多数任务一样，该任务在无限循环中实现。 */
		for( ;; )
		{
				/* 信号量由 UART 接收（Rx）中断“释放”。
					 最多等待 xMaxExpectedBlockTime 个 tick 以接收下一次中断。 */
				if( xSemaphoreTake( xBinarySemaphore, xMaxExpectedBlockTime ) == pdPASS)
				{
						/* 已获取信号量。在再次调用 xSemaphoreTake() 之前处理所有
							 待处理的 Rx 事件。每个 Rx 事件都会在 UART 接收 FIFO 中
							 放入一个字符，假设 UART_RxCount() 返回 FIFO 中字符数量。 */
						while( UART_RxCount() > 0 )
						{
								/* 假设 UART_ProcessNextRxEvent() 处理一个 Rx 字符，
									 使 FIFO 中字符数量减少 1。 */
								UART_ProcessNextRxEvent();
						}

						/* 没有更多待处理的 Rx 事件（FIFO 中无更多字符），
							 因此回到循环并调用 xSemaphoreTake() 等待下一次中断。
							 在此处到 xSemaphoreTake() 调用之间发生的任何中断都会
							 被锁存在信号量中，因此不会丢失。 */
				}
				else
				{
						/* 在期望时间内未收到事件。检查 UART 是否存在错误，
							 必要时清除错误，以防止 UART 无法再产生中断。 */
						UART_ClearErrors();
				}
		}
}
```
***清单 7.10*** *延迟中断处理任务的推荐结构（以 UART 接收处理为例）*


## 7.5 计数信号量

二值信号量可视作长度为 1 的队列，计数信号量可视作长度大于 1 的队列。
任务不关心队列中存放的数据，只关心队列中的项目数量。
要使用计数信号量，必须在 FreeRTOSConfig.h 中将 `configUSE_COUNTING_SEMAPHORES`
设为 1。

每次“释放”计数信号量都会占用队列中的一个空间。队列中的项目数量就是信号量的“计数值”。

计数信号量通常用于两类场景：

1. 计数事件[^18]

	 在该场景中，每次事件发生，事件处理程序都会“释放”一次信号量，使其计数值递增；
	 每次任务处理一个事件就“获取”一次信号量，使计数值递减。计数值等于已发生事件数与
	 已处理事件数之间的差。该机制见图 7.8。

	 用于计数事件的计数信号量初始计数值为 0。

	 [^18]: 使用直接任务通知计数事件比使用计数信号量更高效。直接任务通知将在第 10 章
	 介绍。

1. 资源管理。

	 在该场景中，计数值表示可用资源数量。任务要获得资源必须先获取信号量，
	 从而使计数值递减。当计数值为 0 时，无可用资源。任务完成资源使用后“释放”信号量，
	 计数值递增。

	 用于资源管理的计数信号量初始计数值等于可用资源数量。第 7 章涵盖使用信号量管理资源。


<a name="fig7.8" title="Figure 7.8 Using a counting semaphore to 'count' events"></a>

* * *
![](media/image55.png)
***图 7.8*** *使用计数信号量“计数”事件*
* * *

### 7.5.1 xSemaphoreCreateCounting() API 函数

FreeRTOS 还提供 `xSemaphoreCreateCountingStatic()`，用于在编译期静态分配创建
计数信号量所需内存：各种 FreeRTOS 信号量的句柄均存放在 `SemaphoreHandle_t` 类型变量中。

信号量使用前必须先创建。创建计数信号量可使用 `xSemaphoreCreateCounting()` API 函数。


<a name="list7.11" title="Listing 7.11 The xSemaphoreCreateCounting() API function prototype"></a>

```c
SemaphoreHandle_t xSemaphoreCreateCounting( UBaseType_t uxMaxCount,
																						UBaseType_t uxInitialCount );
```
***清单 7.11*** *xSemaphoreCreateCounting() API 函数原型*


**xSemaphoreCreateCounting() 参数与返回值**

- `uxMaxCount`

	 信号量的最大计数值。继续类比队列，`uxMaxCount` 相当于队列长度。

	 用于计数或锁存事件时，`uxMaxCount` 是可锁存的最大事件数。

	 用于管理资源时，`uxMaxCount` 应设置为可用资源总数。

- `uxInitialCount`

	创建后信号量的初始计数值。

	用于计数或锁存事件时，`uxInitialCount` 应设为 0（创建时假定尚未发生事件）。

	用于管理资源时，`uxInitialCount` 应等于 `uxMaxCount`（创建时假定所有资源可用）。

- 返回值

	若返回 NULL，则表示堆内存不足，无法为信号量分配数据结构。第 3 章提供更多
	堆内存管理信息。

	若返回非 NULL，则表示信号量创建成功，返回值应保存为该信号量句柄。


<a name="example7.2" title="Example 7.2 Using a counting semaphore to synchronize a task with an interrupt"></a>
---
***示例 7.2*** *使用计数信号量将任务与中断同步*

---

示例 7.2 通过使用计数信号量替代二值信号量，改进了示例 7.1 的实现。
`main()` 中将 `xSemaphoreCreateBinary()` 替换为 `xSemaphoreCreateCounting()`。
新的 API 调用见清单 7.12。


<a name="list7.12" title="Listing 7.12 The call to xSemaphoreCreateCounting() used to create the counting semaphore in Example 7.2"></a>

```c
/* 使用信号量前必须显式创建。本例创建计数信号量，其最大计数值为 10，
	 初始计数值为 0。 */
xCountingSemaphore = xSemaphoreCreateCounting( 10, 0 );
```
***清单 7.12*** *示例 7.2 中用于创建计数信号量的 xSemaphoreCreateCounting() 调用*


为模拟高频多事件发生，中断服务例程改为在每次中断中多次“释放”信号量。
每次事件都会被锁存到计数值中。修改后的 ISR 见清单 7.13。


<a name="list7.13" title="Listing 7.13 The implementation of the interrupt service routine used by Example 7.2"></a>

```c
static uint32_t ulExampleInterruptHandler( void )
{
		BaseType_t xHigherPriorityTaskWoken;

		/* xHigherPriorityTaskWoken 参数必须初始化为 pdFALSE，
			 如果需要上下文切换，中断安全 API 会在内部将其置为 pdTRUE。 */
		xHigherPriorityTaskWoken = pdFALSE;

		/* 多次“释放”信号量。第一次释放将解除延迟处理中断任务的阻塞，
			 后续释放用于演示信号量会锁存事件，使延迟处理中断的任务
			 能依次处理而不丢失事件。这模拟了处理器接收到多次中断，
			 尽管本例中的事件是在一次中断中模拟的。 */
		xSemaphoreGiveFromISR( xCountingSemaphore, &xHigherPriorityTaskWoken );
		xSemaphoreGiveFromISR( xCountingSemaphore, &xHigherPriorityTaskWoken );
		xSemaphoreGiveFromISR( xCountingSemaphore, &xHigherPriorityTaskWoken );

		/* 将 xHigherPriorityTaskWoken 传给 portYIELD_FROM_ISR()。
			 若 xSemaphoreGiveFromISR() 在内部将 xHigherPriorityTaskWoken 设为
			 pdTRUE，则调用 portYIELD_FROM_ISR() 会请求上下文切换。
			 若 xHigherPriorityTaskWoken 仍为 pdFALSE，则调用
			 portYIELD_FROM_ISR() 不会产生效果。与多数 FreeRTOS 移植不同，
			 Windows 移植要求 ISR 返回值——返回语句位于 Windows 版本的
			 portYIELD_FROM_ISR() 内部。 */
		portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
}
```
***清单 7.13*** *示例 7.2 中的 ISR 实现*

其余函数与示例 7.1 保持一致。

示例 7.2 的输出如图 7.9 所示。可见延迟处理中断的任务在每次中断发生时都会处理
全部三个（模拟）事件。事件被锁存到信号量计数值中，使任务可以依次处理而不丢失。


<a name="fig7.9" title="Figure 7.9 The output produced when Example 7.2 is executed"></a>

* * *
![](media/image56.jpg)
***图 7.9*** *示例 7.2 的输出*
* * *


## 7.6 将工作延迟到 RTOS 守护任务

前面的延迟中断处理示例需要为每个中断创建一个任务。也可使用
`xTimerPendFunctionCallFromISR()`[^19] 将中断处理延迟到 RTOS 守护任务，从而无需
为每个中断创建单独任务。这称为“集中式延迟中断处理”。

[^19]: 守护任务最初被称为定时器服务任务，因为最初仅用于执行软件定时器回调。
因此 `xTimerPendFunctionCall()` 实现于 timers.c 中，并按“函数名前缀为其实现文件名”
的约定，以 “Timer” 为前缀。

第 6 章说明了软件定时器相关 API 通过定时器命令队列向守护任务发送命令。
`xTimerPendFunctionCall()` 与 `xTimerPendFunctionCallFromISR()` 也使用该定时器
命令队列向守护任务发送“执行函数”的命令。守护任务随后在自身上下文中执行该函数。

集中式延迟中断处理的优点：

- 资源占用更低

	无需为每个延迟处理中断创建独立任务。

- 用户模型更简洁

	延迟处理中断函数就是普通 C 函数。

集中式延迟中断处理的缺点：

- 灵活性较低

	无法为每个延迟处理中断函数单独设置优先级。所有延迟处理中断函数都以守护任务
	的优先级执行。第 6 章提到守护任务优先级由 FreeRTOSConfig.h 中的
	`configTIMER_TASK_PRIORITY` 设置。

- 确定性较低

	`xTimerPendFunctionCallFromISR()` 将命令发送到定时器命令队列尾部。队列中
	已有的命令会先由守护任务处理，再处理该“执行函数”命令。

不同中断具有不同时间约束，因此在同一应用中同时使用两种延迟处理方式是常见的。


### 7.6.1 xTimerPendFunctionCallFromISR() API 函数

`xTimerPendFunctionCallFromISR()` 是 `xTimerPendFunctionCall()` 的中断安全版本。
二者均允许应用编写者提供的函数由 RTOS 守护任务执行，从而在守护任务上下文中运行。
待执行的函数以及其参数值通过定时器命令队列发送给守护任务。因此函数的实际执行时机
取决于守护任务相对其他任务的优先级。


<a name="list7.14" title="Listing 7.14 The xTimerPendFunctionCallFromISR() API function prototype"></a>

```c
BaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t
																					xFunctionToPend,
																					void *pvParameter1,
																					uint32_t ulParameter2,
																					BaseType_t *pxHigherPriorityTaskWoken );
```
***清单 7.14*** *xTimerPendFunctionCallFromISR() API 函数原型*


<a name="list7.15" title="Listing 7.15 The prototype to which a function passed in the xFunctionToPend parameter of xTimerPendFunctionCallFromISR()..."></a>

```c
void vPendableFunction( void *pvParameter1, uint32_t ulParameter2 );
```
***清单 7.15*** *xTimerPendFunctionCallFromISR() 的 xFunctionToPend 参数所指函数的原型*


**xTimerPendFunctionCallFromISR() 参数与返回值**

- `xFunctionToPend`

	指向将由守护任务执行的函数（即函数名）。函数原型必须与清单 7.15 相同。

- `pvParameter1`

	传给守护任务执行函数的 `pvParameter1` 参数值。该参数为 `void *` 类型，以便
	传递任意数据类型。例如可直接将整数类型强制转换为 `void *`，或让 `void *`
	指向结构体。

- `ulParameter2`

	传给守护任务执行函数的 `ulParameter2` 参数值。

- `pxHigherPriorityTaskWoken`

	`xTimerPendFunctionCallFromISR()` 会写定时器命令队列。若守护任务正阻塞在
	队列上等待数据，则写队列会使守护任务离开 *Blocked* 状态。若守护任务优先级
	高于当前执行任务（被中断的任务），则 `xTimerPendFunctionCallFromISR()` 会将
	`*pxHigherPriorityTaskWoken` 置为 `pdTRUE`。

	若该值被置为 `pdTRUE`，则必须在退出中断前执行上下文切换，以确保中断直接返回
	到守护任务（最高优先级 *Ready* 任务）。

- 返回值

	有两种可能返回值：

	- `pdPASS`

		“执行函数”命令成功写入定时器命令队列时返回 `pdPASS`。

	- `pdFAIL`

		若定时器命令队列已满，无法写入“执行函数”命令，则返回 `pdFAIL`。
		第 6 章描述了如何设置定时器命令队列长度。


<a name="example7.3" title="Example 7.3 Centralized deferred interrupt processing"></a>
---
***示例 7.3*** *集中式延迟中断处理*

---

示例 7.3 与示例 7.1 提供类似功能，但不使用信号量，也不创建专门处理中断的任务，
而是由 RTOS 守护任务执行处理。

示例 7.3 的 ISR 见清单 7.16。它调用 `xTimerPendFunctionCallFromISR()` 向守护任务
传递 `vDeferredHandlingFunction()` 的函数指针。实际延迟处理中断的工作由
`vDeferredHandlingFunction()` 完成。

ISR 每次执行都会递增变量 `ulParameterValue`。该值作为 `xTimerPendFunctionCallFromISR()`
的 `ulParameter2` 参数，因此 `vDeferredHandlingFunction()` 被守护任务执行时也会将其
作为 `ulParameter2` 参数。该示例中 `pvParameter1` 未使用。


<a name="list7.16" title="Listing 7.16 The software interrupt handler used in Example 7.3"></a>

```c
static uint32_t ulExampleInterruptHandler( void )
{
		static uint32_t ulParameterValue = 0;
		BaseType_t xHigherPriorityTaskWoken;

		/* xHigherPriorityTaskWoken 参数必须初始化为 pdFALSE，
			 如果需要上下文切换，中断安全 API 会在内部将其置为 pdTRUE。 */
		xHigherPriorityTaskWoken = pdFALSE;

		/* 将中断的延迟处理函数指针发送给守护任务。延迟处理函数的
			 pvParameter1 参数未使用，因此设为 NULL。延迟处理函数的
			 ulParameter2 参数用于传递一个数值，该数值在每次中断处理
			 程序执行时递增。 */
		xTimerPendFunctionCallFromISR( vDeferredHandlingFunction, /* 要执行的函数 */
													 NULL, /* 未使用 */
													 ulParameterValue, /* 递增值。 */
																	 &xHigherPriorityTaskWoken );
		ulParameterValue++;

		/* 将 xHigherPriorityTaskWoken 传给 portYIELD_FROM_ISR()。
			 若 xTimerPendFunctionCallFromISR() 在内部将 xHigherPriorityTaskWoken
			 设为 pdTRUE，则调用 portYIELD_FROM_ISR() 会请求上下文切换。
			 若 xHigherPriorityTaskWoken 仍为 pdFALSE，则调用
			 portYIELD_FROM_ISR() 不会产生效果。与多数 FreeRTOS 移植不同，
			 Windows 移植要求 ISR 返回值——返回语句位于 Windows 版本的
			 portYIELD_FROM_ISR() 内部。 */
		portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
}
```
***清单 7.16*** *示例 7.3 使用的软件中断处理程序*


`vDeferredHandlingFunction()` 的实现见清单 7.17。它输出固定字符串与其 `ulParameter2`
参数值。

即使在本例中仅使用一个参数，`vDeferredHandlingFunction()` 仍必须符合清单 7.15 的原型。


<a name="list7.17" title="Listing 7.17 The function that performs the processing necessitated by the interrupt in Example 7.3"></a>

```c
static void vDeferredHandlingFunction( void *pvParameter1, uint32_t ulParameter2 )
{
		/* 处理事件——此处仅打印一条消息和 ulParameter2 的值。
			 本示例未使用 pvParameter1。 */
		vPrintStringAndNumber( "Handler function - Processing event ", ulParameter2 );
}
```
***清单 7.17*** *示例 7.3 中执行中断处理的函数*


示例 7.3 的 `main()` 实现见清单 7.18。它比示例 7.1 简化，因为无需创建信号量或
专门的延迟处理中断任务。

`vPeriodicTask()` 是周期性产生软件中断的任务。它以低于守护任务的优先级创建，
确保守护任务从 *Blocked* 状态离开后可抢占该任务。


<a name="list7.18" title="Listing 7.18 The implementation of main() for Example 7.3"></a>

```c
int main( void )
{
		/* 生成软件中断的任务以低于守护任务的优先级创建。
			 守护任务优先级由 FreeRTOSConfig.h 中的编译期配置常量
			 configTIMER_TASK_PRIORITY 设置。 */
		const UBaseType_t ulPeriodicTaskPriority = configTIMER_TASK_PRIORITY - 1;

		/* 创建周期性产生软件中断的任务。 */
		xTaskCreate( vPeriodicTask, "Periodic", 1000, NULL, ulPeriodicTaskPriority,
								 NULL );

		/* 安装软件中断处理程序。所需语法取决于所用 FreeRTOS 移植。
			 此处语法仅适用于 FreeRTOS Windows 移植，在该移植中这类
			 中断只是模拟的。 */
		vPortSetInterruptHandler( mainINTERRUPT_NUMBER, ulExampleInterruptHandler );

		/* 启动调度器，使已创建的任务开始执行。 */
		vTaskStartScheduler();

		/* 按惯例，下面这一行不应被执行。 */
		for( ;; );
}
```
***清单 7.18*** *示例 7.3 的 main() 实现*


示例 7.3 的输出如图 7.10 所示。守护任务优先级高于产生软件中断的任务，因此
`vDeferredHandlingFunction()` 会在中断产生后立即由守护任务执行。
这使 `vDeferredHandlingFunction()` 的输出出现在周期任务的两条输出之间，
与使用信号量解阻专用延迟处理中断任务时一致。图 7.11 给出进一步说明。


<a name="fig7.10" title="Figure 7.10 The output produced when Example 7.3 is executed"></a>
<a name="fig7.11" title="Figure 7.11 The sequence of execution when Example 7.3 is executed"></a>

* * *
![](media/image57.jpg)
***图 7.10*** *示例 7.3 的输出*

![](media/image58.png)
***图 7.11*** *示例 7.3 的执行顺序*
* * *


## 7.7 在 ISR 中使用队列

二值与计数信号量用于传递事件；队列则用于传递事件与数据。

`xQueueSendToFrontFromISR()` 是 `xQueueSendToFront()` 的中断安全版本，
`xQueueSendToBackFromISR()` 是 `xQueueSendToBack()` 的中断安全版本，
`xQueueReceiveFromISR()` 是 `xQueueReceive()` 的中断安全版本。


### 7.7.1 xQueueSendToFrontFromISR() 与 xQueueSendToBackFromISR() API 函数


<a name="list7.19" title="Listing 7.19 The xQueueSendToFrontFromISR() API function prototype"></a>

```c
BaseType_t xQueueSendToFrontFromISR( QueueHandle_t xQueue,
																		 const void *pvItemToQueue
																		 BaseType_t *pxHigherPriorityTaskWoken );
```
***清单 7.19*** *xQueueSendToFrontFromISR() API 函数原型*


<a name="list7.20" title="Listing 7.20 The xQueueSendToBackFromISR() API function prototype"></a>

```c
BaseType_t xQueueSendToBackFromISR( QueueHandle_t xQueue,
																		const void *pvItemToQueue
																		BaseType_t *pxHigherPriorityTaskWoken );
```
***清单 7.20*** *xQueueSendToBackFromISR() API 函数原型*


`xQueueSendFromISR()` 与 `xQueueSendToBackFromISR()` 功能等价。

**xQueueSendToFrontFromISR() 与 xQueueSendToBackFromISR() 参数与返回值**

- `xQueue`

	要发送（写入）数据的队列句柄。该句柄由 `xQueueCreate()` 返回。

- `pvItemToQueue`

	指向要写入队列的数据项。

	队列创建时已指定每个队列项的大小，因此会从 `pvItemToQueue` 拷贝该字节数到
	队列存储区。

- `pxHigherPriorityTaskWoken`

	一个队列可能有一个或多个任务阻塞在其上等待数据。调用
	`xQueueSendToFrontFromISR()` 或 `xQueueSendToBackFromISR()` 可使数据可用，从而
	使等待任务离开 *Blocked* 状态。若调用 API 使任务离开 *Blocked* 状态，且该任务
	优先级高于当前执行任务（被中断的任务），则 API 内部会将
	`*pxHigherPriorityTaskWoken` 置为 `pdTRUE`。

	若 `xQueueSendToFrontFromISR()` 或 `xQueueSendToBackFromISR()` 将该值置为
	`pdTRUE`，则应在退出中断前执行上下文切换，确保中断直接返回到最高优先级
	*Ready* 任务。

- 返回值

	有两种可能返回值：

	- `pdPASS`

		仅当数据成功发送到队列时返回 `pdPASS`。

	- `errQUEUE_FULL

		若队列已满，无法发送数据，则返回 `errQUEUE_FULL`。


### 7.7.2 在 ISR 中使用队列的注意事项

队列提供了将数据从中断传递到任务的简便方式，但当数据高频到达时，使用队列并不高效。

FreeRTOS 下载包的许多演示应用包含使用队列从 UART 接收 ISR 中传出字符的简单 UART 驱动。
这些示例之所以使用队列，一是演示 ISR 中使用队列，二是刻意增加负载以测试移植。
这些 ISR 设计并非高效设计，除非数据到达很慢，否则不建议生产代码采用该技术。
更高效且适合生产的技术包括：

- 使用 DMA 接收并缓冲字符。该方法几乎无软件开销。然后可用直接任务通知[^20]
	在检测到传输中断后解除处理缓冲区任务的阻塞。

	[^20]: 直接任务通知是 ISR 中解除任务阻塞的最高效方法，详见第 10 章“任务通知”。

- 将每个接收字符拷贝到线程安全的 RAM 缓冲区[^21]。同样，可在收到完整消息或检测到
	传输中断后，用直接任务通知解除处理缓冲区任务的阻塞。

	[^21]: FreeRTOS+TCP 中的“Stream Buffer”（[https://www.FreeRTOS.org/tcp](http://www.FreeRTOS.org/tcp)）
	可用于此目的。

- 在 ISR 内直接处理接收字符，然后使用队列将处理结果（而非原始数据）发送到任务。
	图 5.4 已演示此方法。

<a name="example7.4" title="Example 7.4 Sending and receiving on a queue from within an interrupt"></a>
---
***示例 7.4*** *在中断中使用队列发送与接收*

---

该示例演示在同一中断中使用 `xQueueSendToBackFromISR()` 与 `xQueueReceiveFromISR()`。
同样，为方便起见，使用软件中断。

创建一个周期任务，每 200ms 向队列发送 5 个数字，且仅在全部 5 个值发送完后
才产生软件中断。任务实现见清单 7.21。


<a name="list7.21" title="Listing 7.21 The implementation of the task that writes to the queue in Example 7.4"></a>

```c
static void vIntegerGenerator( void *pvParameters )
{
		TickType_t xLastExecutionTime;
		uint32_t ulValueToSend = 0;
		int i;

		/* 初始化用于 vTaskDelayUntil() 调用的变量。 */
		xLastExecutionTime = xTaskGetTickCount();

		for( ;; )
		{
				/* 这是周期性任务。阻塞直到再次运行的时间到达。
					 该任务每 200ms 执行一次。 */
				vTaskDelayUntil( &xLastExecutionTime, pdMS_TO_TICKS( 200 ) );

				/* 向队列发送 5 个数字，每个值比前一个大 1。
					 这些数字由中断服务例程从队列中读取。中断服务例程
					 会总是清空队列，因此该任务无需设置阻塞时间也能
					 保证写入全部 5 个值。 */
				for( i = 0; i < 5; i++ )
				{
						xQueueSendToBack( xIntegerQueue, &ulValueToSend, 0 );
						ulValueToSend++;
				}

				/* 生成中断，使中断服务例程能从队列读取数据。
					 生成软件中断的语法取决于所用 FreeRTOS 移植。下面的
					 语法仅适用于 FreeRTOS Windows 移植，在该移植中这类
					 中断只是模拟的。 */
				vPrintString( "Generator task - About to generate an interrupt.\r\n" );
				vPortGenerateSimulatedInterrupt( mainINTERRUPT_NUMBER );
				vPrintString( "Generator task - Interrupt generated.\r\n\r\n\r\n" );
		}
}
```
***清单 7.21*** *示例 7.4 中写队列任务的实现*


ISR 会反复调用 `xQueueReceiveFromISR()`，直到将周期任务写入队列的所有值读出，
并使队列清空。每个接收值的最后两位用作字符串数组索引，然后使用
`xQueueSendFromISR()` 将对应字符串指针发送到另一队列。ISR 实现见清单 7.22。


<a name="list7.22" title="Listing 7.22 The implementation of the interrupt service routine used by Example 7.4"></a>

```c
static uint32_t ulExampleInterruptHandler( void )
{
		BaseType_t xHigherPriorityTaskWoken;
		uint32_t ulReceivedNumber;

		/* 字符串声明为 static const，以确保它们不会分配在
			 中断服务例程的栈上，从而在 ISR 不执行时也仍然存在。 */

		static const char *pcStrings[] =
		{
				"String 0\r\n",
				"String 1\r\n",
				"String 2\r\n",
				"String 3\r\n"
		};

		/* 按惯例，xHigherPriorityTaskWoken 初始化为 pdFALSE，以便检测
			 中断安全 API 是否将其置为 pdTRUE。注意中断安全 API 只能将
			 xHigherPriorityTaskWoken 设为 pdTRUE，因此在调用
			 xQueueReceiveFromISR() 和 xQueueSendToBackFromISR() 时复用同一个
			 xHigherPriorityTaskWoken 变量是安全的。 */
		xHigherPriorityTaskWoken = pdFALSE;

		/* 从队列读取直到队列为空。 */
		while( xQueueReceiveFromISR( xIntegerQueue,
																 &ulReceivedNumber,
																 &xHigherPriorityTaskWoken ) != errQUEUE_EMPTY )
		{
				/* 将接收值截断为最低两位（取值 0 到 3），再将截断后的值
					 作为 pcStrings[] 的索引，选择要发送到另一队列的
					 字符串（char *）。 */
				ulReceivedNumber &= 0x03;
				xQueueSendToBackFromISR( xStringQueue,
																 &pcStrings[ ulReceivedNumber ],
																 &xHigherPriorityTaskWoken );
		}

		/* 如果从 xIntegerQueue 接收导致某任务离开 Blocked 状态，且该任务
			 的优先级高于当前 Running 状态任务，则 xQueueReceiveFromISR()
			 会在内部将 xHigherPriorityTaskWoken 设为 pdTRUE。

			 如果向 xStringQueue 发送导致某任务离开 Blocked 状态，且该任务
			 的优先级高于当前 Running 状态任务，则 xQueueSendToBackFromISR()
			 会在内部将 xHigherPriorityTaskWoken 设为 pdTRUE。

			 xHigherPriorityTaskWoken 用作 portYIELD_FROM_ISR() 的参数。
			 若 xHigherPriorityTaskWoken 等于 pdTRUE，则调用
			 portYIELD_FROM_ISR() 会请求上下文切换；若仍为 pdFALSE，
			 调用 portYIELD_FROM_ISR() 则不会产生效果。

			 Windows 移植中 portYIELD_FROM_ISR() 的实现包含返回语句，
			 因此该函数未显式返回值。 */
		portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
}
```
***清单 7.22*** *示例 7.4 使用的 ISR 实现*


接收字符串指针的任务在队列上阻塞等待消息到达，并在收到时打印字符串。
其实现见清单 7.23。


<a name="list7.23" title="Listing 7.23 The task that prints out the strings received from the interrupt service routine in Example 7.4"></a>

```c
static void vStringPrinter( void *pvParameters )
{
		char *pcString;

		for( ;; )
		{
				/* 阻塞在队列上等待数据到达。 */
				xQueueReceive( xStringQueue, &pcString, portMAX_DELAY );

				/* 打印接收到的字符串。 */
				vPrintString( pcString );
		}
}
```
***清单 7.23*** *示例 7.4 中打印 ISR 接收字符串的任务*

与往常一样，`main()` 在启动调度器前创建所需队列与任务。其实现见清单 7.24。


<a name="list7.24" title="Listing 7.24 The main() function for Example 7.4"></a>

```c
int main( void )
{
		/* 使用队列前必须先创建。本例创建两个队列：一个保存 uint32_t，
			 另一个保存 char*。两个队列最多可容纳 10 个条目。真实应用
			 应检查返回值以确保队列创建成功。 */
		xIntegerQueue = xQueueCreate( 10, sizeof( uint32_t ) );
		xStringQueue = xQueueCreate( 10, sizeof( char * ) );

		/* 创建通过队列向中断服务例程传递整数的任务，优先级为 1。 */
		xTaskCreate( vIntegerGenerator, "IntGen", 1000, NULL, 1, NULL );

		/* 创建用于打印中断服务例程发送的字符串的任务，优先级为 2。 */
		xTaskCreate( vStringPrinter, "String", 1000, NULL, 2, NULL );

		/* 安装软件中断处理程序。所需语法取决于所用 FreeRTOS 移植。
			 此处语法仅适用于 FreeRTOS Windows 移植，在该移植中这类
			 中断只是模拟的。 */
		vPortSetInterruptHandler( mainINTERRUPT_NUMBER, ulExampleInterruptHandler );

		/* 启动调度器，使已创建的任务开始执行。 */
		vTaskStartScheduler();

		/* 如果一切正常，调度器将运行任务，main() 不会到达这里。
			 若 main() 到达此处，很可能是堆内存不足以创建空闲任务。
			 第 2 章提供了更多堆内存管理信息。 */
		for( ;; );
}
```
***清单 7.24*** *示例 7.4 的 main() 函数*

示例 7.4 的输出如图 7.12 所示。可见中断接收了全部 5 个整数，并产生 5 条字符串响应。
图 7.13 给出更详细说明。


<a name="fig7.12" title="Figure 7.12 The output produced when Example 7.4 is executed"></a>
<a name="fig7.13" title="Figure 7.13 The sequence of execution produced by Example 7.4"></a>

* * *
![](media/image59.jpg)
***图 7.12*** *示例 7.4 的输出*

![](media/image60.png)
***图 7.13*** *示例 7.4 的执行顺序*
* * *


## 7.8 中断嵌套

任务优先级与中断优先级常被混淆。本节讨论中断优先级，即 ISR 之间的相对执行优先级。
任务优先级与中断优先级无关：硬件决定 ISR 何时执行，软件决定任务何时执行。
硬件中断触发的 ISR 会打断任务，但任务无法抢占 ISR。

支持中断嵌套的移植要求在 FreeRTOSConfig.h 中定义以下常量之一或两者：
`configMAX_SYSCALL_INTERRUPT_PRIORITY` 与 `configMAX_API_CALL_INTERRUPT_PRIORITY`
表达相同属性。较老的移植使用前者，较新的移植使用后者。

**控制中断嵌套的常量**

- `configMAX_SYSCALL_INTERRUPT_PRIORITY` 或 `configMAX_API_CALL_INTERRUPT_PRIORITY`

	设置可调用中断安全 FreeRTOS API 的最高中断优先级。

- `configKERNEL_INTERRUPT_PRIORITY`

	设置 tick 中断的优先级，必须始终设置为最低可能的中断优先级。

	若所用移植不使用 `configMAX_SYSCALL_INTERRUPT_PRIORITY`，则凡调用中断安全
	FreeRTOS API 的中断均必须以 `configKERNEL_INTERRUPT_PRIORITY` 指定的优先级执行。

每个中断源都有数值优先级与逻辑优先级：

- 数值优先级

	数值优先级就是分配给中断的数字。例如优先级为 7，则数值优先级为 7；
	优先级为 200，则数值优先级为 200。

- 逻辑优先级

	逻辑优先级描述该中断相对于其他中断的优先级。

	若两个不同优先级的中断同时发生，处理器将先执行逻辑优先级更高的 ISR。

	一个中断可以打断（嵌套）任何逻辑优先级更低的中断，但不能打断逻辑优先级
	相同或更高的中断。

数值优先级与逻辑优先级之间的关系取决于处理器架构：有的架构数值越高逻辑优先级越高，
有的架构数值越高逻辑优先级越低。

通过将 `configMAX_SYSCALL_INTERRUPT_PRIORITY` 设置为高于
`configKERNEL_INTERRUPT_PRIORITY` 的逻辑优先级，可建立完整的中断嵌套模型。图 7.14
展示了以下场景：

- 处理器有 7 个唯一中断优先级。
- 数值优先级 7 的逻辑优先级高于数值优先级 1。
- `configKERNEL_INTERRUPT_PRIORITY` 设为 1。
- `configMAX_SYSCALL_INTERRUPT_PRIORITY` 设为 3。


<a name="fig7.14" title="Figure 7.14 Constants affecting interrupt nesting behavior"></a>

* * *
![](media/image61.png)
***图 7.14*** *影响中断嵌套行为的常量*
* * *

参见图 7.14：

- 使用优先级 1~3（含） 的中断在内核或应用进入临界区时会被屏蔽。
	这些优先级的 ISR 可调用中断安全 FreeRTOS API 函数。临界区见第 8 章。

- 使用优先级 4 或更高的中断不受临界区影响，因此调度器无法阻止其立即执行
	（受硬件本身限制）。这些优先级的 ISR 不能调用任何 FreeRTOS API 函数。

- 通常需要极严格定时精度的功能（如电机控制）会使用高于
	`configMAX_SYSCALL_INTERRUPT_PRIORITY` 的优先级，以确保调度器不会引入
	中断响应抖动。


### 7.8.1 给 ARM Cortex-M[^22] 与 ARM GIC 用户的提示

[^22]: 本节仅部分适用于 Cortex-M0 与 Cortex-M0+ 内核。

Cortex-M 处理器的中断配置较为复杂且易出错。为帮助开发，FreeRTOS Cortex-M 移植
会自动检查中断配置，但仅在定义了 `configASSERT()` 时才会启用。`configASSERT()`
在 11.2 节介绍。

ARM Cortex 内核与 ARM 通用中断控制器（GIC）使用数值*低*的优先级表示逻辑*高*
的中断。这看起来反直觉且易忘。若要分配逻辑低优先级，则必须使用数值高；
若要分配逻辑高优先级，则必须使用数值低。

Cortex-M 中断控制器最多使用 8 位设置中断优先级，最低优先级为 255，最高为 0。
但 Cortex-M 微控制器通常只实现其中一部分位，具体取决于芯片系列。

当只实现部分位时，只能使用该字节的高位（最显著位），低位未实现。未实现位可取
任意值，但通常设为 1。图 7.15 展示了在实现 4 位优先级的 Cortex-M 微控制器中，
二进制 101 的优先级如何存储。


<a name="fig7.15" title="Figure 7.15 How a priority of binary 101 is stored by a Cortex-M microcontroller that implements four priority bits"></a>

* * *
![](media/image62.png)
***图 7.15*** *实现 4 位优先级的 Cortex-M 微控制器如何存储二进制 101 的优先级*
* * *

在图 7.15 中，二进制 101 被左移到最显著 4 位，因为最低 4 位未实现。未实现位设为 1。

某些库函数期望在将优先级值左移到已实现（最显著）位之后再传入。例如图 7.15
所示优先级可指定为十进制 95。十进制 95 是二进制 101 左移 4 位得到的 101nnnn
（n 为未实现位），并将未实现位设为 1 得到 1011111。

另一些库函数期望在左移前传入优先级值。例如图 7.15 所示优先级应指定为十进制 5，
即二进制 101 未移位的值。

`configMAX_SYSCALL_INTERRUPT_PRIORITY` 与 `configKERNEL_INTERRUPT_PRIORITY`
必须以可直接写入 Cortex-M 寄存器的方式指定，也就是左移到已实现位之后的值。

`configKERNEL_INTERRUPT_PRIORITY` 必须始终设为最低可能的中断优先级。未实现的
优先级位可设为 1，因此该常量可始终设为 255，不受实际实现位数影响。

Cortex-M 中断默认优先级为 0，即最高优先级。Cortex-M 硬件不允许将
`configMAX_SYSCALL_INTERRUPT_PRIORITY` 设为 0，因此调用 FreeRTOS API 的中断
不得保持默认优先级。
