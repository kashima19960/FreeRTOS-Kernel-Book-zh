# 4 任务管理

## 4.1 简介

### 4.1.1 范围

本章涵盖：

- FreeRTOS 如何为应用中的每个任务分配处理时间。
- FreeRTOS 如何选择在任意时刻执行哪个任务。
- 各任务相对优先级如何影响系统行为。
- 任务可处于的状态。

本章还讨论：

- 如何实现任务。
- 如何创建一个或多个任务实例。
- 如何使用任务参数。
- 如何更改已创建任务的优先级。
- 如何删除任务。
- 如何使用任务实现周期性处理。（后续章节还会介绍使用软件定时器实现同样效果。）
- 空闲任务何时执行以及可如何利用它。

本章中的概念是理解 FreeRTOS 用法与 FreeRTOS 应用行为的基础，因此这是本书中
最为详细的章节。

## 4.2 任务函数

任务以 C 函数的形式实现。任务必须实现清单 4.1 所示的函数原型，该原型接收
一个 `void *` 参数并返回 `void`。

<a name="list4.1" title="清单 4.1 任务函数原型"></a>

```c
void vATaskFunction( void * pvParameters );
```

***清单 4.1*** *任务函数原型*


每个任务本身就是一个小程序。它有入口点，通常会在无限循环中运行，并不会退出。
清单 4.2 展示了典型任务的结构。

FreeRTOS 任务绝不能以任何方式从实现它的函数返回。它不应包含 `return` 语句，
也不能让执行流越过实现函数的末尾。如果任务不再需要，应显式删除，如清单 4.2
所示。

一个任务函数定义可以用来创建任意数量的任务，每个创建出的任务都是独立的执行
实例。每个实例都有自己的栈，因此拥有任务内部定义的任何自动（栈）变量的独立副本。


<a name="list4.2" title="清单 4.2 典型任务函数结构"></a>


```c
void vATaskFunction( void * pvParameters )
{
		/*
		 * 在函数内部可以像平常一样声明栈分配变量。
		 * 使用此示例函数创建的每个任务实例，都会在任务栈上
		 * 分配自己独立的 lStackVariable 实例。
		 */
		long lStackVariable = 0;

		/*
		 * 与栈分配变量相对，使用 `static` 关键字声明的变量由链接器
		 * 分配到特定内存位置。这意味着所有调用 vATaskFunction 的任务
		 * 将共享同一个 lStaticVariable 实例。
		 */
		static long lStaticVariable = 0;

		for( ;; )
		{
				/* 任务功能的实现代码放在这里。 */
		}

		/*
		 * 如果任务实现退出了上述循环，则必须在到达实现函数末尾前
		 * 删除该任务。当向 vTaskDelete() API 函数传入 NULL 参数时，
		 * 表示要删除的是调用该函数的（本）任务。
		 */
		vTaskDelete( NULL );
}
```

***清单 4.2*** *典型任务函数结构*

## 4.3 顶层任务状态

一个应用可能包含多个任务。如果运行应用的处理器只有一个核心，那么任一时刻
只能有一个任务在执行。这意味着任务可能处于两种状态之一：*Running* 与
*Not Running*。先从这种简化模型开始，稍后本章会介绍 *Not Running* 状态下的
多个子状态。

当处理器正在执行某任务的代码时，该任务处于 *Running* 状态。当任务处于
*Not Running* 状态时，任务会被暂停，其状态被保存，以便调度器下次决定它进入
*Running* 状态时能够继续执行。任务恢复执行时，会从其离开 *Running* 状态前
即将执行的指令处继续。


<a name="fig4.1" title="图 4.1 顶层任务状态与转换"></a>

***
![](media/figure_4.1_top_level_task_states.png)
***图 4.1*** *顶层任务状态与转换*
***

任务从 *Not Running* 状态转换到 *Running* 状态称为 “switched in” 或
“swapped in”。相反，任务从 *Running* 状态转换到 *Not Running* 状态称为
“switched out” 或 “swapped out”。FreeRTOS 调度器是唯一能够将任务在
*Running* 状态内外切换的实体。

## 4.4 任务创建

可用于创建任务的 API 函数共有六个：
`xTaskCreate()`、
`xTaskCreateStatic()`、
`xTaskCreateRestricted()`、
`xTaskCreateRestrictedStatic()`、
`xTaskCreateAffinitySet()` 和
`xTaskCreateStaticAffinitySet()`。

每个任务需要两块 RAM：一块用于保存任务控制块（TCB），一块用于保存任务栈。
名称中包含 “Static” 的 FreeRTOS API 函数使用由参数传入的预分配 RAM。相反，
名称中不包含 “Static” 的 API 函数会在运行时从系统堆中动态分配所需 RAM。

部分 FreeRTOS port 支持任务在“受限”或“非特权”模式下运行。名称中包含
“Restricted” 的 API 函数创建执行时对系统内存访问受限的任务；名称中不包含
“Restricted” 的 API 函数创建在“特权模式”下执行、可访问系统完整内存映射的任务。

支持对称多处理（SMP）的 FreeRTOS port 允许不同任务在同一 CPU 的多个核心上
同时运行。对于这些 port，可以使用名称中包含 “Affinity” 的函数来指定任务将运行
在哪个核心上。

FreeRTOS 的任务创建 API 比较复杂。本书大多数示例使用 `xTaskCreate()`，因为
它是这些函数中最简单的一个。

### 4.4.1 xTaskCreate() API 函数

清单 4.3 给出了 `xTaskCreate()` API 函数原型。`xTaskCreateStatic()` 额外增加
两个参数，分别指向预先分配用于保存任务数据结构和栈的内存。有关使用的数据类型
与命名规范，请参阅 [第 2.5 节：数据类型与编码风格指南](ch02-FreeRTOS%20内核分发包.md#25-数据类型与编码风格指南)。


<a name="list4.3" title="清单 4.3 xTaskCreate() API 函数原型"></a>


```c
BaseType_t xTaskCreate( TaskFunction_t pvTaskCode,
												const char * const pcName,
												configSTACK_DEPTH_TYPE usStackDepth,
												void * pvParameters,
												UBaseType_t uxPriority,
												TaskHandle_t * pxCreatedTask );
```

***清单 4.3*** *xTaskCreate() API 函数原型*

**xTaskCreate() 参数与返回值：**

- `pvTaskCode`

	任务本质上是永不退出的 C 函数，因此通常以无限循环实现。
	`pvTaskCode` 参数就是指向实现该任务的函数的指针（实际上就是函数名）。

- `pcName`

	任务的描述性名称。FreeRTOS 不会以任何方式使用该名称，加入它仅用于调试。
	用可读名称识别任务比使用任务句柄更容易。

	应用定义常量 `configMAX_TASK_NAME_LEN` 指定任务名的最大长度（包含 NULL 终止符）。
	若字符串更长，将被截断。

- `usStackDepth`

	指定为任务分配的栈大小。
	若要使用预分配内存而非动态分配内存，请使用 `xTaskCreateStatic()` 代替
	`xTaskCreate()`。

	注意该值表示栈可容纳的 *字数*，而非字节数。例如，若栈宽为 32 位且
	`usStackDepth` 为 128，则 `xTaskCreate()` 分配 512 字节栈空间（128 * 4 字节）。

	`configSTACK_DEPTH_TYPE` 是宏，用于指定保存栈大小的数据类型。
	若未定义，`configSTACK_DEPTH_TYPE` 默认是 `uint16_t`，因此当栈深度
	乘以栈宽度大于 65535（16 位最大值）时，请在 FreeRTOSConfig.h 中将
	`configSTACK_DEPTH_TYPE` 定义为 `unsigned long` 或 `size_t`。

	[第 13.3 节：栈溢出](ch13-故障排查.md#133-栈溢出) 介绍了选择最优栈大小的实用方法。

- `pvParameters`

	任务函数接受一个 `void *` 参数。`pvParameters` 是通过该参数传入任务的值。

- `uxPriority`

	指定任务优先级。0 为最低优先级，`(configMAX_PRIORITIES – 1)` 为最高优先级。
	[第 4.5 节](#45-任务优先级) 描述了用户定义的 `configMAX_PRIORITIES` 常量。

	若定义的 `uxPriority` 大于 `(configMAX_PRIORITIES – 1)`，将被自动限制为
	`(configMAX_PRIORITIES – 1)`。

- `pxCreatedTask`

	指向用于保存已创建任务句柄的位置。该句柄可用于后续 API 调用，例如修改任务
	优先级或删除任务。

	`pxCreatedTask` 是可选参数，若不需要任务句柄可设为 NULL。

- 返回值

	有两种返回值：

	- `pdPASS`

		表示任务创建成功。

	- `pdFAIL`

		表示堆内存不足，无法创建任务。
		[第 3 章](ch03-堆内存管理.md#3-堆内存管理) 提供了堆内存管理的更多信息。


<a name="example4.1" title="示例 4.1 创建任务"></a>
---
***示例 4.1*** *创建任务*

---

以下示例演示如何创建两个简单任务并启动它们。任务通过一个粗糙的忙等循环
来产生周期性延迟，从而周期性打印字符串。两个任务在相同优先级创建，且完全相同，
仅输出字符串不同——各自实现见清单 4.4 与清单 4.5。关于在任务中使用 `printf()`
的警告请参见第 8 章。

<a name="list4.4" title="清单 4.4 示例 4.1 中第一个任务的实现"></a>


```c
void vTask1( void * pvParameters )
{
		/* ulCount 声明为 volatile，以确保不会被优化掉。 */
		volatile unsigned long ulCount;

		for( ;; )
		{
				/* 打印当前任务的名称。 */
				vPrintLine( "Task 1 is running" );

				/* 延时一段时间。 */
				for( ulCount = 0; ulCount < mainDELAY_LOOP_COUNT; ulCount++ )
				{
						/*
						 * 该循环只是一个非常粗糙的延时实现。
						 * 这里没有任何事情要做。后续示例会用
						 * 合适的延时/休眠函数替代该粗糙循环。
						 */
				}
		}
}
```

***清单 4.4*** *示例 4.1 中第一个任务的实现*


<a name="list4.5" title="清单 4.5 示例 4.1 中第二个任务的实现"></a>


```c
void vTask2( void * pvParameters )
{
		/* ulCount 声明为 volatile，以确保不会被优化掉。 */
		volatile unsigned long ulCount;

		/* 按多数任务的惯例，该任务以无限循环实现。 */
		for( ;; )
		{
				/* 打印该任务的名称。 */
				vPrintLine( "Task 2 is running" );

				/* 延时一段时间。 */
				for( ulCount = 0; ulCount < mainDELAY_LOOP_COUNT; ulCount++ )
				{
						/*
						 * 该循环只是一个非常粗糙的延时实现。
						 * 这里没有任何事情要做。后续示例会用
						 * 合适的延时/休眠函数替代该粗糙循环。
						 */
				}
		}
}
```

***清单 4.5*** *示例 4.1 中第二个任务的实现*

`main()` 函数在启动调度器之前创建任务——其实现见清单 4.6。


<a name="list4.6" title="清单 4.6 启动示例 4.1 的任务"></a>


```c
int main( void )
{
		/*
		 * 启动 FreeRTOS 调度器后，此处声明的变量可能不再存在。
		 * 不要在任务中访问 main() 所用栈上声明的变量。
		 */

		/*
		 * 创建两个任务中的一个。注意，真实应用应检查 xTaskCreate()
		 * 的返回值，以确保任务创建成功。
		 */
		xTaskCreate( vTask1,  /* 指向实现该任务的函数的指针。*/
							 "Task 1",/* 任务的文本名称。 */
							 1000,    /* 以字为单位的栈深度。 */
							 NULL,    /* 本示例不使用任务参数。 */
							 1,       /* 该任务以优先级 1 运行。 */
							 NULL );  /* 本示例不使用任务句柄。 */

		/* 以完全相同方式、相同优先级创建另一个任务。*/
		xTaskCreate( vTask2, "Task 2", 1000, NULL, 1, NULL );

		/* 启动调度器，使任务开始执行。 */
		vTaskStartScheduler();

		/*
		 * 一切正常时 main() 不会到达这里，因为调度器已在运行已创建的任务。
		 * 如果 main() 到达这里，说明堆内存不足，无法创建空闲任务或定时器任务
		 *（本书后续章节描述）。第 3 章提供更多堆内存管理信息。
		 */
		for( ;; );
}
```

***清单 4.6*** *启动示例 4.1 的任务*

执行示例会产生图 4.2 所示的输出。


<a name="fig4.2" title="图 4.2 执行示例 4.1 的输出"></a>

***

```console
C:\Temp>rtosdemo
Task 1 is running
Task 2 is running
Task 1 is running
Task 2 is running
Task 1 is running
Task 2 is running
Task 1 is running
Task 2 is running
Task 1 is running
Task 2 is running
Task 1 is running
Task 2 is running
Task 1 is running
Task 2 is running
```

***图 4.2*** *执行示例 4.1 的输出[^4]*

***

[^4]: 屏幕截图显示每个任务在下一个任务执行前只打印一次消息。这是由于使用
Windows 模拟器造成的“人为”场景。Windows 模拟器并不是真实时系统。此外，
向 Windows 控制台写入耗时较长，并会触发一连串 Windows 系统调用。在真实嵌入式
目标上使用快速且非阻塞的打印函数时，可能会出现每个任务在被切换出去之前打印
多次的情况。

图 4.2 看起来像是两个任务同时执行；然而两个任务都在同一处理器核心上执行，
因此不可能真正并行。实际上，两者都在快速进入并退出 *Running* 状态。两个任务
在相同优先级运行，因此共享该核心的时间。图 4.3 展示了真实的执行模式。

图 4.3 底部的箭头表示时间从 t1 开始推进。彩色线段表示每个时间点正在执行的
任务——例如，Task 1 在 t1 与 t2 之间执行。

任一时刻只能有一个任务处于 *Running* 状态。因此，当一个任务进入 *Running*
状态（被切入），另一个任务进入 *Not Running* 状态（被切出）。


<a name="fig4.3" title="图 4.3 示例 4.1 中两个任务的实际执行模式"></a>

***
![](media/figure_4.3_example_4.1_execution_pattern.png)
***图 4.3*** *示例 4.1 中两个任务的实际执行模式*
***

示例 4.1 在启动调度器之前在 `main()` 中创建了两个任务。也可以在任务内部
创建另一个任务。例如，可在 Task 1 内创建 Task 2，如清单 4.7 所示。


<a name="list4.7" title="清单 4.7 在调度器启动后由一个任务创建另一个任务"></a>


```c
void vTask1( void * pvParameters )
{
		const char *pcTaskName = "Task 1 is running\r\n";
		volatile unsigned long ul; /* 声明为 volatile，确保 ul 不被优化掉。 */

		/*
		 * 如果该任务代码正在执行，则调度器必然已经启动。
		 * 在进入无限循环前创建另一个任务。
		 */
		xTaskCreate( vTask2, "Task 2", 1000, NULL, 1, NULL );

		for( ;; )
		{
				/* 打印该任务的名称。 */
				vPrintLine( pcTaskName );

				/* 延时一段时间。 */
				for( ul = 0; ul < mainDELAY_LOOP_COUNT; ul++ )
				{
						/*
						 * 该循环只是一个非常粗糙的延时实现。
						 * 这里没有任何事情要做。后续示例会用
						 * 合适的延时/休眠函数替代该粗糙循环。
						 */
				}
		}
}
```

***清单 4.7*** *在调度器启动后由一个任务创建另一个任务*

<a name="example4.2" title="示例 4.2 使用任务参数"></a>
---
***示例 4.2*** *使用任务参数*

---

示例 4.1 中创建的两个任务几乎完全相同，唯一差别是打印的字符串。如果使用一个
任务实现函数创建两个实例，并使用任务参数把字符串传入各实例，就能消除代码
重复。

示例 4.2 用一个名为 `vTaskFunction()` 的任务函数替代示例 4.1 中的两个任务函数，
如清单 4.8 所示。注意任务参数被强制转换为 `char *` 以获得任务要打印的字符串。


<a name="list4.8" title="清单 4.8 示例 4.2 中用于创建两个任务的单一任务函数"></a>

```c
void vTaskFunction( void * pvParameters )
{

		char *pcTaskName;
		volatile unsigned long ul; /* 声明为 volatile，确保 ul 不被优化掉。 */

		/*
		 * 要打印的字符串通过参数传入，将其强制转换为字符指针。
		 */
		pcTaskName = ( char * ) pvParameters;

		/* 按多数任务的惯例，该任务以无限循环实现。 */
		for( ;; )
		{
				/* 打印该任务的名称。 */
				vPrintLine( pcTaskName );

				/* 延时一段时间。 */
				for( ul = 0; ul < mainDELAY_LOOP_COUNT; ul++ )
				{
						/*
						 * 该循环只是一个非常粗糙的延时实现。
						 * 这里没有任何事情要做。后续示例会用
						 * 合适的延时/休眠函数替代该粗糙循环。
						 */
				}
		}
}
```

***清单 4.8*** *示例 4.2 中用于创建两个任务的单一任务函数*

清单 4.9 创建了 `vTaskFunction()` 的两个实例，通过任务参数为每个实例传入不同
字符串。两个任务在 FreeRTOS 调度器控制下独立运行，且各自拥有自己的栈，因此
也拥有 `pcTaskName` 与 `ul` 变量的独立副本。


<a name="list4.9" title="清单 4.9 示例 2 的 main() 函数"></a>


```c
/*
 * 定义将作为任务参数传入的字符串。
 * 这些字符串声明为 const，并且不放在 main() 使用的栈上，
 * 以确保在任务执行期间始终有效。
 */
static const char * pcTextForTask1 = "Task 1 is running";
static const char * pcTextForTask2 = "Task 2 is running";

int main( void )
{
		/*
		 * 启动 FreeRTOS 调度器后，此处声明的变量可能不再存在。
		 * 不要在任务中访问 main() 所用栈上声明的变量。
		 */

		/* 创建两个任务中的一个。 */
		xTaskCreate( vTaskFunction,             /* 指向实现该任务的函数指针。 */
							 "Task 1",                  /* 任务的文本名称，仅用于调试。 */
							 1000,                      /* 栈深度——小型 MCU 使用的栈会远小于此值。*/
							 ( void * ) pcTextForTask1, /* 通过任务参数传入要打印的文本。 */
							 1,                         /* 该任务以优先级 1 运行。 */
							 NULL );                    /* 本示例不使用任务句柄。 */

		/*
		 * 以完全相同的方式创建另一个任务。注意这次是从同一个
		 * 任务实现（vTaskFunction）创建多个任务实例。只有传入参数
		 * 的值不同，即创建了同一任务定义的两个实例。
		 */
		xTaskCreate( vTaskFunction,
								 "Task 2",
								 1000,
								 ( void * ) pcTextForTask2,
								 1,
								 NULL );

		/* 启动调度器，使任务开始执行。 */
		vTaskStartScheduler();

		/*
		 * 一切正常时 main() 不会到达这里，因为调度器已在运行已创建的任务。
		 * 如果 main() 到达这里，说明堆内存不足，无法创建空闲任务或定时器任务
		 *（本书后续章节描述）。第 3 章提供更多堆内存管理信息。
		 */
		for( ;; )
		{
		}
}
```

***清单 4.9*** *示例 2 的 main() 函数*


示例 4.2 的输出与图 4.2 所示的示例 1 输出完全相同。

## 4.5 任务优先级

FreeRTOS 调度器始终确保能运行的最高优先级任务被选中进入 *Running* 状态。
同一优先级的任务会轮流进入与退出 *Running* 状态。

用于创建任务的 API 的 `uxPriority` 参数指定任务的初始优先级。
`vTaskPrioritySet()` API 函数可在任务创建后修改其优先级。

应用定义的 `configMAX_PRIORITIES` 编译期配置常量决定可用优先级数量。数值较小
表示较低优先级，优先级 0 为最低优先级——因此有效优先级范围为 0 到
`(configMAX_PRIORITIES – 1)`。任意数量的任务都可以共享同一优先级。

FreeRTOS 调度器用于选择 *Running* 状态任务的算法有两种实现，`configMAX_PRIORITIES`
的最大可取值取决于所使用的实现：

### 4.5.1 通用调度器

通用调度器用 C 编写，可用于所有 FreeRTOS 架构移植。它不对
`configMAX_PRIORITIES` 施加上限。一般建议尽量减小 `configMAX_PRIORITIES`，
因为更大的值需要更多 RAM，并会增加最坏情况执行时间。

### 4.5.2 架构优化调度器

架构优化实现用特定架构的汇编编写，性能优于通用 C 实现，且对所有
`configMAX_PRIORITIES` 值具有相同的最坏情况执行时间。

架构优化实现对 `configMAX_PRIORITIES` 有最大限制：在 32 位架构上为 32，
在 64 位架构上为 64。与通用方法相同，建议将 `configMAX_PRIORITIES` 设为尽可能
低的实际值，因为更高的值需要更多 RAM。

在 FreeRTOSConfig.h 中将 `configUSE_PORT_optimized_TASK_SELECTION` 设为 1 以使用
架构优化实现，设为 0 则使用通用实现。并非所有 FreeRTOS port 都提供架构优化实现。
提供该实现的 port 会在该宏未定义时默认设为 1；未提供该实现的 port 会在未定义时
默认设为 0。

## 4.6 时间测量与滴答中断

[第 4.12 节：调度算法](#412-调度算法) 描述了一项可选特性——
“时间片”。此前示例都使用了时间片，且其输出符合该行为。在示例中，两个任务在
同一优先级创建且始终可运行。因此每个任务会执行一个“时间片”，即在时间片开始时
进入 *Running* 状态，在时间片结束时退出 *Running* 状态。在图 4.3 中，t1 与 t2
之间的时间等于一个时间片。

调度器会在每个时间片结束时运行，以选择下一个任务[^5]。为此使用周期性中断，
称为 “tick 中断”。编译期配置常量 `configTICK_RATE_HZ` 设定 tick 中断频率，
从而决定每个时间片长度。例如，将 `configTICK_RATE_HZ` 设为 100（Hz），时间片
长度为 10 毫秒。两次 tick 中断之间的时间称为 “tick 周期”——因此一个时间片
等于一个 tick 周期。

[^5]: 需要注意，时间片结束并不是调度器选择新任务的唯一时刻。正如本书
所示，当当前运行的任务进入 *Blocked* 状态，或当中断把更高优先级任务
移入 *Ready* 状态时，调度器也会立即选择新的任务运行。

图 4.4 在图 4.3 的基础上扩展，显示调度器的执行。在图 4.4 中，上方的线表示调度器
执行的时刻，细箭头表示执行序列：从任务到 tick 中断，再从 tick 中断切换到不同任务。

`configTICK_RATE_HZ` 的最佳值取决于应用，典型值为 100。


<a name="fig4.4" title="图 4.4 展示 tick 中断执行的扩展执行序列"></a>

***
![](media/figure_4.4_expanded_execution_sequence_with_tick_interrupt.png)
***图 4.4*** *展示 tick 中断执行的扩展执行序列*
***

FreeRTOS API 调用以 tick 周期的倍数指定时间，通常称为 “ticks”。
`pdMS_TO_TICKS()` 宏把以毫秒指定的时间转换为以 tick 指定的时间。可用分辨率
取决于 tick 频率，且当 tick 频率高于 1KHz（`configTICK_RATE_HZ` 大于 1000）时，
不能使用 `pdMS_TO_TICKS()`。清单 4.10 展示如何将 200 毫秒转换为等效的 tick 数。


<a name="list4.10" title="清单 4.10 使用 pdMS\_TO\_TICKS() 将 200 毫秒转换为 tick"></a>

```c
/*
 * pdMS_TO_TICKS() 仅接受一个以毫秒表示的时间参数，
 * 并计算得到等效的 tick 周期数。本示例演示将
 * xTimeInTicks 设置为等价于 200 毫秒的 tick 数。
 */
TickType_t xTimeInTicks = pdMS_TO_TICKS( 200 );
```

***清单 4.10*** *使用 pdMS\_TO\_TICKS() 将 200 毫秒转换为等效 tick*

使用 `pdMS_TO_TICKS()` 以毫秒指定时间，而不是直接用 tick，可确保当 tick 频率
改变时应用中的时间参数保持一致。

“tick 计数”是自调度器启动以来发生的 tick 中断总数（假定未溢出）。用户应用
在指定延迟时无需考虑溢出，因为 FreeRTOS 会在内部保证时间一致性。

[第 4.12 节：调度算法](#412-调度算法) 介绍了影响调度器何时选择新任务
以及 tick 中断何时执行的配置常量。

<a name="example4.3" title="示例 4.3 体验优先级"></a>
---
***示例 4.3*** *体验优先级*

---

调度器始终保证能运行的最高优先级任务被选中进入 *Running* 状态。此前示例创建了
两个相同优先级的任务，因此它们轮流进入与退出 *Running* 状态。本示例观察当任务
具有不同优先级时会发生什么。清单 4.11 显示创建两个任务的代码：第一个优先级为 1，
第二个为 2。两任务共享同一个实现函数，该函数未变化，仍会周期性打印字符串，
并用空循环产生延迟。


<a name="list4.11" title="清单 4.11 创建两个不同优先级任务"></a>


```c
/*
 * 定义将作为任务参数传入的字符串。
 * 这些字符串声明为 const，并且不放在栈上，以确保在任务执行期间有效。
 */
static const char * pcTextForTask1 = "Task 1 is running";
static const char * pcTextForTask2 = "Task 2 is running";

int main( void )
{
		/* 创建第一个任务，优先级为 1。 */
		xTaskCreate( vTaskFunction,             /* 任务函数 */
							 "Task 1",                  /* 任务名称 */
							 1000,                      /* 任务栈深度 */
							 ( void * ) pcTextForTask1, /* 任务参数 */
							 1,                         /* 任务优先级 */
							 NULL );

		/* 创建第二个任务，优先级更高，为 2。 */
		xTaskCreate( vTaskFunction,             /* 任务函数 */
							 "Task 2",                  /* 任务名称 */
							 1000,                      /* 任务栈深度 */
							 ( void * ) pcTextForTask2, /* 任务参数 */
							 2,                         /* 任务优先级 */
							 NULL );

		/* 启动调度器，使任务开始执行。 */
		vTaskStartScheduler();

		/* 不会到达这里。 */
		return 0;
}
```

***清单 4.11*** *创建两个不同优先级任务*

图 4.5 显示了示例 4.3 的输出。

调度器总是选择能运行的最高优先级任务。Task 2 的优先级高于 Task 1 且始终可运行，
因此调度器总是选择 Task 2，而 Task 1 永远不执行。Task 1 被称为被 Task 2 “饿死”
了处理时间——它无法打印字符串，因为它从未进入 *Running* 状态。


<a name="fig4.5" title="图 4.5 以不同优先级运行两个任务"></a>

***
```console
C:\Temp>rtosdemo
Task 2 is running
Task 2 is running
Task 2 is running
Task 2 is running
Task 2 is running
Task 2 is running
Task 2 is running
Task 2 is running
Task 2 is running
Task 2 is running
Task 2 is running
Task 2 is running
Task 2 is running
Task 2 is running
Task 2 is running
```

***图 4.5*** *以不同优先级运行两个任务*
***

Task 2 总能运行，因为它从不需要等待任何东西——要么在空循环中自旋，要么输出到终端。


<a name="fig4.6" title="图 4.6 当一个任务优先级高于另一个任务时的执行模式"></a>

***
![](media/figure_4.6_execution_pattern_higher_priority_task.png)
***图 4.6*** *示例 4.3 中一个任务优先级更高时的执行模式*

## 4.7 扩展 *Not Running* 状态

到目前为止，已创建的任务总是有处理可做且无需等待任何事件——因此始终能够进入
*Running* 状态。这类“持续处理”任务实用性有限，因为它们只能以最低优先级创建。
若在更高优先级运行，它们将阻止更低优先级任务运行。

为了使这些任务有用，必须将其改写为事件驱动。事件驱动任务只有在事件触发后才
有工作需要处理，在此之前不能进入 *Running* 状态。调度器总是选择能运行的最高
优先级任务。如果高优先级任务正在等待事件而无法运行，调度器必须选择能运行的
低优先级任务。因此，编写事件驱动任务可以让任务以不同优先级创建，而不会出现
最高优先级任务饿死低优先级任务的情况。

### 4.7.1 *Blocked* 状态

等待事件的任务处于 *Blocked* 状态，这是 *Not Running* 的子状态。

任务可以进入 *Blocked* 状态等待两类事件：

1. 时间（时间相关）事件——当延迟到期或达到某个绝对时间时发生。例如，任务可
	 进入 *Blocked* 状态等待 10 毫秒过去。

1. 同步事件——由其他任务或中断发起。例如，任务可进入 *Blocked* 状态等待
	 队列中到达数据。同步事件覆盖了广泛的事件类型。

FreeRTOS 队列、二值信号量、计数信号量、互斥量、递归互斥量、事件组、流缓冲区、
消息缓冲区以及直接任务通知都可以产生同步事件。本书后续章节将介绍其中的大部分。

任务可以带超时地阻塞在同步事件上，从而相当于同时等待两类事件。例如，任务可以
最多等待 10 毫秒以接收队列数据。若 10 毫秒内有数据到达，任务会离开 *Blocked*
状态；若 10 毫秒内无数据到达，也会离开 *Blocked* 状态。

### 4.7.2 *Suspended* 状态

*Suspended* 也是 *Not Running* 的子状态。处于 *Suspended* 状态的任务不被调度器
考虑。进入 *Suspended* 状态的唯一方式是调用 `vTaskSuspend()` API 函数，离开该
状态的唯一方式是调用 `vTaskResume()` 或 `xTaskResumeFromISR()` API 函数。大多数
应用不会使用 *Suspended* 状态。

### 4.7.3 Ready 状态

处于 *Not Running* 状态且既非 *Blocked* 也非 *Suspended* 的任务称为处于 *Ready*
状态。它们可以运行，因此“就绪”运行，但当前并未处于 *Running* 状态。

### 4.7.4 完整的状态转换图

图 4.7 在简化状态图基础上扩展，包含了本节描述的所有 *Not Running* 子状态。
目前示例中的任务尚未使用 *Blocked* 或 *Suspended* 状态，它们只在 *Ready* 与
*Running* 状态之间转换，如图 4.7 中粗线所示。


<a name="fig4.7" title="图 4.7 完整任务状态机"></a>

***
![](media/figure_4.7_full_task_state_machine.png)
***图 4.7*** *完整任务状态机*
***

<a name="example4.4" title="示例 4.4 使用 Blocked 状态创建延迟"></a>
---
***示例 4.4*** *使用 *Blocked* 状态创建延迟</i></h3>

---

到目前为止示例中的任务都是“周期性”任务——它们先延迟一段时间再打印字符串，
然后再次延迟，如此循环。延迟通过空循环粗糙地产生——任务轮询递增的循环计数器
直到达到固定值。示例 4.3 清楚展示了该方法的缺点：高优先级任务在执行空循环时
仍处于 *Running* 状态，从而“饿死”低优先级任务。

任何形式的轮询都有其他缺点，其中最重要的是效率低。在轮询期间，任务实际上
没有工作可做，却仍占用最大处理时间，浪费处理器周期。示例 4.4 通过将轮询空
循环替换为 `vTaskDelay()` API 函数调用来纠正这一行为，其原型见清单 4.12。
新的任务定义见清单 4.13。注意 `vTaskDelay()` 仅在 FreeRTOSConfig.h 中
`INCLUDE_vTaskDelay` 设为 1 时可用。

`vTaskDelay()` 将调用任务置于 *Blocked* 状态固定数量的 tick 中断。任务在
*Blocked* 状态时不占用处理时间，因此只有真正有工作可做时才使用处理时间。


<a name="list4.12" title="清单 4.12 vTaskDelay() API 函数原型"></a>


```c
void vTaskDelay( TickType_t xTicksToDelay );
```

***清单 4.12*** *vTaskDelay() API 函数原型*

**vTaskDelay 参数：**

- `xTicksToDelay`

	调用任务将保持在 *Blocked* 状态的 tick 中断数量，之后会被转回 *Ready* 状态。

	例如，若任务在 tick 计数为 10,000 时调用 `vTaskDelay( 100 )`，则它会立刻进入
	*Blocked* 状态，并保持该状态直到 tick 计数达到 10,100。

	`pdMS_TO_TICKS()` 宏可将毫秒转换为 tick。例如调用
	`vTaskDelay( pdMS_TO_TICKS( 100 ) )` 会使任务在 *Blocked* 状态保持 100 毫秒。


<a name="list4.13" title="清单 4.13 用 vTaskDelay() 替换空循环后的任务源码"></a>


```c
void vTaskFunction( void * pvParameters )
{
		char * pcTaskName;
		const TickType_t xDelay250ms = pdMS_TO_TICKS( 250 );

		/*
		 * 要打印的字符串通过参数传入，将其强制转换为字符指针。
		 */
		pcTaskName = ( char * ) pvParameters;

		/* 按多数任务的惯例，该任务以无限循环实现。 */
		for( ;; )
		{
				/* 打印该任务的名称。 */
				vPrintLine( pcTaskName );

				/*
				 * 延时一段时间。本次使用 vTaskDelay()，它会让任务进入
				 * Blocked 状态直到延时到期。参数以 tick 为单位，
				 * 并使用 pdMS_TO_TICKS() 宏（xDelay250ms 常量的定义处）
				 * 将 250 毫秒转换为等效的 tick 数。
				 */
				vTaskDelay( xDelay250ms );
		}
}
```

***清单 4.13*** *用 vTaskDelay() 替换空循环后的任务源码*

即使两个任务仍以不同优先级创建，它们现在都将运行。示例 4.4 的输出如图 4.8 所示，
符合预期行为。


<a name="fig4.8" title="图 4.8 执行示例 4.4 的输出"></a>

***

```console
C:\Temp>rtosdemo
Task 2 is running
Task 1 is running
Task 2 is running
Task 1 is running
Task 2 is running
Task 1 is running
Task 2 is running
Task 1 is running
Task 2 is running
Task 1 is running
Task 2 is running
Task 1 is running
Task 2 is running
Task 1 is running
Task 2 is running
Task 1 is running
```

***图 4.8*** *执行示例 4.4 的输出*
***

图 4.9 所示的执行序列解释了为何两个任务都能运行，即使它们以不同优先级创建。
为简化起见，图中省略了调度器自身的执行。

当调度器启动时会自动创建空闲任务，以确保始终至少有一个任务可以运行（至少有
一个任务处于 *Ready* 状态）。[第 4.8 节：空闲任务与空闲任务钩子](#48-空闲任务与空闲任务钩子)
将更详细介绍空闲任务。


<a name="fig4.9" title="图 4.9 当任务用 vTaskDelay() 替代空循环的执行序列"></a>

***
![](media/figure_4.9_vTaskDelay_execution_sequence.png)
***图 4.9*** *当任务用 vTaskDelay() 替代空循环的执行序列*
***

只有两个任务的实现发生了变化，其功能并未改变。将图 4.9 与图 4.4 对比可以清楚
看出，这种实现方式效率更高。

图 4.4 显示任务使用空循环产生延迟时的执行模式，因为它们始终可运行，因而占用
了全部可用处理器时间。图 4.9 显示任务在整个延迟期间进入 *Blocked* 状态的执行
模式。它们只在真正有工作要做时使用处理器时间（此处只是打印一条消息），因此
仅占用可用处理器时间的一小部分。

在图 4.9 的场景中，每次任务离开 *Blocked* 状态后只执行很短一段时间就再次进入
*Blocked* 状态。大部分时间里没有任何应用任务可运行（没有任务处于 *Ready* 状态），
因此没有应用任务可以被选为进入 *Running* 状态。在这种情况下，空闲任务会运行。
空闲任务获得的处理时间可衡量系统的空闲处理能力。使用 RTOS 可显著提高空闲处理
能力，因为它允许应用完全事件驱动。

图 4.10 中的粗线展示了示例 4.4 中任务的状态转换，此时每个任务在回到 *Ready* 状态
之前都会经过 *Blocked* 状态。


<a name="fig4.10" title="图 4.10 粗线表示示例 4.4 中任务执行的状态转换"></a>

***
![](media/figure_4.10_example_4.4_state_machine.png)
***图 4.10*** *粗线表示示例 4.4 中任务执行的状态转换*
***


### 4.7.5 vTaskDelayUntil() API 函数

`vTaskDelayUntil()` 与 `vTaskDelay()` 类似。正如上文所示，`vTaskDelay()` 的参数
指定调用 `vTaskDelay()` 到同一任务再次从 *Blocked* 状态转出之间经历的 tick 中断
数量。任务在 *Blocked* 状态中停留的时间由 `vTaskDelay()` 参数决定，而任务离开
*Blocked* 状态的时间是相对于调用 `vTaskDelay()` 的时刻而言的。

`vTaskDelayUntil()` 的参数则指定调用任务应在某个 **绝对** tick 计数值时从
*Blocked* 状态转为 *Ready* 状态。若需要固定执行周期（希望任务以固定频率周期性
执行），应使用 `vTaskDelayUntil()`，因为其解阻塞时间是绝对时间，而非相对于
函数调用时刻（如 `vTaskDelay()`）。


<a name="list4.14" title="清单 4.14 vTaskDelayUntil() API 函数原型"></a>

```c
void vTaskDelayUntil( TickType_t * pxPreviousWakeTime,
											TickType_t xTimeIncrement );
```

***清单 4.14*** *vTaskDelayUntil() API 函数原型*

**vTaskDelayUntil() 参数**

- `pxPreviousWakeTime`

	该参数假定 `vTaskDelayUntil()` 用于实现固定频率的周期性任务。
	在此情况下，`pxPreviousWakeTime` 保存任务上一次离开 *Blocked* 状态（被“唤醒”）
	的时间，用于计算任务下一次离开 *Blocked* 状态的时刻。

	`pxPreviousWakeTime` 指向的变量会在 `vTaskDelayUntil()` 内自动更新；
	应用通常不应修改它，但在首次使用前必须将其初始化为当前 tick 计数。
	清单 4.15 演示了如何初始化该变量。

- `xTimeIncrement`

	该参数同样假定 `vTaskDelayUntil()` 用于固定频率的周期性任务，频率由
	`xTimeIncrement` 指定。

	`xTimeIncrement` 以 tick 为单位。`pdMS_TO_TICKS()` 宏可将毫秒转换为 tick。

<a name="example4.5" title="示例 4.5 将示例任务改为使用 vTaskDelayUntil()"></a>
---
***示例 4.5*** *将示例任务改为使用 vTaskDelayUntil()*

---

示例 4.4 中的两个任务都是周期性任务，但使用 `vTaskDelay()` 无法保证执行频率
固定，因为任务离开 *Blocked* 状态的时间是相对于调用 `vTaskDelay()` 的时刻。
将任务改为使用 `vTaskDelayUntil()` 可解决该潜在问题。


<a name="list4.15" title="清单 4.15 使用 vTaskDelayUntil() 的示例任务实现"></a>


```c
void vTaskFunction( void * pvParameters )
{
		char * pcTaskName;
		TickType_t xLastWakeTime;

		/*
		 * 要打印的字符串通过参数传入，将其强制转换为字符指针。
		 */
		pcTaskName = ( char * ) pvParameters;

		/*
		 * xLastWakeTime 变量需要用当前 tick 计数进行初始化。
		 * 注意这是该变量唯一一次被显式写入。之后 xLastWakeTime
		 * 会在 vTaskDelayUntil() 内自动更新。
		 */
		xLastWakeTime = xTaskGetTickCount();

		/* 按多数任务的惯例，该任务以无限循环实现。 */
		for( ;; )
		{
				/* 打印该任务的名称。 */
				vPrintLine( pcTaskName );

				/*
				 * 该任务应精确每 250 毫秒执行一次。与 vTaskDelay()
				 * 一样，时间以 tick 计量，并使用 pdMS_TO_TICKS() 宏
				 * 将毫秒转换为 tick。xLastWakeTime 会在 vTaskDelayUntil()
				 * 内自动更新，因此任务无需显式更新。
				 */
				vTaskDelayUntil( &xLastWakeTime, pdMS_TO_TICKS( 250 ) );
		}
}
```

***清单 4.15*** *使用 vTaskDelayUntil() 的示例任务实现*

示例 4.5 的输出与图 4.8 所示的示例 4.4 输出完全相同。

<a name="example4.6" title="示例 4.6 结合阻塞与非阻塞任务"></a>
---
***示例 4.6*** *结合阻塞与非阻塞任务*

---

前面的示例分别观察了轮询任务与阻塞任务的行为。本示例重申我们已经说明的预期系统
行为，并展示当两种方案结合使用时的执行序列：

1. 创建两个优先级为 1 的任务。这两个任务仅不断打印字符串。

	 这类任务不会调用可能使其进入 *Blocked* 状态的 API，因此始终处于 *Ready* 或
	 *Running* 状态。这类任务被称为“持续处理”任务，因为它们总有工作要做（此处虽
	 只是很简单的工作）。清单 4.16 给出持续处理任务的源码。

1. 再创建一个优先级为 2 的任务，高于前两个任务。该任务也打印字符串，但以周期
	 方式打印，因此使用 `vTaskDelayUntil()` 在每次打印间进入 *Blocked* 状态。

清单 4.17 给出周期性任务源码。


<a name="list4.16" title="清单 4.16 示例 4.6 中的持续处理任务"></a>


```c
void vContinuousProcessingTask( void * pvParameters )
{
		char * pcTaskName;

		/*
		 * 要打印的字符串通过参数传入，将其强制转换为字符指针。
		 */
		pcTaskName = ( char * ) pvParameters;

		/* 按多数任务的惯例，该任务以无限循环实现。 */
		for( ;; )
		{
				/*
				 * 打印该任务的名称。该任务仅反复执行此操作，
				 * 从不阻塞或延时。
				 */
				vPrintLine( pcTaskName );
		}
}
```

***清单 4.16*** *示例 4.6 中的持续处理任务*


<a name="list4.17" title="清单 4.17 示例 4.6 中的周期性任务"></a>


```c
void vPeriodicTask( void * pvParameters )
{
		TickType_t xLastWakeTime;

		const TickType_t xDelay3ms = pdMS_TO_TICKS( 3 );

		/*
		 * xLastWakeTime 变量需要用当前 tick 计数初始化。
		 * 注意这是该变量唯一一次被显式写入。之后 xLastWakeTime
		 * 由 vTaskDelayUntil() API 函数自动管理。
		 */
		xLastWakeTime = xTaskGetTickCount();

		/* 按多数任务的惯例，该任务以无限循环实现。 */
		for( ;; )
		{
				/* 打印该任务的名称。 */
				vPrintLine( "Periodic task is running" );

				/*
				 * 该任务应精确每 3 毫秒执行一次——见本函数中 xDelay3ms 的定义。
				 */
				vTaskDelayUntil( &xLastWakeTime, xDelay3ms );
		}
}
```

***清单 4.17*** *示例 4.6 中的周期性任务*

图 4.11 显示了示例 4.6 的输出，图 4.12 的执行序列解释了观察到的行为。

<a name="fig4.11" title="图 4.11 执行示例 4.6 的输出"></a>

***

```console
Continuous task 2 running
Continuous task 2 running
Periodic task is running
Continuous task 1 running
Continuous task 1 running
Continuous task 1 running
Continuous task 1 running
Continuous task 1 running
Continuous task 2 running
Continuous task 2 running
Continuous task 2 running
Continuous task 2 running
Continuous task 2 running
Continuous task 1 running
Continuous task 1 running
Continuous task 1 running
Continuous task 1 running
Continuous task 1 running
Continuous task 1 running
Continuous task 1 running
Continuous task 1 running
Continuous task 1 running
Periodic task is running
Continuous task 2 running
Continuous task 2 running
```

***图 4.11*** *执行示例 4.6 的输出*
***


<a name="fig4.12" title="图 4.12 示例 4.6 的执行模式"></a>

***
![](media/figure_4.11_example_4.6_execution_pattern.png)
***图 4.12*** *示例 4.6 的执行模式*
***

## 4.8 空闲任务与空闲任务钩子

示例 4.4 中创建的任务大部分时间处于 *Blocked* 状态。在此状态下任务无法运行，
因此不能被调度器选中。

必须始终至少有一个任务能够进入 *Running* 状态[^6]。为此，调度器在调用
`vTaskStartScheduler()` 时会自动创建空闲任务。空闲任务几乎只是在循环中空转，
因此与前面示例中的任务一样，它始终可运行。

[^6]: 即便启用了 FreeRTOS 的特殊低功耗特性，这一点也成立；在此情况下，若应用
创建的任务都无法执行，运行 FreeRTOS 的微控制器会进入低功耗模式。

空闲任务具有最低可能优先级（优先级 0），以确保它不会阻止更高优先级的应用任务
进入 *Running* 状态。不过，也没有任何东西阻止应用设计者创建与空闲任务同优先级
（即优先级 0）的任务。FreeRTOSConfig.h 中的 `configIDLE_SHOULD_YIELD` 编译期
配置常量可用于防止空闲任务消耗本应更有效分配给同为优先级 0 的应用任务的处理时间。
第 4.12 节《调度算法》描述了 `configIDLE_SHOULD_YIELD`。

以最低优先级运行可确保空闲任务在更高优先级任务进入 *Ready* 状态时立刻被切出。
这可在图 4.9 的时间 **tn** 看到：当 Task 2 离开 *Blocked* 状态的瞬间，空闲任务被
立即切出以让 Task 2 运行。Task 2 被称为抢占了空闲任务。抢占会自动发生，且被抢占的
任务并不知情。

> *注意：如果任务使用 `vTaskDelete()` API 函数删除自身，必须确保空闲任务不会
> 被完全饿死，因为空闲任务负责清理由任务自删所占用的内核资源。*

### 4.8.1 空闲任务钩子函数

可以通过空闲钩子（或空闲回调）函数将应用特定功能直接添加到空闲任务中。
空闲钩子函数由空闲任务在其循环的每次迭代中自动调用。

空闲任务钩子的常见用途包括：

- 在无需创建额外应用任务（避免其 RAM 开销）的情况下执行低优先级、后台或
	持续处理功能。

- 测量空闲处理能力。（空闲任务仅在所有更高优先级的应用任务都无工作可做时才运行；
	因此测量空闲任务所占用的处理时间能清晰反映系统的空闲处理时间。）

- 将处理器置于低功耗模式，为在无应用处理时自动节能提供简便方法（尽管节能程度
	不如无节拍空闲模式）。

### 4.8.2 空闲任务钩子函数实现的限制

空闲任务钩子函数必须遵守以下规则：

- 空闲任务钩子函数绝不能试图阻塞或挂起自身。

	*注意：以任何方式阻塞空闲任务都可能导致没有任务能够进入 *Running* 状态。*

- 如果应用任务使用 `vTaskDelete()` 删除自身，则空闲任务钩子必须在合理时间内
	返回给其调用者。这是因为空闲任务负责清理已自删任务使用的内核资源。如果空闲任务
	永久停留在钩子函数中，这一清理就无法进行。

空闲任务钩子函数必须具有清单 4.18 所示的名称与原型。


<a name="list4.18" title="清单 4.18 空闲任务钩子函数名称与原型"></a>

```c
void vApplicationIdleHook( void );
```

***清单 4.18*** *空闲任务钩子函数名称与原型*

<a name="example4.7" title="示例 4.7 定义空闲任务钩子函数"></a>
---
***示例 4.7*** *定义空闲任务钩子函数</i></h3>

---

示例 4.4 中使用阻塞的 `vTaskDelay()` 调用产生了大量空闲时间，即应用任务处于
*Blocked* 状态时空闲任务执行的时间。示例 4.7 通过添加空闲钩子函数来利用这些
空闲时间，其源码见清单 4.19。


<a name="list4.19" title="清单 4.19 一个非常简单的空闲钩子函数"></a>

```c
/* 声明一个将由钩子函数递增的变量。 */
volatile unsigned long ulIdleCycleCount = 0UL;

/*
 * 空闲任务钩子函数必须命名为 vApplicationIdleHook()，
 * 不接受参数，返回 void。
 */
void vApplicationIdleHook( void )
{
		/* 该钩子函数只做一件事：递增计数器。 */
		ulIdleCycleCount++;
}
```

***清单 4.19*** *一个非常简单的空闲钩子函数*


必须在 FreeRTOSConfig.h 中将 `configUSE_IDLE_HOOK` 设为 1，空闲钩子函数才会被调用。

示例中的任务实现稍作修改，以打印 `ulIdleCycleCount` 的值，如清单 4.20 所示。


<a name="list4.20" title="清单 4.20 示例任务现在输出 ulIdleCycleCount 的值"></a>


```c
void vTaskFunction( void * pvParameters )
{
		char * pcTaskName;
		const TickType_t xDelay250ms = pdMS_TO_TICKS( 250 );

		/*
		 * 要打印的字符串通过参数传入，将其强制转换为字符指针。
		 */
		pcTaskName = ( char * ) pvParameters;

		/* 按多数任务的惯例，该任务以无限循环实现。 */
		for( ;; )
		{
				/*
				 * 打印该任务的名称以及 ulIdleCycleCount 的递增次数。
				 */
				vPrintLineAndNumber( pcTaskName, ulIdleCycleCount );

				/* 延时 250 毫秒。 */
				vTaskDelay( xDelay250ms );
		}
}
```

***清单 4.20*** *示例任务现在输出 ulIdleCycleCount 的值*

图 4.13 显示示例 4.7 的输出。可以看到空闲任务钩子函数在两次应用任务迭代之间
执行约 400 万次（具体次数取决于硬件速度）。


<a name="fig4.13" title="图 4.13 执行示例 4.7 的输出"></a>

***

```console
C:\Temp>rtosdemo
Task 2 is running
ulIdleCycleCount = 0
Task 1 is running
ulIdleCycleCount = 0
Task 2 is running
ulIdleCycleCount = 3869504
Task 1 is running
ulIdleCycleCount = 3869504
Task 2 is running
ulIdleCycleCount = 8564623
Task 1 is running
ulIdleCycleCount = 8564623
Task 2 is running
ulIdleCycleCount = 13181489
Task 1 is running
ulIdleCycleCount = 13181489
Task 2 is running
ulIdleCycleCount = 17838406
Task 1 is running
ulIdleCycleCount = 17838406
Task 2 is running
```

***图 4.13*** *执行示例 4.7 的输出*
***


## 4.9 更改任务优先级

### 4.9.1 vTaskPrioritySet() API 函数

`vTaskPrioritySet()` API 函数在调度器启动后修改任务优先级。该函数仅在
FreeRTOSConfig.h 中 `INCLUDE_vTaskPrioritySet` 设为 1 时可用。


<a name="list4.21" title="清单 4.21 vTaskPrioritySet() API 函数原型"></a>

```c
void vTaskPrioritySet( TaskHandle_t xTask,
											 UBaseType_t uxNewPriority );
```

***清单 4.21*** *vTaskPrioritySet() API 函数原型*

**vTaskPrioritySet() 参数**

- `pxTask`

	被修改优先级的任务句柄（目标任务）。获取任务句柄的方法见 `xTaskCreate()` 的
	`pxCreatedTask` 参数或 `xTaskCreateStatic()` 的返回值。

	任务可通过传入 NULL 来修改自身优先级。

- `uxNewPriority`

	目标任务的新优先级。该值会自动限制为最大可用优先级
	`(configMAX_PRIORITIES – 1)`，其中 `configMAX_PRIORITIES` 为 FreeRTOSConfig.h
	中的编译期常量。


### 4.9.2 uxTaskPriorityGet() API 函数

`uxTaskPriorityGet()` API 函数返回任务的优先级。该函数仅在
FreeRTOSConfig.h 中 `INCLUDE_uxTaskPriorityGet` 设为 1 时可用。


<a name="list4.22" title="清单 4.22 uxTaskPriorityGet() API 函数原型"></a>

```c
UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask );
```

***清单 4.22*** *uxTaskPriorityGet() API 函数原型*

**uxTaskPriorityGet() 参数与返回值**

- `pxTask`

	需要查询优先级的任务句柄（目标任务）。获取任务句柄的方法见 `xTaskCreate()`
	的 `pxCreatedTask` 参数或 `xTaskCreateStatic()` 的返回值。

	任务可通过传入 NULL 来查询自身优先级。

- 返回值

	被查询任务的当前优先级。


<a name="example4.8" title="示例 4.8 修改任务优先级"></a>
---
***示例 4.8*** *修改任务优先级*

---

调度器始终选择最高优先级的 *Ready* 状态任务进入 *Running* 状态。示例 4.8
通过 `vTaskPrioritySet()` API 函数改变两个任务的相对优先级来演示这一点。

示例 4.8 创建两个不同优先级的任务。两个任务都不会调用可能进入 *Blocked* 状态
的 API，因此它们始终处于 *Ready* 或 *Running* 状态。因此，具有更高相对优先级
的任务将总是被调度器选中进入 *Running* 状态。

示例 4.8 行为如下：

1. Task 1（清单 4.23）以最高优先级创建，保证最先运行。Task 1 打印几条消息后
	 将 Task 2（清单 4.24）的优先级提升到高于自身。

1. Task 2 一旦成为最高优先级任务就会开始运行（进入 *Running* 状态）。任一时刻
	 只能有一个任务处于 *Running* 状态，因此当 Task 2 处于 *Running* 状态时，
	 Task 1 处于 *Ready* 状态。

1. Task 2 打印消息后将自身优先级降低到低于 Task 1。

1. 当 Task 2 降低优先级后，Task 1 再次成为最高优先级任务，于是重新进入
	 *Running* 状态，将 Task 2 迫使回 *Ready* 状态。


<a name="list4.23" title="清单 4.23 示例 4.8 中 Task 1 的实现"></a>

```c
void vTask1( void * pvParameters )
{
		UBaseType_t uxPriority;

		/*
		 * 该任务以更高优先级创建，因此总会先于 Task 2 运行。
		 * Task 1 和 Task 2 都不会阻塞，因此始终处于 Running 或 Ready 状态。
		 */

		/*
		 * 查询该任务当前运行的优先级——传入 NULL 表示
		 * “返回调用任务的优先级”。
		 */
		uxPriority = uxTaskPriorityGet( NULL );

		for( ;; )
		{
				/* 打印该任务的名称。 */
				vPrintLine( "Task 1 is running" );

				/*
				 * 将 Task 2 的优先级设为高于 Task 1 会使 Task 2 立即开始运行
				 *（因为此时 Task 2 在两个已创建任务中优先级最高）。注意在
				 * vTaskPrioritySet() 调用中使用了 Task 2 的句柄（xTask2Handle）。
				 * 清单 4.25 展示了该句柄的获取方式。
				 */
				vPrintLine( "About to raise the Task 2 priority" );
				vTaskPrioritySet( xTask2Handle, ( uxPriority + 1 ) );

				/*
				 * 只有当 Task 1 的优先级高于 Task 2 时，Task 1 才能运行。
				 * 因此该任务要执行到此处，Task 2 必须已经运行并将其优先级
				 * 调回到低于本任务的水平。
				 */
		}
}
```

***清单 4.23*** *示例 4.8 中 Task 1 的实现*


<a name="list4.24" title="清单 4.24 示例 4.8 中 Task 2 的实现"></a>


```c
void vTask2( void * pvParameters )
{
		UBaseType_t uxPriority;

		/*
		 * Task 1 以更高优先级创建，因此总会先于本任务运行。
		 * Task 1 和 Task 2 都不会阻塞，因此始终处于 Running 或 Ready 状态。
		 *
		 * 查询本任务当前运行的优先级——传入 NULL 表示
		 * “返回调用任务的优先级”。
		 */
		uxPriority = uxTaskPriorityGet( NULL );

		for( ;; )
		{
				/*
				 * 本任务能到达此处，说明 Task 1 已经运行并将本任务的优先级
				 * 设为高于其自身。
				 */

				 /* 打印该任务的名称。 */
				vPrintLine( "Task 2 is running" );

				/*
				 * 将本任务优先级调回原值。
				 * 传入 NULL 作为任务句柄表示“修改调用任务的优先级”。
				 * 将优先级设为低于 Task 1 会使 Task 1 立即再次运行——抢占本任务。
				 */
				vPrintLine( "About to lower the Task 2 priority" );
				vTaskPrioritySet( NULL, ( uxPriority - 2 ) );
		}
}
```

***清单 4.24*** *示例 4.8 中 Task 2 的实现*

每个任务都可以通过传入 NULL 来查询和设置自己的优先级。当任务需要引用自身之外
的另一个任务时才需要句柄，例如 Task 1 修改 Task 2 的优先级。为此，在创建 Task 2
时获取并保存其句柄，如清单 4.25 注释中所示。


<a name="list4.25" title="清单 4.25 示例 4.8 的 main() 实现"></a>

```c
/* 声明一个用于保存 Task 2 句柄的变量。 */
TaskHandle_t xTask2Handle = NULL;

int main( void )
{
		/*
		 * 创建第一个任务，优先级为 2。任务参数不使用，设为 NULL。
		 * 任务句柄也不使用，因此同样设为 NULL。
		 */
		xTaskCreate( vTask1, "Task 1", 1000, NULL, 2, NULL );
		/* 该任务以优先级 2 创建 ______^. */

		/*
		 * 创建第二个任务，优先级为 1——低于 Task 1 的优先级。
		 * 同样不使用任务参数，因此设为 NULL；但这次需要任务句柄，
		 * 所以将 xTask2Handle 的地址作为最后一个参数传入。
		 */
		xTaskCreate( vTask2, "Task 2", 1000, NULL, 1, &xTask2Handle );
		/* 任务句柄是最后一个参数 _____^^^^^^^^^^^^^ */

		/* 启动调度器，使任务开始执行。 */
		vTaskStartScheduler();

		/*
		 * 一切正常时 main() 不会到达这里，因为调度器已在运行已创建的任务。
		 * 如果 main() 到达这里，说明堆内存不足，无法创建空闲任务或定时器任务
		 *（本书后续章节描述）。第 3 章提供更多堆内存管理信息。
		 */
		for( ;; )
		{
		}
}
```

***清单 4.25*** *示例 4.8 的 main() 实现*

图 4.14 展示示例 4.8 中任务的执行顺序，其输出见图 4.15。


<a name="fig4.14" title="图 4.14 运行示例 4.8 时的任务执行序列"></a>

***
![](media/figure_4.14_example_4.8_execution_sequence.png)
***图 4.14*** *运行示例 4.8 时的任务执行序列*
***


<a name="fig4.15" title="图 4.15 执行示例 4.8 的输出"></a>

***

```console
Task1 is running
About to raise the Task2 priority
Task2 is running
About to lower the Task2 priority
Task1 is running
About to raise the Task2 priority
Task2 is running
About to lower the Task2 priority
Task1 is running
About to raise the Task2 priority
Task2 is running
About to lower the Task2 priority
Task1 is running
```

***图 4.15*** *执行示例 4.8 的输出*
***

## 4.10 删除任务

### 4.10.1 vTaskDelete() API 函数

`vTaskDelete()` API 函数用于删除任务。该函数仅在 FreeRTOSConfig.h 中
`INCLUDE_vTaskDelete` 设为 1 时可用。

在运行时持续创建和删除任务不是良好实践，因此如有需要请考虑其他设计方案，例如
复用任务。

被删除的任务不再存在，也无法再次进入 *Running* 状态。

如果任务在使用动态内存分配创建后自行删除，空闲任务负责释放该任务所用内存，
包括任务数据结构与栈。因此此时必须确保应用不会完全饿死空闲任务。

> *注意：只有内核为任务本身分配的内存会在任务删除时自动释放。
> 任务实现中自行分配的任何内存或其他资源，若不再需要，必须显式释放。*


<a name="list4.26" title="清单 4.26 vTaskDelete() API 函数原型"></a>


```c
void vTaskDelete( TaskHandle_t xTaskToDelete );
```

***清单 4.26*** *vTaskDelete() API 函数原型*

**vTaskDelete() 参数**

- `pxTaskToDelete`

	要删除的任务句柄（目标任务）。获取任务句柄的方法见 `xTaskCreate()` 的
	`pxCreatedTask` 参数或 `xTaskCreateStatic()` 的返回值。

	任务可通过传入 NULL 来删除自身。


<a name="example4.9" title="示例 4.9 删除任务"></a>
---
***示例 4.9*** *删除任务*

---

这是一个非常简单的示例，行为如下：

1. `main()` 以优先级 1 创建 Task 1。Task 1 运行后以优先级 2 创建 Task 2。
	 Task 2 此时为最高优先级任务，因此立即开始执行。`main()` 的源码见清单 4.27，
	 Task 1 的源码见清单 4.28。

1. Task 2 仅执行删除自身的操作。它可通过向 `vTaskDelete()` 传入 NULL 删除自身，
	 但为了演示，使用了自己的任务句柄。Task 2 的源码见清单 4.29。

1. Task 2 删除后，Task 1 再次成为最高优先级任务，继续执行——随后调用
	 `vTaskDelay()` 阻塞一小段时间。

1. 当 Task 1 处于阻塞状态时，空闲任务运行并释放先前分配给已删除 Task 2 的内存。

1. Task 1 离开阻塞状态后再次成为最高优先级 *Ready* 状态任务，并抢占空闲任务。
	 当进入 *Running* 状态时又创建 Task 2，如此循环。


<a name="list4.27" title="清单 4.27 示例 4.9 的 main() 实现"></a>

```c
int main( void )
{
		/* 创建第一个任务，优先级为 1。 */
		xTaskCreate( vTask1, "Task 1", 1000, NULL, 1, NULL );

		/* 启动调度器，使任务开始执行。 */
		vTaskStartScheduler();

		/* 调度器已启动，main() 不应到达这里。 */
		for( ;; )
		{
		}
}
```

***清单 4.27*** *示例 4.9 的 main() 实现*
***


<a name="list4.28" title="清单 4.28 示例 4.9 中 Task 1 的实现"></a>

```c
TaskHandle_t xTask2Handle = NULL;

void vTask1( void * pvParameters )
{
		const TickType_t xDelay100ms = pdMS_TO_TICKS( 100UL );

		for( ;; )
		{
				/* 打印该任务的名称。 */
				vPrintLine( "Task 1 is running" );

				/*
				 * 以更高优先级创建 Task 2。
				 * 将 xTask2Handle 的地址作为 pxCreatedTask 参数传入，
				 * 以便 xTaskCreate 将生成的任务句柄写入该变量。
				 */
				xTaskCreate( vTask2, "Task 2", 1000, NULL, 2, &xTask2Handle );

				/*
				 * Task 2 具有/曾具有更高优先级。Task 1 能执行到此处，
				 * 说明 Task 2 已经运行并删除了自身。
				 */
				vTaskDelay( xDelay100ms );
		}
}
```

***清单 4.28*** *示例 4.9 中 Task 1 的实现*


<a name="list4.29" title="清单 4.29 示例 4.9 中 Task 2 的实现"></a>


```c
void vTask2( void * pvParameters )
{
		/*
		 * Task 2 启动后立即删除自身。
		 * 可通过向 vTaskDelete() 传入 NULL 来实现；
		 * 为演示起见，这里改为传入它自己的任务句柄。
		 */
		vPrintLine( "Task 2 is running and about to delete itself" );
		vTaskDelete( xTask2Handle );
}
```

***清单 4.29*** *示例 4.9 中 Task 2 的实现*


<a name="fig4.16" title="图 4.16 执行示例 4.9 的输出"></a>

***

```console
C:\Temp>rtosdemo
Task1 is running
Task2 is running and about to delete itself
Task1 is running
Task2 is running and about to delete itself
Task1 is running
Task2 is running and about to delete itself
Task1 is running
Task2 is running and about to delete itself
Task1 is running
Task2 is running and about to delete itself
Task1 is running
Task2 is running and about to delete itself
Task1 is running
Task2 is running and about to delete itself
Task1 is running
Task2 is running and about to delete itself
```

***图 4.16*** *执行示例 4.9 的输出*
***


<a name="fig4.17" title="图 4.17 示例 4.9 的执行序列"></a>

***
![](media/figure_4.17_example_4.9_execution_sequence.png)
***图 4.17*** *示例 4.9 的执行序列*
***


## 4.11 线程本地存储与可重入性

线程本地存储允许应用开发者将任意数据存储在每个任务的任务控制块中。
该特性最常用于保存非可重入函数通常会存放在全局变量中的数据。

可重入函数可以在多线程中安全运行且无副作用。若在多线程环境中使用不可重入函数
而又没有线程本地存储，则必须在临界区内检查这些函数调用的“带外”结果。
过度使用临界区会降低 RTOS 性能，因此通常更倾向于使用线程本地存储。

线程本地存储最常见的用途是 ISO C 标准库和 POSIX 系统中的全局变量 `errno`。
`errno` 用于为标准库函数（如 strtof、strtol）提供扩展结果或错误码。

### 4.11.1 C 运行库线程本地存储实现

多数嵌入式 libc 实现提供 API，以确保不可重入函数在多线程环境中正确工作。
FreeRTOS 支持两个常用开源库的可重入 API：
[newlib](https://sourceware.org/newlib/) 与
[picolibc](https://github.com/picolibc/picolibc)。
这些预构建的 C 运行库线程本地存储实现可通过在项目的 FreeRTOSConfig.h 文件中
定义以下宏启用：

- `configUSE_NEWLIB_REENTRANT`（用于 [newlib](https://sourceware.org/newlib/)）
- `configUSE_PICOLIBC_TLS`（用于 [picolibc](https://github.com/picolibc/picolibc)）

### 4.11.2 自定义 C 运行库线程本地存储

应用开发者可通过在 FreeRTOSConfig.h 中定义以下宏实现线程本地存储：

- 将 `configUSE_C_RUNTIME_TLS_SUPPORT` 设为 1，以启用 C 运行库 TLS 支持。

- 将 `configTLS_BLOCK_TYPE` 定义为用于保存 C 运行库 TLS 数据的 C 类型。

- 将 `configINIT_TLS_BLOCK` 定义为初始化 C 运行库 TLS 块时运行的 C 代码。

- 将 `configSET_TLS_BLOCK` 定义为切换到新任务时运行的 C 代码。

- 将 `configDEINIT_TLS_BLOCK` 定义为反初始化 C 运行库 TLS 块时运行的 C 代码。

### 4.11.3 应用级线程本地存储

除了 C 运行库 TLS 外，应用开发者还可以在任务控制块中定义一组应用专用指针。
该特性通过在项目 FreeRTOSConfig.h 中将 `configNUM_THREAD_LOCAL_STORAGE_POINTERS`
设置为非零启用。清单 4.30 所示的
`vTaskSetThreadLocalStoragePointer` 与 `pvTaskGetThreadLocalStoragePointer`
函数可分别用于在运行时设置与获取每个线程本地存储指针的值。


<a name="list4.30" title="清单 4.30 线程本地存储指针 API 函数原型"></a>

```c
void * pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery,
																					 BaseType_t xIndex )

void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet,
																				BaseType_t xIndex,
																				void * pvValue );
```

***清单 4.30*** *线程本地存储指针 API 函数原型*


## 4.12 调度算法

### 4.12.1 任务状态与事件回顾

实际正在运行（占用处理时间）的任务处于 *Running* 状态。单核处理器任一时刻只能有
一个任务处于 *Running* 状态。也可以在多核上运行 FreeRTOS（非对称多处理 AMP），
或让 FreeRTOS 在多个核心上调度任务（对称多处理 SMP）。这些场景此处不描述。

不在运行、但也不处于 *Blocked* 或 *Suspended* 状态的任务处于 *Ready* 状态。处于
*Ready* 状态的任务可被调度器选择为进入 *Running* 状态的任务。调度器总是选择
最高优先级的 *Ready* 状态任务进入 *Running* 状态。

任务可在 *Blocked* 状态等待事件，并在事件发生时自动移回 *Ready* 状态。时间事件
发生于特定时间点，例如阻塞时间到期，常用于实现周期性或超时行为。同步事件在任务
或中断服务例程通过任务通知、队列、事件组、消息缓冲区、流缓冲区或多种信号量之一
发送信息时发生。它们通常用于指示异步活动，例如外设数据到达。


### 4.12.2 选择调度算法

调度算法是决定哪个 *Ready* 状态任务转换为 *Running* 状态的软件例程。

此前所有示例都使用同一调度算法，但可通过 `configUSE_PREEMPTION` 与
`configUSE_TIME_SLICING` 配置常量改变算法。两个常量均在 FreeRTOSConfig.h 中定义。

第三个配置常量 `configUSE_TICKLESS_IDLE` 也会影响调度算法，因为启用后 tick 中断
可能在较长时间内被完全关闭。`configUSE_TICKLESS_IDLE` 是专为需要最小化功耗的应用
提供的高级选项。本节描述假定 `configUSE_TICKLESS_IDLE` 为 0（若未定义则默认 0）。

在所有可能的单核配置中，FreeRTOS 调度器会轮流选择共享同一优先级的任务。
这种“轮流”策略通常称为 “Round Robin Scheduling”（轮转调度）。轮转调度并不保证
相同优先级任务获得完全相等的时间，只保证同优先级 *Ready* 任务轮流进入 *Running*
状态。

<a name="tbl5" title="表 5 配置内核调度算法的 FreeRTOSConfig.h 设置"></a>

***
| 调度算法                         | 是否优先级调度 | `configUSE_PREEMPTION` | `configUSE_TIME_SLICING` |
|----------------------------------|----------------|------------------------|--------------------------|
| 抢占式且启用时间片               | 是             | 1 | 1   |
| 抢占式但不启用时间片             | 是             | 1 | 0   |
| 协作式                           | 否             | 0 | 任意 |

***表 5*** *配置内核调度算法的 FreeRTOSConfig.h 设置*
* * *

### 4.12.3 带时间片的优先级抢占式调度

表 5 的配置使 FreeRTOS 使用一种称为“固定优先级抢占式调度并带时间片”的算法。
这是大多数小型 RTOS 应用采用的算法，也是本书目前所有示例使用的算法。
下表给出该算法名称中术语的解释。

**调度策略术语解释：**

- 固定优先级（Fixed Priority）

	“固定优先级”调度算法不会改变被调度任务的优先级，但不禁止任务自行改变自身
	或其他任务的优先级。

- 抢占式（Preemptive）

	抢占式调度在更高优先级任务进入 *Ready* 状态时，会立即抢占 *Running* 状态任务。
	被抢占意味着任务在未主动让出或阻塞的情况下被移出 *Running* 状态并回到 *Ready*
	状态，以让另一个任务进入 *Running* 状态。任务抢占可在任何时刻发生，不仅仅在
	RTOS 的 tick 中断中。

- 时间片（Time Slicing）

	时间片用于在同优先级任务之间共享处理器时间，即便任务未显式让出或进入
	*Blocked* 状态。使用时间片的调度算法会在每个时间片结束时（若存在其他同优先级
	*Ready* 任务）选择新任务进入 *Running* 状态。一个时间片等于两次 RTOS tick 中断
	之间的时间。

图 4.18 与图 4.19 展示了在使用固定优先级抢占式调度并带时间片时任务的调度方式。
图 4.18 显示当应用中所有任务优先级各不相同时的进入 *Running* 状态顺序。图 4.19
显示当应用中有两个任务共享同一优先级时的进入 *Running* 状态顺序。


<a name="fig4.18" title="图 4.18 强调任务优先级与抢占的执行模式"></a>

***
![](media/figure_4.18_preemption_execution_pattern.png)
***图 4.18*** *在假设应用中每个任务都有唯一优先级的情况下，强调任务优先级与抢占
的执行模式*
***

参见图 4.18：

- 空闲任务（Idle Task）

	空闲任务以最低优先级运行，因此每当更高优先级任务进入 *Ready* 状态时都会被
	抢占，例如 t3、t5 与 t9。

- Task 3

	Task 3 是事件驱动任务，优先级较低但高于空闲优先级。它大部分时间处于 *Blocked*
	状态等待事件发生。每次事件发生时，它从 *Blocked* 状态转入 *Ready* 状态。
	所有 FreeRTOS 任务间通信机制（任务通知、队列、信号量、事件组等）都可用于
	触发事件并解阻塞任务。

	事件发生在 t3 与 t5，另外在 t9 与 t12 之间某处也发生一次。t3 与 t5 时的事件
	能立即处理，因为此时 Task 3 是能运行的最高优先级任务。t9 与 t12 之间的事件
	直到 t12 才处理，因为在那之前 Task 1 与 Task 2 仍在执行。只有到 t12 时 Task 1
	与 Task 2 都处于 *Blocked* 状态，Task 3 才成为最高优先级的 *Ready* 状态任务。

- Task 2

	Task 2 是周期性任务，优先级高于 Task 3 但低于 Task 1。其周期意味着希望在
	t1、t6 与 t9 执行。

	在 t6 时，Task 3 处于 *Running* 状态，但 Task 2 具有更高优先级，因此抢占
	Task 3 并立即执行。Task 2 在 t7 完成处理并进入 *Blocked* 状态，此时 Task 3
	可重新进入 *Running* 状态完成处理。Task 3 在 t8 进入阻塞。

- Task 1

	Task 1 也是事件驱动任务，具有最高优先级，因此能抢占系统中任何其他任务。
	图中 Task 1 的事件发生在 t10，此时 Task 1 抢占 Task 2。Task 2 只能在 Task 1
	于 t11 重新进入 *Blocked* 状态后继续处理。


<a name="fig4.19" title="图 4.19 强调任务优先级与时间片的执行模式"></a>

***
![](media/figure_4.19_time_slicing_execution_pattern.png)
***图 4.19*** *在假设应用中两个任务同优先级的情况下，强调任务优先级与时间片的
执行模式*
***

参见图 4.19：

- 空闲任务与 Task 2

	空闲任务与 Task 2 都是持续处理任务，且优先级为 0（最低优先级）。调度器只有在
	没有更高优先级任务可运行时才为优先级 0 的任务分配处理时间，并通过时间片在
	这些任务之间共享时间。每次 tick 中断开始一个新的时间片，在图 4.19 中发生于
	t1、t2、t3、t4、t5、t8、t9、t10 与 t11。

	空闲任务与 Task 2 轮流进入 *Running* 状态，因此在同一时间片内两者可能先后
	处于 *Running* 状态，如 t5 到 t8 之间所示。

- Task 1

	Task 1 优先级高于空闲优先级。Task 1 是事件驱动任务，大部分时间处于 *Blocked*
	状态等待事件发生，每次事件发生时从 *Blocked* 转入 *Ready*。

	事件发生在 t6。t6 时 Task 1 成为最高优先级可运行任务，因此在时间片中途抢占
	空闲任务。事件处理在 t7 完成，Task 1 重新进入 *Blocked* 状态。

图 4.19 显示空闲任务与应用创建的任务共享处理时间。如果应用创建的空闲优先级
任务有实际工作，而空闲任务没有，这种时间分配可能不理想。可以通过
`configIDLE_SHOULD_YIELD` 编译期配置常量改变空闲任务的调度方式：

- 若 `configIDLE_SHOULD_YIELD` 设为 0，空闲任务会在整个时间片内保持
	*Running* 状态，除非被更高优先级任务抢占。

- 若 `configIDLE_SHOULD_YIELD` 设为 1，空闲任务在其循环的每次迭代都会让出
	（自愿放弃剩余时间片），只要存在其他处于 *Ready* 状态的空闲优先级任务。

图 4.19 的执行模式对应 `configIDLE_SHOULD_YIELD` 为 0 的情况。图 4.20 展示了
在同一场景下将 `configIDLE_SHOULD_YIELD` 设为 1 的执行模式。


<a name="fig4.20" title="图 4.20 与图 4.19 相同场景但 configIDLE_SHOULD_YIELD 设为 1"></a>

***
![](media/figure_4.20_time_slicing_with_yield_execution_pattern.png)
***图 4.20*** *与图 4.19 相同场景但 `configIDLE_SHOULD_YIELD` 设为 1 时的执行模式*
***

图 4.20 还显示当 `configIDLE_SHOULD_YIELD` 设为 1 时，在空闲任务之后进入
*Running* 状态的任务不会获得完整时间片，而是仅执行空闲任务让出后的剩余时间片。

### 4.12.4 不带时间片的优先级抢占式调度

不带时间片的优先级抢占式调度与上一节描述的任务选择与抢占算法相同，但不使用
时间片在同优先级任务之间共享处理时间。

表 5 展示了将 FreeRTOS 配置为不带时间片的优先级抢占式调度所需的设置。

正如图 4.19 所示，若使用时间片且最高优先级可运行任务不止一个，则调度器会在
每次 RTOS tick 中断时选择新的任务进入 *Running* 状态（tick 中断标记一个时间片
结束）。若不使用时间片，调度器仅在以下情况下选择新的任务进入 *Running* 状态：

- 更高优先级任务进入 *Ready* 状态。

- 当前 *Running* 状态任务进入 *Blocked* 或 *Suspended* 状态。

不使用时间片时任务上下文切换次数少于使用时间片，因此可降低调度器处理开销。
然而，关闭时间片也可能导致同优先级任务获得极不均衡的处理时间，如图 4.21 所示。
因此，关闭时间片被视为高级技术，通常仅适用于经验丰富的用户。


<a name="fig4.21" title="图 4.21 展示关闭时间片时同优先级任务处理时间差异"></a>

***
![](media/figure_4.21_equal_priority_without_time_slicing_execution_pattern.png)
***图 4.21*** *展示关闭时间片时同优先级任务处理时间差异的执行模式*
***

参见图 4.21（假设 `configIDLE_SHOULD_YIELD` 设为 0）：

- Tick 中断

	Tick 中断发生在 t1、t2、t3、t4、t5、t8、t11、t12 与 t13。

- Task 1

	Task 1 是高优先级事件驱动任务，大部分时间处于 *Blocked* 状态等待事件。
	每次事件发生时，Task 1 从 *Blocked* 转入 *Ready* 状态，并因其是最高优先级
	*Ready* 状态任务而进入 *Running* 状态。图 4.21 显示 Task 1 在 t6 至 t7
	处理事件，然后在 t9 至 t10 再次处理事件。

- 空闲任务与 Task 2

	空闲任务与 Task 2 都是持续处理任务，优先级为 0（空闲优先级）。持续处理任务
	不会进入 *Blocked* 状态。

	未使用时间片，因此处于 *Running* 状态的空闲优先级任务会一直保持 *Running*
	直到被更高优先级的 Task 1 抢占。

	在图 4.21 中，空闲任务从 t1 开始运行，直到 t6 被 Task 1 抢占，期间超过四个
	完整 tick 周期。

	Task 2 在 t7 开始运行，即 Task 1 再次进入 *Blocked* 状态等待事件之时。Task 2
	一直处于 *Running* 状态直到 t9 被 Task 1 抢占，此时其运行时间不足一个 tick
	周期。

	在 t10，空闲任务重新进入 *Running* 状态，尽管它已获得比 Task 2 多四倍以上的
	处理时间。

### 4.12.5 协作式调度

本书重点讲解抢占式调度，但 FreeRTOS 也支持协作式调度。表 5 展示了配置为协作式
调度所需的 FreeRTOSConfig.h 设置。

使用协作式调度时（假设应用提供的中断服务例程不会显式请求上下文切换），只有当
*Running* 状态任务进入 *Blocked* 状态，或该任务通过调用 `taskYIELD()` 显式让出
（手动请求重新调度）时，才会发生上下文切换。任务不会被抢占，因此无法使用时间片。

图 4.22 展示协作式调度器的行为。图中水平虚线表示任务处于 *Ready* 状态的时间。


<a name="fig4.22" title="图 4.22 展示协作式调度器行为的执行模式"></a>

***
![](media/figure_4.22_cooperative_scheduler_execution_pattern.png)
***图 4.22*** *展示协作式调度器行为的执行模式*
***

参见图 4.22：

- Task 1

	Task 1 具有最高优先级。它起初处于 *Blocked* 状态，等待一个信号量。

	在 t3 时刻，一个中断释放信号量，使 Task 1 离开 *Blocked* 状态并进入 *Ready*
	状态（在中断中释放信号量将在第 6 章介绍）。

	在 t3 时刻，Task 1 是最高优先级的 *Ready* 状态任务。如果使用抢占式调度，
	Task 1 会成为 *Running* 状态任务。但在协作式调度下，Task 1 会一直保持
	*Ready* 状态直到 t4，即当前 *Running* 状态任务调用 `taskYIELD()` 时。

- Task 2

	Task 2 优先级介于 Task 1 与 Task 3 之间。它起初处于 *Blocked* 状态，等待
	Task 3 在 t2 时发送的消息。

	在 t2 时刻，Task 2 是最高优先级的 *Ready* 状态任务，如果使用抢占式调度，
	Task 2 会成为 *Running* 状态任务。但在协作式调度下，Task 2 会一直处于 *Ready*
	状态，直到 *Running* 状态任务进入 *Blocked* 状态或调用 `taskYIELD()`。

	*Running* 状态任务在 t4 调用了 `taskYIELD()`，但此时 Task 1 已是最高优先级
	*Ready* 状态任务，因此 Task 2 直到 Task 1 在 t5 重新进入 *Blocked* 状态后
	才真正成为 *Running* 状态任务。

	在 t6，Task 2 重新进入 *Blocked* 状态等待下一条消息，此时 Task 3 再次成为
	最高优先级 *Ready* 状态任务。

在多任务应用中，应用编写者必须确保资源不会被多个任务同时访问，因为同时访问
可能会破坏资源。例如以下 UART（串口）资源被访问的场景：两个任务向 UART 写字符串；
Task 1 写 “abcdefghijklmnop”，Task 2 写 “123456789”。

1. Task 1 处于 *Running* 状态开始写字符串，写到 “abcdefg” 后离开 *Running* 状态，
	 尚未写完。

1. Task 2 进入 *Running* 状态并写入 “123456789”，随后离开 *Running* 状态。

1. Task 1 再次进入 *Running* 状态并写入剩余字符。

在该场景中，UART 上实际写入的是 “abcdefg123456789hijklmnop”。Task 1 的字符串
并未按预期连续输出，而是被 Task 2 的字符串插入而发生破坏。

使用协作式调度通常更容易避免资源的同时访问问题，而使用抢占式调度则更难[^7]：

[^7]: 任务之间安全共享资源的方法将在本书后续章节介绍。FreeRTOS 自身提供的资源
（如队列与信号量）在任务之间共享时始终是安全的。

- 使用抢占式调度时，*Running* 状态任务可能在任何时刻被抢占，包括资源处于不一致
	状态时。正如 UART 示例所示，将资源置于不一致状态可能导致数据损坏。

- 使用协作式调度时，你可以控制任务切换发生的时机，从而确保在资源处于不一致状态时
	不会切换到其他任务。

- 在上述 UART 示例中，你可以确保 Task 1 在写完整个字符串前不离开 *Running* 状态，
	从而消除被其他任务破坏字符串的可能。

正如图 4.22 所示，使用协作式调度的系统响应性不如抢占式调度：

- 使用抢占式调度时，调度器在任务成为最高优先级 *Ready* 状态任务时立即运行该任务。
	这对于必须在限定时间内响应高优先级事件的实时系统往往至关重要。

- 使用协作式调度时，当某任务成为最高优先级 *Ready* 状态任务后，只有当当前
	*Running* 状态任务进入 *Blocked* 状态或调用 `taskYIELD()` 时才会切换。

