# 5 队列管理

## 5.1 简介

“队列（Queue）”提供了任务到任务、任务到中断、以及中断到任务的通信机制。


### 5.1.1 范围

本章涵盖：

- 如何创建队列。
- 队列如何管理其包含的数据。
- 如何向队列发送数据。
- 如何从队列接收数据。
- 在队列上阻塞意味着什么。
- 如何在多个队列上阻塞。
- 如何覆盖队列中的数据。
- 如何清空队列。
- 任务优先级在写入与读取队列时的影响。

本章仅涉及任务到任务的通信。第 7 章将介绍任务到中断及中断到任务的通信。


## 5.2 队列的特性

### 5.2.1 数据存储

队列可保存有限数量且大小固定的数据项[^8]。队列可容纳的最大数据项数量称为其
“长度”。队列长度与每个数据项大小均在创建队列时设置。

[^8]: 本书稍后介绍的 FreeRTOS 消息缓冲区提供了一种更轻量的替代方案，可保存
变长消息。

队列通常作为先进先出（FIFO）缓冲区使用，数据写入队列尾部（tail），从队列头部
（head）移出。图 5.1 展示了 FIFO 队列的写入与读取过程。也可以写入队列头部，
以及覆盖队列头部已有的数据。

<a name="fig5.1" title="图 5.1 队列写入与读取示例序列"></a>

* * *
![](media/image31.png)   
***图 5.1*** *队列写入与读取示例序列*
* * *

队列行为可用两种方式实现：

1. 按拷贝入队（Queue by copy）

	 按拷贝入队意味着发送到队列的数据会按字节逐一拷贝到队列中。

1. 按引用入队（Queue by reference）

	 按引用入队意味着队列只保存指向数据的指针，而不保存数据本身。

FreeRTOS 使用按拷贝入队，因为相较按引用入队既更强大也更易使用，原因包括：

- 按拷贝入队并不妨碍队列也用于按引用入队。例如，当数据过大不适合拷贝时，可以
  将指向数据的指针拷贝到队列中。

- 可以直接将栈变量发送到队列，即使该变量在其声明函数退出后不再存在。

- 可以在不预先为数据分配缓冲区的情况下发送数据——之后可将数据拷贝到已分配缓冲区，
  并将缓冲区引用入队。

- 发送任务可以立即复用已发送到队列的变量或缓冲区。

- 发送任务与接收任务完全解耦；应用设计者无需关心哪个任务“拥有”数据，或哪个任务
  负责释放数据。

- RTOS 完全负责分配用于存储数据的内存。

- 在受内存保护的系统中，RAM 访问受到限制，按引用入队只有在发送与接收任务都能访问
  被引用数据时才可实现。按拷贝入队允许数据跨越内存保护边界传递。


### 5.2.2 多任务访问

队列是独立对象，任何知晓其存在的任务或中断服务例程都可以访问它。多个任务可以
向同一队列写入，多个任务也可以从同一队列读取。实践中，队列具有多个写者很常见，
但拥有多个读者相对少见。


### 5.2.3 在队列读取上阻塞

当任务尝试从队列读取数据时，可以可选地指定“阻塞”时间。若队列为空，任务会在
*Blocked* 状态中等待数据可用的最长时间。处于 *Blocked* 状态等待队列数据的任务，
会在其他任务或中断向队列放入数据时自动转为 *Ready* 状态。如果指定的阻塞时间
在数据可用前到期，任务也会自动从 *Blocked* 状态转为 *Ready* 状态。

队列可以有多个读者，因此可能有多个任务阻塞在同一队列上等待数据。当数据到达时，
仅有一个任务被解阻塞，被解阻塞的是等待数据的最高优先级任务。若多个阻塞任务
优先级相同，则等待时间最长的任务被解阻塞。


### 5.2.4 在队列写入上阻塞

与读取类似，任务在写入队列时也可指定阻塞时间。此时阻塞时间表示任务在队列已满
的情况下等待队列有空间的最长时间。

队列可以有多个写者，因此当队列满时可能有多个任务阻塞等待完成发送操作。当队列
出现空间时，仅有一个任务被解阻塞，被解阻塞的是等待空间的最高优先级任务。若多个
阻塞任务优先级相同，则等待时间最长的任务被解阻塞。


### 5.2.5 在多个队列上阻塞

队列可以组合为集合，使任务进入 *Blocked* 状态等待集合中任一队列有数据可用。
第 5.6 节《从多个队列接收》展示了队列集合的使用。


### 5.2.6 创建队列：静态与动态队列

队列通过句柄引用，句柄类型为 `QueueHandle_t`。队列必须在使用前显式创建。

创建队列的 API 函数有两个：`xQueueCreate()` 与 `xQueueCreateStatic()`。

每个队列需要两块 RAM：一块用于保存队列的数据结构，另一块用于保存队列数据。
`xQueueCreate()` 从堆中动态分配所需 RAM，`xQueueCreateStatic()` 使用通过参数传入
的预分配 RAM。


## 5.3 使用队列

### 5.3.1 xQueueCreate() API 函数

清单 5.1 给出 `xQueueCreate()` 函数原型。`xQueueCreateStatic()` 额外增加两个参数，
分别指向预分配用于保存队列数据结构与数据存储区的内存。

<a name="list5.1" title="清单 5.1 xQueueCreate() API 函数原型"></a>

```c
QueueHandle_t xQueueCreate( UBaseType_t uxQueueLength, UBaseType_t uxItemSize );
```
***清单 5.1*** *xQueueCreate() API 函数原型*


**xQueueCreate() 参数与返回值：**

- `uxQueueLength`

  正在创建的队列可在任意时刻保存的最大数据项数量。

- `uxItemSize`

  队列中每个数据项的字节大小。

- 返回值

  若返回 NULL，表示堆内存不足，FreeRTOS 无法分配队列数据结构与存储区。
  第 2 章提供了 FreeRTOS 堆的更多信息。

  若返回非 NULL，则队列创建成功，返回值即为创建队列的句柄。

`xQueueReset()` 是一个 API 函数，用于将已创建的队列恢复到初始空状态。


### 5.3.2 xQueueSendToBack() 与 xQueueSendToFront() API 函数

`xQueueSendToBack()` 将数据发送到队列尾部（tail），`xQueueSendToFront()` 将数据
发送到队列头部（head）。

`xQueueSend()` 等同于 `xQueueSendToBack()`。

> *注意：切勿在中断服务例程中调用 `xQueueSendToFront()` 或
> `xQueueSendToBack()`。应使用其中断安全版本 `xQueueSendToFrontFromISR()` 与
> `xQueueSendToBackFromISR()`，详见第 7 章。*

<a name="list5.2" title="清单 5.2 xQueueSendToFront() API 函数原型"></a>


```c
BaseType_t xQueueSendToFront( QueueHandle_t xQueue,
										const void * pvItemToQueue,
										TickType_t xTicksToWait );
```
***清单 5.2*** *xQueueSendToFront() API 函数原型*


<a name="list5.3" title="清单 5.3 xQueueSendToBack() API 函数原型"></a>


```c
BaseType_t xQueueSendToBack( QueueHandle_t xQueue,
									  const void * pvItemToQueue,
									  TickType_t xTicksToWait );
```
***清单 5.3*** *xQueueSendToBack() API 函数原型*


**xQueueSendToFront() 与 xQueueSendToBack() 参数与返回值**

- `xQueue`

  要写入数据的队列句柄。该句柄由 `xQueueCreate()` 或 `xQueueCreateStatic()` 创建时返回。

- `pvItemToQueue`

  指向要拷贝进队列的数据。

  队列创建时已设置每个数据项的大小，因此会从 `pvItemToQueue` 向队列存储区拷贝相应
  字节数。

- `xTicksToWait`

  当队列已满时，调用任务在 *Blocked* 状态中等待队列可用空间的最长时间。
  当 `xTicksToWait` 为 0 且队列已满时，`xQueueSendToFront()` 与 `xQueueSendToBack()`
  将立即返回。

  阻塞时间以 tick 周期表示，绝对时间取决于 tick 频率。可使用 `pdMS_TO_TICKS()`
  将毫秒转换为 tick。

  将 `xTicksToWait` 设为 `portMAX_DELAY` 会使任务无限期等待（不超时），前提是
  FreeRTOSConfig.h 中 `INCLUDE_vTaskSuspend` 设为 1。

- 返回值

  可能的返回值有两个：

  - `pdPASS`

	 表示成功将数据发送到队列。

	 若指定了阻塞时间（`xTicksToWait` 非 0），调用任务可能会进入 *Blocked* 状态等待
	 队列空间，但在超时前成功写入队列。

  - `errQUEUE_FULL`（与 `pdFAIL` 相同）

	 队列已满导致写入失败时返回 `errQUEUE_FULL`。

	 若指定了阻塞时间（`xTicksToWait` 非 0），调用任务会进入 *Blocked* 状态等待
	 其他任务或中断腾出队列空间，但在超时前未发生。


### 5.3.3 xQueueReceive() API 函数

`xQueueReceive()` 从队列接收（读取）一个数据项，并将其从队列中移除。

> *注意：切勿在中断服务例程中调用 `xQueueReceive()`。其中断安全版本
> `xQueueReceiveFromISR()` 在第 7 章介绍。*

<a name="list5.4" title="清单 5.4 xQueueReceive() API 函数原型"></a>

```c
BaseType_t xQueueReceive( QueueHandle_t xQueue,
								  void * const pvBuffer,
								  TickType_t xTicksToWait );
```
***清单 5.4*** *xQueueReceive() API 函数原型*


**xQueueReceive() 参数与返回值**

- `xQueue`

  要读取数据的队列句柄。该句柄由 `xQueueCreate()` 或 `xQueueCreateStatic()` 创建时返回。

- `pvBuffer`

  指向用于保存接收数据的内存。

  队列创建时已设置每个数据项的大小，因此 `pvBuffer` 所指向的内存必须足够容纳
  这些字节。

- `xTicksToWait`

  当队列为空时，调用任务在 *Blocked* 状态中等待数据可用的最长时间。

  若 `xTicksToWait` 为 0，且队列为空，则 `xQueueReceive()` 立即返回。

  阻塞时间以 tick 周期表示，绝对时间取决于 tick 频率。可使用 `pdMS_TO_TICKS()`
  将毫秒转换为 tick。

  将 `xTicksToWait` 设为 `portMAX_DELAY` 会使任务无限期等待（不超时），前提是
  FreeRTOSConfig.h 中 `INCLUDE_vTaskSuspend` 设为 1。

- 返回值

  可能的返回值有两个：

  - `pdPASS`

	 表示成功从队列读取数据。

	 若指定了阻塞时间（`xTicksToWait` 非 0），调用任务可能会进入 *Blocked* 状态等待
	 数据可用，但在超时前成功读取队列数据。</p>

  - `errQUEUE_EMPTY`（与 `pdFAIL` 相同）

	 当队列为空导致无法读取数据时返回 `errQUEUE_EMPTY`。

	 若指定了阻塞时间（`xTicksToWait` 非 0），调用任务会进入 *Blocked* 状态等待
	 其他任务或中断向队列发送数据，但在超时前未发生。


### 5.3.4 uxQueueMessagesWaiting() API 函数

`uxQueueMessagesWaiting()` 用于查询队列中当前数据项数量。

> *注意：切勿在中断服务例程中调用 `uxQueueMessagesWaiting()`。应使用其中断安全版本
> `uxQueueMessagesWaitingFromISR()`。*

<a name="list5.5" title="清单 5.5 uxQueueMessagesWaiting() API 函数原型"></a>

```c
UBaseType_t uxQueueMessagesWaiting( QueueHandle_t xQueue );
```
***清单 5.5*** *uxQueueMessagesWaiting() API 函数原型*


**uxQueueMessagesWaiting() 参数与返回值**

- `xQueue`

  被查询的队列句柄。该句柄由 `xQueueCreate()` 或 `xQueueCreateStatic()` 创建时返回。

- 返回值

  队列中当前的数据项数量。返回 0 表示队列为空。


<a name="example5.1" title="示例 5.1 在从队列接收时阻塞"></a>
---
***示例 5.1*** *在从队列接收时阻塞*

---

该示例演示创建队列、从多个任务向队列发送数据以及从队列接收数据。队列被创建为
保存 `int32_t` 类型数据项。发送任务不指定阻塞时间，而接收任务指定阻塞时间。

发送任务的优先级低于接收任务，这意味着队列中不会同时包含多个数据项，因为一旦
数据进入队列，接收任务会解除阻塞并抢占发送任务（因为它优先级更高），随即取走
数据，使队列再次为空。

该示例创建了两个任务实例，如清单 5.6 所示：一个不断向队列写入 100，另一个不断
写入 200。任务参数用于向每个实例传递不同的数值。

<a name="list5.6" title="清单 5.6 示例 5.1 中发送任务的实现"></a>

```c
static void vSenderTask( void *pvParameters )
{

	 int32_t lValueToSend;

	 BaseType_t xStatus;

	 /* Two instances of this task are created so the value that is sent to
		 the queue is passed in via the task parameter - this way each instance 
		 can use a different value. The queue was created to hold values of type 
		 int32_t, so cast the parameter to the required type. */
	 lValueToSend = ( int32_t ) pvParameters;

	 /* As per most tasks, this task is implemented within an infinite loop. */
	 for( ;; )
	 {

		  /* Send the value to the queue.

			  The first parameter is the queue to which data is being sent. The
			  queue was created before the scheduler was started, so before this 
			  task started to execute.

			  The second parameter is the address of the data to be sent, in this 
			  case the address of lValueToSend.

			  The third parameter is the Block time – the time the task should be 
			  kept in the Blocked state to wait for space to become available on 
			  the queue should the queue already be full. In this case a block 
			  time is not specified because the queue should never contain more 
			  than one item, and therefore never be full. */
		  xStatus = xQueueSendToBack( xQueue, &lValueToSend, 0 );

		  if( xStatus != pdPASS )
		  {
				/* The send operation could not complete because the queue was full-
					this must be an error as the queue should never contain more than
					one item! */
				vPrintString( "Could not send to the queue.\r\n" );
		  }
	 }
}
```
***清单 5.6*** *示例 5.1 中发送任务的实现*


清单 5.7 展示接收任务的实现。接收任务指定 100 毫秒阻塞时间，然后进入 *Blocked*
状态等待队列数据可用。当队列有数据或 100 毫秒到期时，任务离开 *Blocked* 状态。
本示例中有两个任务不断写入队列，因此 100 毫秒超时不会发生。

<a name="list5.7" title="清单 5.7 示例 5.1 中接收任务的实现"></a>

```c
static void vReceiverTask( void *pvParameters )
{
	 /* Declare the variable that will hold the values received from the
		 queue. */
	 int32_t lReceivedValue;
	 BaseType_t xStatus;
	 const TickType_t xTicksToWait = pdMS_TO_TICKS( 100 );

	 /* This task is also defined within an infinite loop. */
	 for( ;; )
	 {
		  /* This call should always find the queue empty because this task will
			  immediately remove any data that is written to the queue. */
		  if( uxQueueMessagesWaiting( xQueue ) != 0 )
		  {
				vPrintString( "Queue should have been empty!\r\n" );
		  }

		  /* Receive data from the queue.

			  The first parameter is the queue from which data is to be received.
			  The queue is created before the scheduler is started, and therefore
			  before this task runs for the first time.

			  The second parameter is the buffer into which the received data will
			  be placed. In this case the buffer is simply the address of a 
			  variable that has the required size to hold the received data.

			  The last parameter is the block time – the maximum amount of time 
			  that the task will remain in the Blocked state to wait for data to 
			  be available should the queue already be empty. */
		  xStatus = xQueueReceive( xQueue, &lReceivedValue, xTicksToWait );

		  if( xStatus == pdPASS )
		  {
				/* Data was successfully received from the queue, print out the
					received value. */
				vPrintStringAndNumber( "Received = ", lReceivedValue );
		  }
		  else
		  {
				/* Data was not received from the queue even after waiting for 
					100ms. This must be an error as the sending tasks are free 
					running and will be continuously writing to the queue. */
				vPrintString( "Could not receive from the queue.\r\n" );
		  }
	 }
}
```
***清单 5.7***  *示例 5.1 中接收任务的实现*


清单 5.8 给出了 `main()` 的定义，它仅在启动调度器前创建队列与三个任务。队列被
创建为最多保存 5 个 `int32_t` 值，尽管任务优先级的关系意味着队列在任意时刻
不会超过 1 个数据项。

<a name="list5.8" title="清单 5.8 示例 5.1 中 main() 的实现"></a>

```c
/* Declare a variable of type QueueHandle_t. This is used to store the
	handle to the queue that is accessed by all three tasks. */
QueueHandle_t xQueue;

int main( void )
{
	 /* The queue is created to hold a maximum of 5 values, each of which is
		 large enough to hold a variable of type int32_t. */
	 xQueue = xQueueCreate( 5, sizeof( int32_t ) );

	 if( xQueue != NULL )
	 {
		  /* Create two instances of the task that will send to the queue. The
			  task parameter is used to pass the value that the task will write 
			  to the queue, so one task will continuously write 100 to the queue 
			  while the other task will continuously write 200 to the queue. Both
			  tasks are created at priority 1. */
		  xTaskCreate( vSenderTask, "Sender1", 1000, ( void * ) 100, 1, NULL );
		  xTaskCreate( vSenderTask, "Sender2", 1000, ( void * ) 200, 1, NULL );

		  /* Create the task that will read from the queue. The task is created
			  with priority 2, so above the priority of the sender tasks. */
		  xTaskCreate( vReceiverTask, "Receiver", 1000, NULL, 2, NULL );

		  /* Start the scheduler so the created tasks start executing. */
		  vTaskStartScheduler();
	 }
	 else
	 {
		  /* The queue could not be created. */
	 }

	 /* If all is well then main() will never reach here as the scheduler will
		 now be running the tasks. If main() does reach here then it is likely
		 that there was insufficient FreeRTOS heap memory available for the idle 
		 task to be created. Chapter 3 provides more information on heap memory 
		 management. */
	 for( ;; );
}
```
***清单 5.8*** *示例 5.1 中 main() 的实现*

图 5.2 显示了示例 5.1 的输出。

<a name="fig5.2" title="图 5.2 执行示例 5.1 的输出"></a>

* * *
![](media/image32.jpg)   
***图 5.2*** *执行示例 5.1 的输出*
* * *


图 5.3 展示了执行序列。

<a name="fig5.3" title="图 5.3 示例 5.1 的执行序列"></a>

* * *
![](media/image33.png)   
***图 5.3*** *示例 5.1 的执行序列*
* * *


## 5.4 从多个来源接收数据

在 FreeRTOS 设计中，一个任务从多个来源接收数据很常见。接收任务需要知道数据来自
哪里，以决定后续处理。一个简单的设计模式是使用单个队列传输结构体，结构体同时
包含数据值和数据来源，如图 5.4 所示。

<a name="fig5.4" title="图 5.4 结构体通过队列发送的示例场景"></a>

* * *
![](media/image34.png)   
***图 5.4*** *结构体通过队列发送的示例场景*
* * *

参见图 5.4：

- 创建的队列保存 `Data_t` 类型结构体。该结构体允许在一条消息中同时发送数据值与
  枚举类型（表示数据意义）。

- 中央控制器（Controller）任务执行系统主要功能，需要响应通过队列传来的输入与
  状态变化。

- CAN 总线任务封装 CAN 总线接口功能。当 CAN 任务收到并解析消息后，将解析后的
  消息以 `Data_t` 结构体发送给 Controller 任务。结构体的 `eDataID` 成员告诉
  Controller 该数据是什么。在本示例中为电机转速值；`lDataValue` 成员给出实际转速。

- 人机接口（HMI）任务封装所有 HMI 功能。操作员可能以多种方式输入命令或查询
  数值，这些都需要在 HMI 任务中检测和解释。当收到新命令时，HMI 任务用 `Data_t`
  结构体把命令发送给 Controller 任务。结构体的 `eDataID` 成员告诉 Controller 该
  数据是什么，在本例中为新的设定值；`lDataValue` 成员给出实际设定值。

（RB-TBD）章节将展示如何扩展该设计模式，使控制器任务可以直接回复发送结构体的任务。


<a name="example5.2" title="示例 5.2 在发送到队列时阻塞，并通过队列发送结构体"></a>
---
***示例 5.2*** *在发送到队列时阻塞，并通过队列发送结构体*

---

示例 5.2 与示例 5.1 类似，但任务优先级相反：接收任务优先级低于发送任务。并且
创建的队列保存结构体而非整数。

清单 5.9 给出示例 5.2 使用的结构体定义。

<a name="list5.9" title="清单 5.9 通过队列传递的结构体定义，以及示例使用的两个变量"></a>

```c
/* Define an enumerated type used to identify the source of the data. */
typedef enum
{
	 eSender1,
	 eSender2
} DataSource_t;

/* Define the structure type that will be passed on the queue. */
typedef struct
{
	 uint8_t ucValue;
	 DataSource_t eDataSource;
} Data_t;

/* Declare two variables of type Data_t that will be passed on the queue. */
static const Data_t xStructsToSend[ 2 ] =
{
	 { 100, eSender1 }, /* Used by Sender1. */
	 { 200, eSender2 }  /* Used by Sender2. */
};
```
***清单 5.9*** *通过队列传递的结构体定义，以及示例使用的两个变量*

在示例 5.1 中，接收任务优先级最高，因此队列从不包含多个数据项。这是因为一旦
数据进入队列，接收任务就会抢占发送任务并立即移走数据。在示例 5.2 中，发送任务
优先级更高，因此队列通常是满的。这是因为接收任务一旦从队列移走一个数据项，
就会被发送任务抢占，发送任务立即再次填满队列。随后发送任务进入 *Blocked*
状态等待队列空间。

清单 5.10 展示发送任务实现。发送任务指定 100 毫秒阻塞时间，因此每当队列满时，
它都会进入 *Blocked* 状态等待空间可用。当队列有空间，或 100 毫秒过去仍无空间
时离开 *Blocked* 状态。本示例中接收任务持续释放空间，因此 100 毫秒超时不会发生。

<a name="list5.10" title="清单 5.10 示例 5.2 中发送任务的实现"></a>

```c
static void vSenderTask( void *pvParameters )
{
	 BaseType_t xStatus;
	 const TickType_t xTicksToWait = pdMS_TO_TICKS( 100 );

	 /* As per most tasks, this task is implemented within an infinite loop. */
	 for( ;; )
	 {
		  /* Send to the queue.

			  The second parameter is the address of the structure being sent. The
			  address is passed in as the task parameter so pvParameters is used
			  directly.

			  The third parameter is the Block time - the time the task should be 
			  kept in the Blocked state to wait for space to become available on 
			  the queue if the queue is already full. A block time is specified 
			  because the sending tasks have a higher priority than the receiving 
			  task so the queue is expected to become full. The receiving task 
			  will remove items from the queue when both sending tasks are in the 
			  Blocked state. */
		  xStatus = xQueueSendToBack( xQueue, pvParameters, xTicksToWait );

		  if( xStatus != pdPASS )
		  {
				/* The send operation could not complete, even after waiting for 
					100ms. This must be an error as the receiving task should make 
					space in the queue as soon as both sending tasks are in the 
					Blocked state. */
				vPrintString( "Could not send to the queue.\r\n" );
		  }
	 }
}
```
***清单 5.10*** *示例 5.2 中发送任务的实现*


接收任务优先级最低，因此只有当两个发送任务都处于 *Blocked* 状态时才运行。
发送任务只有在队列满时才进入 *Blocked* 状态，所以接收任务只会在队列满时执行。
因此即便不指定阻塞时间，它也总能接收到数据。

清单 5.11 展示接收任务实现。

<a name="list5.11" title="清单 5.11 示例 5.2 中接收任务的定义"></a>

```c
static void vReceiverTask( void *pvParameters )
{
	 /* Declare the structure that will hold the values received from the
		 queue. */
	 Data_t xReceivedStructure;
	 BaseType_t xStatus;

	 /* This task is also defined within an infinite loop. */
	 for( ;; )
	 {
		  /* Because it has the lowest priority this task will only run when the
			  sending tasks are in the Blocked state. The sending tasks will only
			  enter the Blocked state when the queue is full so this task always 
			  expects the number of items in the queue to be equal to the queue 
			  length, which is 3 in this case. */
		  if( uxQueueMessagesWaiting( xQueue ) != 3 )
		  {
				vPrintString( "Queue should have been full!\r\n" );
		  }

		  /* Receive from the queue.

			  The second parameter is the buffer into which the received data will
			  be placed. In this case the buffer is simply the address of a 
			  variable that has the required size to hold the received structure.

			  The last parameter is the block time - the maximum amount of time 
			  that the task will remain in the Blocked state to wait for data to 
			  be available if the queue is already empty. In this case a block 
			  time is not necessary because this task will only run when the 
			  queue is full. */
		  xStatus = xQueueReceive( xQueue, &xReceivedStructure, 0 );

		  if( xStatus == pdPASS )
		  {
				/* Data was successfully received from the queue, print out the
					received value and the source of the value. */
				if( xReceivedStructure.eDataSource == eSender1 )
				{
					 vPrintStringAndNumber( "From Sender 1 = ", 
													xReceivedStructure.ucValue );
				}
				else
				{
					 vPrintStringAndNumber( "From Sender 2 = ", 
													xReceivedStructure.ucValue );
				}
		  }
		  else
		  {
				/* Nothing was received from the queue. This must be an error as 
					this task should only run when the queue is full. */
				vPrintString( "Could not receive from the queue.\r\n" );
		  }
	 }
}
```
***清单 5.11*** *示例 5.2 中接收任务的定义*

`main()` 只做了轻微改动。队列被创建为保存三个 `Data_t` 结构体，发送与接收任务
优先级互换。清单 5.12 给出 `main()` 的实现。

<a name="list5.12" title="清单 5.12 示例 5.2 中 main() 的实现"></a>

```c
int main( void )
{
	 /* The queue is created to hold a maximum of 3 structures of type Data_t. */
	 xQueue = xQueueCreate( 3, sizeof( Data_t ) );

	 if( xQueue != NULL )
	 {
		  /* Create two instances of the task that will write to the queue. The
			  parameter is used to pass the structure that the task will write to
			  the queue, so one task will continuously send xStructsToSend[ 0 ]
			  to the queue while the other task will continuously send 
			  xStructsToSend[ 1 ]. Both tasks are created at priority 2, which is
			  above the priority of the receiver. */
		  xTaskCreate( vSenderTask, "Sender1", 1000, &( xStructsToSend[ 0 ] ),
							2, NULL );
		  xTaskCreate( vSenderTask, "Sender2", 1000, &( xStructsToSend[ 1 ] ),
							2, NULL );

		  /* Create the task that will read from the queue. The task is created
			  with priority 1, so below the priority of the sender tasks. */
		  xTaskCreate( vReceiverTask, "Receiver", 1000, NULL, 1, NULL );

		  /* Start the scheduler so the created tasks start executing. */
		  vTaskStartScheduler();
	 }
	 else
	 {
		  /* The queue could not be created. */
	 }

	 /* If all is well then main() will never reach here as the scheduler will
		 now be running the tasks. If main() does reach here then it is likely
		 that there was insufficient heap memory available for the idle task to 
		 be created. Chapter 3 provides more information on heap memory 
		 management. */
	 for( ;; );
}
```
***清单 5.12*** *示例 5.2 中 main() 的实现*

图 5.5 显示示例 5.2 的输出。

<a name="fig5.5" title="图 5.5 示例 5.2 的输出"></a>

* * *
![](media/image35.jpg)   
***图 5.5*** *示例 5.2 的输出*
* * *

图 5.6 展示了发送任务优先级高于接收任务时的执行序列。下面进一步解释图 5.6，
并说明为何前四条消息来自同一任务。

<a name="fig5.6" title="图 5.6 示例 5.2 的执行序列"></a>

* * *
![](media/image36.png)   
***图 5.6*** *示例 5.2 的执行序列*
* * *

**图 5.6 说明**

- t1

  发送任务 1 执行并向队列发送 3 个数据项。

- t2

  队列已满，发送任务 1 进入 *Blocked* 状态等待下一次发送完成。此时发送任务 2
  成为最高优先级可运行任务，进入 *Running* 状态。

- t3

  发送任务 2 发现队列已满，进入 *Blocked* 状态等待首次发送完成。此时接收任务
  成为最高优先级可运行任务，进入 *Running* 状态。

- t4

  两个优先级高于接收任务的任务都在等待队列空间，因此接收任务一旦移除一个数据项
  便会被抢占。发送任务 1 与发送任务 2 同优先级，调度器选择等待时间更长的任务进入
  *Running* 状态——此处为发送任务 1。

- t5

  发送任务 1 向队列发送一个数据项。队列只有一个空位，因此发送任务 1 进入
  *Blocked* 状态等待下一次发送完成。接收任务再次成为最高优先级可运行任务并进入
  *Running* 状态。

  此时发送任务 1 已发送 4 个数据项，而发送任务 2 仍在等待发送其第一个数据项。

- t6

  两个优先级高于接收任务的任务都在等待队列空间，因此接收任务一旦移除一个数据项
  便会被抢占。这次发送任务 2 的等待时间长于发送任务 1，因此发送任务 2 进入
  *Running* 状态。

- t7

  发送任务 2 向队列发送一个数据项。队列只有一个空位，因此发送任务 2 进入
  *Blocked* 状态等待下一次发送完成。此时发送任务 1 与发送任务 2 都在等待队列空间，
  因此接收任务是唯一可进入 *Running* 状态的任务。


## 5.5 处理大数据或变长数据

### 5.5.1 队列化指针

当队列中的数据很大时，使用队列传递指针更合适，而不是逐字节拷贝数据。传递指针
在处理时间与创建队列所需 RAM 上都更高效。但在按指针入队时必须特别注意：

- 指向 RAM 的所有权必须明确。

  通过指针在任务间共享内存时，必须确保两个任务不会同时修改内存内容，或进行其他
  导致内存内容无效或不一致的操作。理想情况下，指针发送到队列之前只有发送任务
  允许访问该内存，指针从队列接收后只有接收任务允许访问该内存。

- 指向的 RAM 必须保持有效。

  如果所指内存是动态分配的，或来自预分配缓冲池，则必须由且仅由一个任务负责释放。
  在内存被释放后，任何任务都不得再访问该内存。

  不得使用指针访问在任务栈上分配的数据。栈帧变化后该数据将失效。

例如，清单 5.13、5.14 与 5.15 展示如何通过队列在任务之间传递缓冲区指针：

- 清单 5.13 创建一个最多可保存 5 个指针的队列。

- 清单 5.14 分配缓冲区，写入字符串，然后将缓冲区指针发送到队列。

- 清单 5.15 从队列接收缓冲区指针，并打印缓冲区字符串。

<a name="list5.13" title="清单 5.13 创建保存指针的队列"></a>

```c
/* Declare a variable of type QueueHandle_t to hold the handle of the
	queue being created. */
QueueHandle_t xPointerQueue;

/* Create a queue that can hold a maximum of 5 pointers, in this case
	character pointers. */
xPointerQueue = xQueueCreate( 5, sizeof( char * ) );
```
***清单 5.13*** *创建保存指针的队列*

<a name="list5.14" title="清单 5.14 使用队列发送指向缓冲区的指针"></a>

```c
/* A task that obtains a buffer, writes a string to the buffer, then
	sends the address of the buffer to the queue created in Listing 5.13. */
void vStringSendingTask( void *pvParameters )
{
	 char *pcStringToSend;
	 const size_t xMaxStringLength = 50;
	 BaseType_t xStringNumber = 0;

	 for( ;; )
	 {
		  /* Obtain a buffer that is at least xMaxStringLength characters big.
			  The implementation of prvGetBuffer() is not shown – it might obtain
			  the buffer from a pool of pre-allocated buffers, or just allocate 
			  the buffer dynamically. */
		  pcStringToSend = ( char * ) prvGetBuffer( xMaxStringLength );

		  /* Write a string into the buffer. */
		  snprintf( pcStringToSend, xMaxStringLength, "String number %d\r\n",
						xStringNumber );

		  /* Increment the counter so the string is different on each iteration
			  of this task. */
		  xStringNumber++;

		  /* Send the address of the buffer to the queue that was created in
			  Listing 5.13. The address of the buffer is stored in the 
			  pcStringToSend variable.*/
		  xQueueSend( xPointerQueue,   /* The handle of the queue. */
						  &pcStringToSend, /* The address of the pointer that points
													 to the buffer. */
						  portMAX_DELAY );
	 }
}
```
***清单 5.14*** *使用队列发送指向缓冲区的指针*

<a name="list5.15" title="清单 5.15 使用队列接收指向缓冲区的指针"></a>

```c
/* A task that receives the address of a buffer from the queue created
	in Listing 5.13, and written to in Listing 5.14. The buffer contains a
	string, which is printed out. */

void vStringReceivingTask( void *pvParameters )
{
	 char *pcReceivedString;

	 for( ;; )
	 {
		  /* Receive the address of a buffer. */
		  xQueueReceive( xPointerQueue,     /* The handle of the queue. */
							  &pcReceivedString, /* Store the buffer's address in 
															pcReceivedString. */
							  portMAX_DELAY );

		  /* The buffer holds a string, print it out. */
		  vPrintString( pcReceivedString );

		  /* The buffer is not required any more - release it so it can be freed,
			  or re-used. */
		  prvReleaseBuffer( pcReceivedString );
	 }
}
```
***清单 5.15*** *使用队列接收指向缓冲区的指针*

### 5.5.2 使用队列发送不同类型和长度的数据[^9]

[^9]: FreeRTOS 消息缓冲区是可保存变长数据的更轻量替代方案。

前面的章节展示了两种强大设计模式：向队列发送结构体，以及向队列发送指针。
将两种技术结合起来，允许任务使用单个队列从任意数据源接收任意数据类型。
FreeRTOS+TCP TCP/IP 栈提供了一个实际示例。

TCP/IP 栈运行在独立任务中，必须处理来自多种来源的事件。不同事件类型关联不同
类型与长度的数据。`IPStackEvent_t` 结构体描述 TCP/IP 任务之外发生的所有事件，
并通过队列发送给 TCP/IP 任务。清单 5.16 给出 `IPStackEvent_t` 结构体。
`IPStackEvent_t` 的 `pvData` 成员既可以直接保存一个值，也可以指向缓冲区。

<a name="list5.16" title="清单 5.16 FreeRTOS+TCP 中用于向 TCP/IP 栈任务发送事件的结构体"></a>

```c
/* A subset of the enumerated types used in the TCP/IP stack to
	identify events. */
typedef enum
{
	 eNetworkDownEvent = 0, /* The network interface has been lost, or needs
										(re)connecting. */
	 eNetworkRxEvent,       /* A packet has been received from the network. */
	 eTCPAcceptEvent,       /* FreeRTOS_accept() called to accept or wait for a
										new client. */

/* Other event types appear here but are not shown in this listing. */

} eIPEvent_t;

/* The structure that describes events, and is sent on a queue to the
	TCP/IP task. */
typedef struct IP_TASK_COMMANDS
{
	 /* An enumerated type that identifies the event. See the eIPEvent_t
		 definition above. */
	 eIPEvent_t eEventType;

	 /* A generic pointer that can hold a value, or point to a buffer. */
	 void *pvData;

} IPStackEvent_t;
```
***清单 5.16*** *FreeRTOS+TCP 中用于向 TCP/IP 栈任务发送事件的结构体*

TCP/IP 事件示例如下：

- `eNetworkRxEvent`：网络收到数据包。

  网络接口使用 `IPStackEvent_t` 结构体向 TCP/IP 任务发送接收事件。结构体的
  `eEventType` 设为 `eNetworkRxEvent`，`pvData` 指向收到的数据缓冲区。
  清单 5.17 给出伪代码示例。

  <a name="list5.17" title="清单 5.17 伪代码：使用 IPStackEvent_t 向 TCP/IP 任务发送网络接收数据"></a>

  ```c
  void vSendRxDataToTheTCPTask( NetworkBufferDescriptor_t *pxRxedData )
  {
		IPStackEvent_t xEventStruct;
  
		/* Complete the IPStackEvent_t structure. The received data is stored in
			pxRxedData. */
		xEventStruct.eEventType = eNetworkRxEvent;
		xEventStruct.pvData = ( void * ) pxRxedData;
  
		/* Send the IPStackEvent_t structure to the TCP/IP task. */
		xSendEventStructToIPTask( &xEventStruct );
  }
  ```
  ***清单 5.17*** *伪代码：使用 IPStackEvent_t 向 TCP/IP 任务发送网络接收数据*

- `eTCPAcceptEvent`：socket 接受或等待客户端连接。

  调用 `FreeRTOS_accept()` 的任务使用 `IPStackEvent_t` 结构体向 TCP/IP 任务发送
  accept 事件。结构体的 `eEventType` 设为 `eTCPAcceptEvent`，`pvData` 设为正在接受
  连接的 socket 句柄。清单 5.18 给出伪代码示例。

  <a name="list5.18" title="清单 5.18 伪代码：使用 IPStackEvent_t 向 TCP/IP 任务发送接受连接的 socket 句柄"></a>

  ```c
  void vSendAcceptRequestToTheTCPTask( Socket_t xSocket )
  {
		IPStackEvent_t xEventStruct;

		/* Complete the IPStackEvent_t structure. */
		xEventStruct.eEventType = eTCPAcceptEvent;
		xEventStruct.pvData = ( void * ) xSocket;

		/* Send the IPStackEvent_t structure to the TCP/IP task. */
		xSendEventStructToIPTask( &xEventStruct );
  }
  ```
  ***清单 5.18*** *伪代码：使用 IPStackEvent_t 向 TCP/IP 任务发送接受连接的 socket 句柄*
  
- `eNetworkDownEvent`：网络需要连接或重新连接。

  网络接口使用 `IPStackEvent_t` 结构体向 TCP/IP 任务发送网络断开事件。
  `eEventType` 设为 `eNetworkDownEvent`。该事件不关联数据，因此 `pvData` 不使用。
  清单 5.19 给出伪代码示例。

  <a name="list5.19" title="清单 5.19 伪代码：使用 IPStackEvent_t 向 TCP/IP 任务发送网络断开事件"></a>

  ```c
  void vSendNetworkDownEventToTheTCPTask( Socket_t xSocket )
  {
		IPStackEvent_t xEventStruct;

		/* Complete the IPStackEvent_t structure. */
		xEventStruct.eEventType = eNetworkDownEvent;

		xEventStruct.pvData = NULL; /* Not used, but set to NULL for
												 completeness. */

		/* Send the IPStackEvent_t structure to the TCP/IP task. */
		xSendEventStructToIPTask( &xEventStruct );
  }
  ```
  ***清单 5.19*** *伪代码：使用 IPStackEvent_t 向 TCP/IP 任务发送网络断开事件*
  
  清单 5.20 展示 TCP/IP 任务中接收并处理这些事件的代码。可以看到从队列收到的
  `IPStackEvent_t` 结构体的 `eEventType` 成员用于决定如何解释 `pvData` 成员。

  <a name="list5.20" title="清单 5.20 伪代码：接收并处理 IPStackEvent_t 结构体"></a>

  ```c
  IPStackEvent_t xReceivedEvent;

  /* Block on the network event queue until either an event is received, or 
	  xNextIPSleep ticks pass without an event being received. eEventType is 
	  set to eNoEvent in case the call to xQueueReceive() returns because it 
	  timed out, rather than because an event was received. */
  xReceivedEvent.eEventType = eNoEvent;
  xQueueReceive( xNetworkEventQueue, &xReceivedEvent, xNextIPSleep );

  /* Which event was received, if any? */
  switch( xReceivedEvent.eEventType )
  {
		case eNetworkDownEvent :
			  /* Attempt to (re)establish a connection. This event is not 
				  associated with any data. */
			  prvProcessNetworkDownEvent();
			  break;

		case eNetworkRxEvent:
			  /* The network interface has received a new packet. A pointer to the
				  received data is stored in the pvData member of the received 
				  IPStackEvent_t structure. Process the received data. */
			  prvHandleEthernetPacket( ( NetworkBufferDescriptor_t * )
												( xReceivedEvent.pvData ) );
			  break;

		case eTCPAcceptEvent:
			  /* The FreeRTOS_accept() API function was called. The handle of the
				  socket that is accepting a connection is stored in the pvData 
				  member of the received IPStackEvent_t structure. */
			  xSocket = ( FreeRTOS_Socket_t * ) ( xReceivedEvent.pvData );
			  xTCPCheckNewClient( xSocket );
			  break;

		/* Other event types are processed in the same way, but are not shown
			here. */

  }
  ```
  ***清单 5.20*** *伪代码：接收并处理 IPStackEvent_t 结构体*  

## 5.6 从多个队列接收

### 5.6.1 队列集合

应用设计中常需要一个任务接收不同大小、不同含义、不同来源的数据。上一节展示了
通过单个队列接收结构体来实现这一点的简洁高效方法。然而，有时设计受到约束，
必须针对某些数据源使用独立队列。例如集成第三方代码时可能假定存在专用队列。
在这些情况下可使用“队列集合（queue set）”。

队列集合允许任务从多个队列接收数据，而无需轮询每个队列来判断哪一个有数据。

相比使用单个结构体队列，队列集合的设计不够简洁也更低效。因此仅在设计约束使其
成为必要时才建议使用队列集合。

以下小节描述如何使用队列集合：

- 创建队列集合。

- 向集合添加队列。

  也可以将信号量添加到队列集合。信号量将在本书后续章节介绍。

- 从队列集合读取，以确定集合中哪些队列包含数据。

  当集合内队列接收到数据时，该队列的句柄会被发送到队列集合，并在任务调用读取
  队列集合的函数时返回。因此，如果从队列集合返回了队列句柄，则该句柄指向的队列
  必定包含数据，任务可直接从该队列读取。

  > *注意：如果某队列属于队列集合，那么每次其句柄从队列集合返回时都必须读取该队列，
  > 且在其句柄从队列集合返回之前不得读取该队列。*

要启用队列集合功能，需要在 FreeRTOSConfig.h 中将 `configUSE_QUEUE_SETS` 设为 1。


### 5.6.2 xQueueCreateSet() API 函数

队列集合必须在使用前显式创建。在编写本书时尚无 `xQueueCreateSetStatic()` 实现。
不过队列集合本身也是队列，因此可以通过精心构造的 `xQueueCreateStatic()` 调用
使用预分配内存来创建集合。

队列集合通过 `QueueSetHandle_t` 句柄引用。`xQueueCreateSet()` 创建队列集合并
返回引用该集合的 `QueueSetHandle_t`。

<a name="list5.21" title="清单 5.21 xQueueCreateSet() API 函数原型"></a>

```c
QueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength);
```
***清单 5.21*** *xQueueCreateSet() API 函数原型*


**xQueueCreateSet() 参数与返回值**

- `uxEventQueueLength`

  当队列集合中的队列接收到数据时，该队列句柄会发送到队列集合。
  `uxEventQueueLength` 定义正在创建的队列集合任意时刻可保存的最大队列句柄数量。

  只有集合内队列接收到数据时，队列句柄才会发送到队列集合。若队列已满，则无法
  接收更多数据，因此当集合内所有队列均满时，不会有队列句柄发送到集合。故队列集合
  需要容纳的最大句柄数量等于集合内所有队列长度之和。

  例如，集合内有三个空队列，每个队列长度为 5，则这些队列合计最多可接收 15 个
  数据项。在该示例中 `uxEventQueueLength` 必须设为 15 以确保集合能接收所有句柄。

  信号量也可加入队列集合。信号量将在后续章节介绍。计算 `uxEventQueueLength` 时，
  二值信号量长度为 1，互斥量长度为 1，计数信号量长度为其最大计数值。

  再如，如果队列集合包含一个长度为 3 的队列和一个二值信号量（长度为 1），
  则 `uxEventQueueLength` 必须设为 4（3 + 1）。

- 返回值

  若返回 NULL，表示堆内存不足，FreeRTOS 无法分配队列集合数据结构与存储区。
  第 3 章提供了 FreeRTOS 堆的更多信息。

  若返回非 NULL，则队列集合创建成功，返回值即为创建集合的句柄。


### 5.6.3 xQueueAddToSet() API 函数

`xQueueAddToSet()` 将队列或信号量加入队列集合。信号量将在本书后续章节介绍。

<a name="list5.22" title="清单 5.22 xQueueAddToSet() API 函数原型"></a>

```c
BaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore,
									QueueSetHandle_t xQueueSet );
```
***清单 5.22*** *xQueueAddToSet() API 函数原型*

**xQueueAddToSet() 参数与返回值**

- `xQueueOrSemaphore`

  要添加到队列集合的队列或信号量句柄。

  队列句柄与信号量句柄均可转换为 `QueueSetMemberHandle_t` 类型。

- `xQueueSet`

  要添加到的队列集合句柄。

- 返回值

  有两种可能返回值：

  1. `pdPASS`

		表示成功添加到队列集合。

  1. `pdFAIL`

	  表示队列或信号量无法加入队列集合。

  队列与二值信号量只有在为空时才能加入集合。计数信号量只有在计数为 0 时才能加入集合。
  队列与信号量同一时刻只能属于一个集合。


### 5.6.4 xQueueSelectFromSet() API 函数

`xQueueSelectFromSet()` 从队列集合读取一个队列句柄。

当集合成员（队列或信号量）接收到数据时，其句柄会被发送到队列集合，并在任务调用
`xQueueSelectFromSet()` 时返回。如果调用 `xQueueSelectFromSet()` 返回了句柄，
则该句柄指向的队列或信号量一定包含数据，调用任务必须直接从该队列或信号量读取。

> *注意：除非某队列或信号量的句柄已通过 `xQueueSelectFromSet()` 返回，否则不要
> 从该队列或信号量读取数据。并且每次 `xQueueSelectFromSet()` 返回队列/信号量句柄时，
> 只读取一个数据项。*

<a name="list5.23" title="清单 5.23 xQueueSelectFromSet() API 函数原型"></a>

```c
QueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet,
														  const TickType_t xTicksToWait );
```
***清单 5.23*** *xQueueSelectFromSet() API 函数原型*

**xQueueSelectFromSet() 参数与返回值**

- `xQueueSet`

  要读取队列/信号量句柄的队列集合句柄。该句柄由 `xQueueCreateSet()` 创建时返回。

- `xTicksToWait`

  当集合中所有队列与信号量为空时，调用任务在 *Blocked* 状态中等待集合句柄的最长时间。

  若 `xTicksToWait` 为 0，且集合中所有队列与信号量为空，则 `xQueueSelectFromSet()`
  立即返回。

  阻塞时间以 tick 周期表示，绝对时间取决于 tick 频率。可使用 `pdMS_TO_TICKS()`
  将毫秒转换为 tick。

  将 `xTicksToWait` 设为 `portMAX_DELAY` 会使任务无限期等待（不超时），前提是
  FreeRTOSConfig.h 中 `INCLUDE_vTaskSuspend` 设为 1。

- 返回值

  若返回非 NULL，则返回值为已包含数据的队列或信号量句柄。若指定了阻塞时间
  （`xTicksToWait` 非 0），调用任务可能进入 *Blocked* 状态等待集合中的队列或信号量
  有数据，但在超时前成功从集合读取到句柄。返回句柄类型为 `QueueSetMemberHandle_t`，
  可转换为 `QueueHandle_t` 或 `SemaphoreHandle_t`。

  若返回 NULL，则未能读取到句柄。若指定了阻塞时间（`xTicksToWait` 非 0），
  调用任务已进入 *Blocked* 状态等待集合中的队列或信号量收到数据，但在超时前未发生。


<a name="example5.3" title="示例 5.3 使用队列集合"></a>
---
***示例 5.3*** *使用队列集合</i></h3>

---

该示例创建两个发送任务与一个接收任务。发送任务通过两个独立队列向接收任务发送数据，
每个任务对应一个队列。两个队列加入同一队列集合，接收任务通过读取队列集合来确定
哪个队列包含数据。

任务、队列与队列集合均在 `main()` 中创建——实现见清单 5.24。

<a name="list5.24" title="清单 5.24 示例 5.3 中 main() 的实现"></a>

```c
/* Declare two variables of type QueueHandle_t. Both queues are added
	to the same queue set. */
static QueueHandle_t xQueue1 = NULL, xQueue2 = NULL;

/* Declare a variable of type QueueSetHandle_t. This is the queue set
	to which the two queues are added. */
static QueueSetHandle_t xQueueSet = NULL;

int main( void )
{
	 /* Create the two queues, both of which send character pointers. The 
		 priority of the receiving task is above the priority of the sending 
		 tasks, so the queues will never have more than one item in them at 
		 any one time*/
	 xQueue1 = xQueueCreate( 1, sizeof( char * ) );
	 xQueue2 = xQueueCreate( 1, sizeof( char * ) );

	 /* Create the queue set. Two queues will be added to the set, each of
		 which can contain 1 item, so the maximum number of queue handles the 
		 queue set will ever have to hold at one time is 2 (2 queues multiplied 
		 by 1 item per queue). */
	 xQueueSet = xQueueCreateSet( 1 * 2 );

	 /* Add the two queues to the set. */
	 xQueueAddToSet( xQueue1, xQueueSet );
	 xQueueAddToSet( xQueue2, xQueueSet );

	 /* Create the tasks that send to the queues. */
	 xTaskCreate( vSenderTask1, "Sender1", 1000, NULL, 1, NULL );
	 xTaskCreate( vSenderTask2, "Sender2", 1000, NULL, 1, NULL );

	 /* Create the task that reads from the queue set to determine which of
		 the two queues contain data. */
	 xTaskCreate( vReceiverTask, "Receiver", 1000, NULL, 2, NULL );

	 /* Start the scheduler so the created tasks start executing. */
	 vTaskStartScheduler();

	 /* As normal, vTaskStartScheduler() should not return, so the following
		 lines will never execute. */
	 for( ;; );
	 return 0;
}
```
***清单 5.24*** *示例 5.3 中 main() 的实现*

第一个发送任务使用 `xQueue1` 每 100 毫秒向接收任务发送字符指针；第二个发送任务
使用 `xQueue2` 每 200 毫秒发送字符指针。字符指针指向标识发送任务的字符串。
清单 5.25 给出两个任务的实现。

<a name="list5.25" title="清单 5.25 示例 5.3 中的发送任务"></a>

```c
void vSenderTask1( void *pvParameters )
{
	 const TickType_t xBlockTime = pdMS_TO_TICKS( 100 );
	 const char * const pcMessage = "Message from vSenderTask1\r\n";

	 /* As per most tasks, this task is implemented within an infinite loop. */

	 for( ;; )
	 {

		  /* Block for 100ms. */
		  vTaskDelay( xBlockTime );

		  /* Send this task's string to xQueue1. It is not necessary to use a
			  block time, even though the queue can only hold one item. This is 
			  because the priority of the task that reads from the queue is 
			  higher than the priority of this task; as soon as this task writes 
			  to the queue it will be pre-empted by the task that reads from the 
			  queue, so the queue will already be empty again by the time the 
			  call to xQueueSend() returns. The block time is set to 0. */
		  xQueueSend( xQueue1, &pcMessage, 0 );
	 }
}

/*-----------------------------------------------------------*/

void vSenderTask2( void *pvParameters )
{
	 const TickType_t xBlockTime = pdMS_TO_TICKS( 200 );
	 const char * const pcMessage = "Message from vSenderTask2\r\n";

	 /* As per most tasks, this task is implemented within an infinite loop. */
	 for( ;; )
	 {
		  /* Block for 200ms. */
		  vTaskDelay( xBlockTime );

		  /* Send this task's string to xQueue2. It is not necessary to use a
			  block time, even though the queue can only hold one item. This is 
			  because the priority of the task that reads from the queue is 
			  higher than the priority of this task; as soon as this task writes 
			  to the queue it will be pre-empted by the task that reads from the 
			  queue, so the queue will already be empty again by the time the 
			  call to xQueueSend() returns. The block time is set to 0. */
		  xQueueSend( xQueue2, &pcMessage, 0 );
	 }
}
```
***清单 5.25*** *示例 5.3 中的发送任务*


发送任务写入的队列同属一个队列集合。每次任务向其中一个队列发送数据，该队列句柄
都会发送到队列集合。接收任务调用 `xQueueSelectFromSet()` 从集合读取队列句柄。
接收任务获得句柄后可确定该句柄所指队列包含数据，并直接从该队列读取数据。
读取到的数据是指向字符串的指针，接收任务将其打印出来。

如果 `xQueueSelectFromSet()` 超时，会返回 NULL。在示例 5.3 中，
`xQueueSelectFromSet()` 使用无限阻塞，因此不会超时，只会返回有效句柄。因此接收
任务无需在使用返回值前检查是否为 NULL。

`xQueueSelectFromSet()` 仅在句柄所指队列包含数据时返回句柄，因此从队列读取时
无需指定阻塞时间。

清单 5.26 给出接收任务的实现。

<a name="list5.26" title="清单 5.26 示例 5.3 中的接收任务"></a>

```c
void vReceiverTask( void *pvParameters )
{
	 QueueHandle_t xQueueThatContainsData;
	 char *pcReceivedString;

	 /* As per most tasks, this task is implemented within an infinite loop. */
	 for( ;; )
	 {
		  /* Block on the queue set to wait for one of the queues in the set to
			  contain data. Cast the QueueSetMemberHandle_t value returned from
			  xQueueSelectFromSet() to a QueueHandle_t, as it is known all the 
			  members of the set are queues (the queue set does not contain any 
			  semaphores). */
		  xQueueThatContainsData = ( QueueHandle_t ) xQueueSelectFromSet(
																	  xQueueSet, portMAX_DELAY );

		  /* An indefinite block time was used when reading from the queue set,
			  so xQueueSelectFromSet() will not have returned unless one of the 
			  queues in the set contained data, and xQueueThatContainsData cannot
			  be NULL. Read from the queue. It is not necessary to specify a 
			  block time because it is known the queue contains data. The block 
			  time is set to 0. */
		  xQueueReceive( xQueueThatContainsData, &pcReceivedString, 0 );

		  /* Print the string received from the queue. */
		  vPrintString( pcReceivedString );
	 }
}
```
***清单 5.26*** *示例 5.3 中的接收任务*

图 5.7 显示示例 5.3 的输出。可见接收任务会从两个发送任务接收字符串。
`vSenderTask1()` 的阻塞时间是 `vSenderTask2()` 的一半，因此 `vSenderTask1()`
发送的字符串打印频率约为 `vSenderTask2()` 的两倍。

<a name="fig5.7" title="图 5.7 执行示例 5.3 的输出"></a>

* * *
![](media/image37.jpg)   
***图 5.7*** *执行示例 5.3 的输出*
* * *


### 5.6.5 更现实的队列集合用例

示例 5.3 展示了非常简单的用例：队列集合只包含队列，且两个队列都发送字符指针。
真实应用中，队列集合可能同时包含队列与信号量，且队列可能保存不同数据类型。
在这种情况下，需要先检查 `xQueueSelectFromSet()` 的返回值再使用它。
清单 5.27 展示了当集合包含以下成员时如何使用返回值：

- 二值信号量。
- 接收字符指针的队列。
- 接收 `uint32_t` 的队列。

清单 5.27 假定队列与信号量已经创建并加入队列集合。

<a name="list5.27" title="清单 5.27 使用包含队列与信号量的队列集合"></a>

```c
/* The handle of the queue from which character pointers are received. */
QueueHandle_t xCharPointerQueue;

/* The handle of the queue from which uint32_t values are received. */
QueueHandle_t xUint32tQueue;

/* The handle of the binary semaphore. */
SemaphoreHandle_t xBinarySemaphore;

/* The queue set to which the two queues and the binary semaphore belong. */
QueueSetHandle_t xQueueSet;

void vAMoreRealisticReceiverTask( void *pvParameters )
{
	 QueueSetMemberHandle_t xHandle;
	 char *pcReceivedString;
	 uint32_t ulRecievedValue;
	 const TickType_t xDelay100ms = pdMS_TO_TICKS( 100 );

	 for( ;; )
	 {
		  /* Block on the queue set for a maximum of 100ms to wait for one of the
			  members of the set to contain data. */
		  xHandle = xQueueSelectFromSet( xQueueSet, xDelay100ms );

		  /* Test the value returned from xQueueSelectFromSet(). If the returned
			  value is NULL then the call to xQueueSelectFromSet() timed out. If 
			  the returned value is not NULL then the returned value will be the 
			  handle of one of the set's members. The QueueSetMemberHandle_t 
			  value can be cast to either a QueueHandle_t or a SemaphoreHandle_t.
			  Whether an explicit cast is required depends on the compiler. */

		  if( xHandle == NULL )
		  {
				/* The call to xQueueSelectFromSet() timed out. */
		  }
		  else if( xHandle == ( QueueSetMemberHandle_t ) xCharPointerQueue )
		  {
				/* The call to xQueueSelectFromSet() returned the handle of the 
					queue that receives character pointers. Read from the queue. 
					The queue is known to contain data, so a block time of 0 is 
					used. */
				xQueueReceive( xCharPointerQueue, &pcReceivedString, 0 );

				/* The received character pointer can be processed here... */
		  }
		  else if( xHandle == ( QueueSetMemberHandle_t ) xUint32tQueue )
		  {
				/* The call to xQueueSelectFromSet() returned the handle of the 
					queue that receives uint32_t types. Read from the queue. The 
					queue is known to contain data, so a block time of 0 is used. */
				xQueueReceive(xUint32tQueue, &ulRecievedValue, 0 );

				/* The received value can be processed here... */
		  }
		  else if( xHandle == ( QueueSetMemberHandle_t ) xBinarySemaphore )
		  {
				/* The call to xQueueSelectFromSet() returned the handle of the 
					binary semaphore. Take the semaphore now. The semaphore is 
					known to be available so a block time of 0 is used. */
				xSemaphoreTake( xBinarySemaphore, 0 );

				/* Whatever processing is necessary when the semaphore is taken 
					can be performed here... */
		  }
	 }
}
```
***清单 5.27*** *使用包含队列与信号量的队列集合*


## 5.7 使用队列实现邮箱

嵌入式领域对术语并无统一共识，“邮箱（mailbox）”在不同 RTOS 中含义不同。本书
将邮箱定义为长度为 1 的队列。称其为邮箱是因为应用使用方式不同，而非与普通队列
存在功能差异：

- 队列用于从一个任务发送数据给另一个任务，或从中断服务例程发送给任务。发送者
  将数据项放入队列，接收者从队列移除数据项。数据通过队列从发送者传递给接收者。

- 邮箱用于保存可被任意任务或中断服务例程读取的数据。数据不会“通过”邮箱，而是
  保留在邮箱中直到被覆盖。发送者覆盖邮箱中的值；接收者读取邮箱中的值，但不会
  将其移除。

本章描述两个队列 API 函数，使队列可用作邮箱。

清单 5.28 展示用于邮箱的队列创建方式。

<a name="list5.28" title="清单 5.28 创建用于邮箱的队列"></a>

```c
/* A mailbox can hold a fixed size data item. The size of the data item is set
	when the mailbox (queue) is created. In this example the mailbox is created 
	to hold an Example_t structure. Example_t includes a time stamp to allow the
	data held in the mailbox to note the time at which the mailbox was last 
	updated. The time stamp used in this example is for demonstration purposes 
	only - a mailbox can hold any data the application writer wants, and the 
	data does not need to include a time stamp. */
typedef struct xExampleStructure
{
	 TickType_t xTimeStamp;
	 uint32_t ulValue;
} Example_t;

/* A mailbox is a queue, so its handle is stored in a variable of type
	QueueHandle_t. */
QueueHandle_t xMailbox;

void vAFunction( void )
{
	 /* Create the queue that is going to be used as a mailbox. The queue has 
		 a length of 1 to allow it to be used with the xQueueOverwrite() API 
		 function, which is described below. */
	 xMailbox = xQueueCreate( 1, sizeof( Example_t ) );
}
```
***清单 5.28*** *创建用于邮箱的队列*


### 5.7.1 xQueueOverwrite() API 函数

与 `xQueueSendToBack()` 类似，`xQueueOverwrite()` 用于向队列发送数据。不同之处在于，
当队列已满时，`xQueueOverwrite()` 会覆盖队列中已有的数据。

`xQueueOverwrite()` 只能用于长度为 1 的队列。覆盖模式总是写入队列头部，并更新
队列头部指针，但不会更新等待消息计数。如果定义了 `configASSERT`，当队列长度
大于 1 时会触发断言。

> *注意：切勿在中断服务例程中调用 `xQueueOverwrite()`。应使用其中断安全版本
> `xQueueOverwriteFromISR()`。*

<a name="list5.29" title="清单 5.29 xQueueOverwrite() API 函数原型"></a>

```c
BaseType_t xQueueOverwrite( QueueHandle_t xQueue, const void * pvItemToQueue );
```
***清单 5.29*** *xQueueOverwrite() API 函数原型*

**xQueueOverwrite() 参数与返回值**

- `xQueue`

  要写入数据的队列句柄。该句柄由 `xQueueCreate()` 或 `xQueueCreateStatic()` 创建时返回。

- `pvItemToQueue`

	指向要拷贝进队列的数据。

	队列创建时已设置每个数据项的大小，因此会从 `pvItemToQueue` 向队列存储区拷贝相应字节。

- 返回值

  `xQueueOverwrite()` 即使队列满也会写入，因此唯一可能的返回值为 `pdPASS`。

清单 5.30 展示如何使用 `xQueueOverwrite()` 向清单 5.28 创建的邮箱（队列）写入。

<a name="list5.30" title="清单 5.30 使用 xQueueOverwrite() API 函数"></a>

```c
void vUpdateMailbox( uint32_t ulNewValue )
{
	 /* Example_t was defined in Listing 5.28. */
	 Example_t xData;

	 /* Write the new data into the Example_t structure.*/
	 xData.ulValue = ulNewValue;

	 /* Use the RTOS tick count as the time stamp stored in the Example_t
		 structure. */
	 xData.xTimeStamp = xTaskGetTickCount();

	 /* Send the structure to the mailbox - overwriting any data that is 
		 already in the mailbox. */
	 xQueueOverwrite( xMailbox, &xData );
}
```
***清单 5.30*** *使用 xQueueOverwrite() API 函数*


### 5.7.2 xQueuePeek() API 函数

`xQueuePeek()` 从队列接收（读取）一个数据项，但**不会**将其从队列中移除。
`xQueuePeek()` 从队列头部接收数据，但不会修改队列存储的数据或其顺序。

> *注意：切勿在中断服务例程中调用 `xQueuePeek()`。应使用其中断安全版本
> `xQueuePeekFromISR()`。*

*`xQueuePeek()` 的参数与返回值与 `xQueueReceive()` 相同。*

<a name="list5.31" title="清单 5.31 xQueuePeek() API 函数原型"></a>

```c
BaseType_t xQueuePeek( QueueHandle_t xQueue,
							  void * const pvBuffer,
							  TickType_t xTicksToWait );
```
***清单 5.31*** *xQueuePeek() API 函数原型*


清单 5.32 展示如何使用 `xQueuePeek()` 读取清单 5.30 写入邮箱（队列）的数据。

<a name="list5.32" title="清单 5.32 使用 xQueuePeek() API 函数"></a>

```c
BaseType_t vReadMailbox( Example_t *pxData )
{
	 TickType_t xPreviousTimeStamp;
	 BaseType_t xDataUpdated;

	 /* This function updates an Example_t structure with the latest value
		 received from the mailbox. Record the time stamp already contained in 
		 *pxData before it gets overwritten by the new data. */
	 xPreviousTimeStamp = pxData->xTimeStamp;

	 /* Update the Example_t structure pointed to by pxData with the data
		 contained in the mailbox. If xQueueReceive() was used here then the 
		 mailbox would be left empty, and the data could not then be read by 
		 any other tasks. Using xQueuePeek() instead of xQueueReceive() ensures 
		 the data remains in the mailbox.

		 A block time is specified, so the calling task will be placed in the
		 Blocked state to wait for the mailbox to contain data should the mailbox
		 be empty. An infinite block time is used, so it is not necessary to 
		 check the value returned from xQueuePeek(), as xQueuePeek() will only 
		 return when data is available. */
	 xQueuePeek( xMailbox, pxData, portMAX_DELAY );

	 /* Return pdTRUE if the value read from the mailbox has been updated since
		 this function was last called. Otherwise return pdFALSE. */
	 if( pxData->xTimeStamp > xPreviousTimeStamp )
	 {
		  xDataUpdated = pdTRUE;
	 }
	 else
	 {
		  xDataUpdated = pdFALSE;
	 }

	 return xDataUpdated;
}
```
***清单 5.32*** *使用 xQueuePeek() API 函数*

