# 12 开发者支持

## 12.1 简介

本章介绍一组用于最大化生产力的特性，目标包括：

- 提供对应用行为的洞察。
- 发现优化机会。
- 在错误发生时立即捕获。


## 12.2 configASSERT()

在 C 语言中，宏 `assert()` 用于验证程序所做的 *断言*（假设）。断言以 C 表达式形式
给出，若表达式计算为假（0），则断言失败。例如清单 12.1 验证指针 `pxMyPointer`
不为 NULL。


<a name="list12.1" title="Listing 12.1 Using the standard C assert() macro to check pxMyPointer is not NULL"></a>

```c
/* 测试断言：pxMyPointer 不为 NULL */
assert( pxMyPointer != NULL );
```
***清单 12.1*** *使用标准 C assert() 宏检查 pxMyPointer 非 NULL*

断言失败时应采取的动作由应用编写者通过实现 `assert()` 宏来指定。

FreeRTOS 源码不调用 `assert()`，因为并非所有用于编译 FreeRTOS 的编译器都提供它。
取而代之，FreeRTOS 源码中大量使用 `configASSERT()` 宏。应用编写者可在
`FreeRTOSConfig.h` 中定义 `configASSERT()`，其行为与标准 C `assert()` 完全一致。

断言失败必须视为致命错误。不要尝试在断言失败行之后继续执行。

> *使用 `configASSERT()` 可以立即捕获并定位最常见的错误来源，从而提升效率。
> 强烈建议在开发或调试 FreeRTOS 应用时定义 `configASSERT()`。*

定义 `configASSERT()` 有助于运行时调试，但也会增大代码体积并降低执行速度。
若未提供 `configASSERT()` 定义，则使用默认空定义，所有 `configASSERT()` 调用将被
C 预处理器完全移除。


### 12.2.1 configASSERT() 示例定义

清单 12.2 中的 `configASSERT()` 定义适用于在调试器控制下运行应用。它会在断言失败
处停止执行，调试暂停时显示的即为断言失败行。


<a name="list12.2" title="Listing 12.2 A simple configASSERT() definition useful when executing under the control of a debugger"></a>

```c
/* 关闭中断以停止 tick 中断执行，然后在循环中停住，
	 使程序不会越过断言失败的行。
	 若硬件支持调试中断指令，可用该指令替代 for() 循环。 */

#define configASSERT( x ) if( ( x ) == 0 ) { taskDISABLE_INTERRUPTS(); for(;;); }
```
***清单 12.2*** *适用于调试器环境的简单 configASSERT() 定义*

清单 12.3 中的 `configASSERT()` 定义适用于非调试器环境。它会打印或记录断言失败的
源代码行。断言失败行通过标准 C `__FILE__` 宏获取源文件名，通过 `__LINE__` 宏获取
行号。


<a name="list12.3" title="Listing 12.3 A configASSERT() definition that records the source code line that failed an assertion"></a>

```c
/* 该函数必须定义在 C 源文件中，而不是 FreeRTOSConfig.h 头文件中。 */
void vAssertCalled( const char *pcFile, uint32_t ulLine )
{
		/* 在该函数中，pcFile 保存检测到错误的源文件名，ulLine 保存源文件中的行号。
			 在进入下面的无限循环之前，可打印或记录 pcFile 与 ulLine。 */
		RecordErrorInformationHere( pcFile, ulLine );

		/* 关闭中断以停止 tick 中断执行，然后在循环中停住，
			 使程序不会越过断言失败的行。 */
		taskDISABLE_INTERRUPTS();
		for( ;; );
}
/*-----------------------------------------------------------*/

/* 以下两行必须放在 FreeRTOSConfig.h 中。 */
extern void vAssertCalled( const char *pcFile, unsigned long ulLine );
#define configASSERT( x ) if( ( x ) == 0 ) vAssertCalled( __FILE__, __LINE__ )
```
***清单 12.3*** *记录断言失败源代码行的 configASSERT() 定义*


## 12.3 Tracealyzer for FreeRTOS

Tracealyzer for FreeRTOS 是由合作伙伴 Percepio 提供的运行时诊断与优化工具。

Tracealyzer for FreeRTOS 捕获关键的动态行为信息，并以相互关联的图形视图展示。
该工具还能显示多个同步视图。

捕获的信息对于分析、排错或优化 FreeRTOS 应用十分宝贵。

Tracealyzer for FreeRTOS 可与传统调试器并行使用，通过更高层次、基于时间的视角
补充调试器的视图。


<a name="fig12.1" title="Figure 12.1 FreeRTOS+Trace includes more than 20 interconnected views"></a>
<a name="fig12.2" title="Figure 12.2 FreeRTOS+Trace main trace view - one of more than 20 interconnected trace views"></a>
<a name="fig12.3" title="Figure 12.3 FreeRTOS+Trace CPU load view - one of more than 20 interconnected trace views"></a>
<a name="fig12.4" title="Figure 12.4 FreeRTOS+Trace response time view - one of more than 20 interconnected trace views"></a>
<a name="fig12.5" title="Figure 12.5 FreeRTOS+Trace user event plot view - one of more than 20 interconnected trace views"></a>
<a name="fig12.6" title="Figure 12.6 FreeRTOS+Trace kernel object history view - one of more than 20 interconnected trace views"></a>

* * *
![](media/image82.png)   
***图 12.1*** *FreeRTOS+Trace 包含 20 多个互相关联的视图*

![](media/image83.png)   
***图 12.2*** *FreeRTOS+Trace 主跟踪视图（20 多个关联视图之一）*

![](media/image84.png)   
***图 12.3*** *FreeRTOS+Trace CPU 负载视图（20 多个关联视图之一）*

![](media/image85.png)   
***图 12.4*** *FreeRTOS+Trace 响应时间视图（20 多个关联视图之一）*

![](media/image86.png)   
***图 12.5*** *FreeRTOS+Trace 用户事件图视图（20 多个关联视图之一）*

![](media/image87.png)   
***图 12.6*** *FreeRTOS+Trace 内核对象历史视图（20 多个关联视图之一）*
* * *


## 12.4 与调试相关的钩子（回调）函数

### 12.4.1 Malloc 失败钩子

Malloc 失败钩子（或回调）已在第 3 章“堆内存管理”中介绍。

定义 malloc 失败钩子可在创建任务、队列、信号量或事件组失败时，立即通知开发者。

### 12.4.2 栈溢出钩子

栈溢出钩子详见 13.3 节“栈溢出”。

定义栈溢出钩子可在任务栈使用量超过分配栈空间时通知开发者。


## 12.5 查看运行时与任务状态信息

### 12.5.1 任务运行时间统计

任务运行时间统计提供各任务获得的处理时间信息。任务的*运行时间*是从应用启动以来，
任务处于 *Running* 状态的总时间。

运行时间统计旨在开发阶段用于性能分析与调试。其提供的信息仅在作为运行时间统计时钟
的计数器溢出前有效。收集运行时间统计会增加任务上下文切换时间。

要获取二进制形式的运行时间统计信息，调用 `uxTaskGetSystemState()` API。
要获取可读的 ASCII 表格，调用 `vTaskGetRunTimeStatistics()` 辅助函数。


### 12.5.2 运行时间统计时钟

运行时间统计需要测量 tick 周期的分数，因此不使用 RTOS tick 计数作为统计时钟，
而是由应用代码提供统计时钟。建议统计时钟频率为 tick 中断频率的 10 到 100 倍。
统计时钟越快，统计越准确，但溢出越快。

理想情况下，可使用自由运行的 32 位外设定时器/计数器，其值读取不需额外处理开销。
若硬件与时钟频率无法满足该方法，可使用替代但效率较低的方案：

- 配置外设生成所需频率的周期中断，并使用中断次数作为运行时间统计时钟。

	若该周期中断仅用于统计时钟，这种方法效率很低；但若应用已有合适频率的周期中断，
	则在现有 ISR 中加入计数简单且高效。

- 使用自由运行的 16 位定时器的当前值作为 32 位值的低 16 位，定时器溢出次数作为
	高 16 位，组合成 32 位值。

通过适当且略复杂的方式，可将 RTOS tick 计数与 ARM Cortex-M SysTick 定时器当前值
结合，生成运行时间统计时钟。FreeRTOS 下载包中的一些示例工程展示了实现方法。


### 12.5.3 配置应用收集运行时间统计

以下为收集任务运行时间统计所需宏。最初这些宏计划放在移植层，因此以 `port` 为前缀，
但实践证明放在 `FreeRTOSConfig.h` 更合适。

**用于收集运行时间统计的宏**

- `configGENERATE_RUN_TIME_STATS`

	必须在 FreeRTOSConfig.h 中设为 1。设为 1 后，调度器会在合适时机调用本节所述
	其他宏。

- `portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()`

	必须提供，用于初始化运行时间统计时钟的外设。

- `portGET_RUN_TIME_COUNTER_VALUE()` 或 `portALT_GET_RUN_TIME_COUNTER_VALUE(Time)`

	必须提供其中之一，以返回当前运行时间统计时钟值。该值表示应用启动以来的总运行时间，
	单位为运行时间统计时钟单位。

	若使用第一个宏，需定义为可求值为当前时钟值；若使用第二个宏，需定义为将其 `Time`
	参数设为当前时钟值。


### 12.5.4 uxTaskGetSystemState() API 函数

`uxTaskGetSystemState()` 提供 FreeRTOS 调度器控制下各任务状态信息的快照。
信息以 `TaskStatus_t` 结构体数组形式返回，每个任务对应数组中的一个索引。
`TaskStatus_t` 见清单 12.5，下文对其成员进行说明。


<a name="list12.4" title="Listing 12.4 The uxTaskGetSystemState() API function prototype"></a>

```c
UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray,
																	const UBaseType_t uxArraySize,
																	configRUN_TIME_COUNTER_TYPE * const pulTotalRunTime );
```
***清单 12.4*** *uxTaskGetSystemState() API 函数原型*

> 注意：`configRUN_TIME_COUNTER_TYPE` 默认为 `uint32_t`（向后兼容），
> 若 `uint32_t` 不够用，可在 FreeRTOSConfig.h 中覆盖定义。


**uxTaskGetSystemState() 参数与返回值**

- `pxTaskStatusArray`

	指向 `TaskStatus_t` 结构体数组的指针。

	数组必须至少包含每个任务一个 `TaskStatus_t` 结构体。
	任务数量可通过 `uxTaskGetNumberOfTasks()` 获取。

	`TaskStatus_t` 结构体见清单 12.5，其成员见下文列表。

- `uxArraySize`

	`pxTaskStatusArray` 指向数组的大小，按数组索引数量（结构体数量）指定，而非字节数。

- `pulTotalRunTime`

	若 `FreeRTOSConfig.h` 中 `configGENERATE_RUN_TIME_STATS` 设为 1，
	则 `uxTaskGetSystemState()` 会将 `*pulTotalRunTime` 设为应用启动以来的
	总运行时间（由应用提供的运行时间统计时钟定义）。

	`pulTotalRunTime` 可选，若不需要总运行时间可设为 NULL。

- 返回值

	返回被 `uxTaskGetSystemState()` 填充的 `TaskStatus_t` 结构体数量。

	返回值应等于 `uxTaskGetNumberOfTasks()` 的返回值；若 `uxArraySize` 太小则返回 0。


<a name="list12.5" title="Listing 12.5 The TaskStatus_t structure"></a>

```c
typedef struct xTASK_STATUS
{
		TaskHandle_t xHandle;
		const char *pcTaskName;
		UBaseType_t xTaskNumber;
		eTaskState eCurrentState;
		UBaseType_t uxCurrentPriority;
		UBaseType_t uxBasePriority;
		configRUN_TIME_COUNTER_TYPE ulRunTimeCounter;
		StackType_t * pxStackBase;
		#if ( ( portSTACK_GROWTH > 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )
				StackType_t * pxTopOfStack;
				StackType_t * pxEndOfStack;
		#endif
		uint16_t usStackHighWaterMark;
		#if ( ( configUSE_CORE_AFFINITY == 1 ) && ( configNUMBER_OF_CORES > 1 ) )
				UBaseType_t uxCoreAffinityMask;
		#endif
} TaskStatus_t;
```
***清单 12.5*** *TaskStatus_t 结构体*

**TaskStatus_t 结构体成员**

- `xHandle`

	结构体信息对应任务的句柄。

- `pcTaskName`

	任务的人类可读名称。

- `xTaskNumber`

	每个任务都有唯一的 `xTaskNumber`。

	若应用在运行时创建与删除任务，可能出现新任务与已删除任务句柄相同的情况。
	`xTaskNumber` 用于帮助应用代码和内核感知调试器区分有效任务与已删除任务。

- `eCurrentState`

	任务状态枚举，可能取值：
  
	- `eRunning`
	- `eReady`
	- `eBlocked`
	- `eSuspended`
	- `eDeleted`

	任务仅会在短时间内显示为 `eDeleted`：从 `vTaskDelete()` 删除任务开始，
	到空闲任务释放其内部数据结构与栈内存之间的时间段。之后该任务不再存在，
	使用其句柄将无效。

- `uxCurrentPriority`

	调用 `uxTaskGetSystemState()` 时任务的运行优先级。`uxCurrentPriority` 只有在
	任务因优先级继承机制而临时提升时，才可能高于应用设定的优先级。
	优先级继承见 [8.3 互斥量（及二值信号量）](ch08-资源管理.md#83)。

- `uxBasePriority`

	应用为任务设置的优先级。仅当 FreeRTOSConfig.h 中 `configUSE_MUTEXES` 设为 1 时有效。

- `ulRunTimeCounter`

	自任务创建以来任务使用的总运行时间，绝对时间由应用提供的运行时间统计时钟定义。
	仅当 `configGENERATE_RUN_TIME_STATS` 设为 1 时有效。
  
- `pxStackBase`

	 指向分配给该任务栈区域的基地址。

- `pxTopOfStack`

	 指向该任务栈区域当前栈顶地址。仅当栈向上增长（`portSTACK_GROWTH` > 0）
	 或 `configRECORD_STACK_HIGH_ADDRESS` 设为 1 时有效。

- `pxEndOfStack`

	 指向该任务栈区域的结束地址。仅当栈向上增长或 `configRECORD_STACK_HIGH_ADDRESS`
	 设为 1 时有效。

- `usStackHighWaterMark`

	任务栈高水位线，表示任务创建以来剩余的最小栈空间。该值越接近 0，越接近栈溢出。
	`usStackHighWaterMark` 以字节为单位。
  
- `uxCoreAffinityMask`

	 表示任务可运行的核的掩码。核编号范围为 0 到 `configNUMBER_OF_CORES - 1`。
	 例如可在核 0 与核 1 上运行的任务，其 `uxCoreAffinityMask` 为 0x03。
	 仅当 `configUSE_CORE_AFFINITY` 设为 1 且 `configNUMBER_OF_CORES` > 1 时有效。


### 12.5.5 vTaskListTasks() 辅助函数

`vTaskListTasks()` 提供与 `uxTaskGetSystemState()` 类似的任务状态信息，但以
可读 ASCII 表格形式输出，而非二进制数组。

`vTaskListTasks()` 处理器开销较大，会使调度器长时间挂起，因此建议仅用于调试，
而非生产实时系统。

当 FreeRTOSConfig.h 中 `configUSE_TRACE_FACILITY` 设为 1 且
`configUSE_STATS_FORMATTING_FUNCTIONS` 设为大于 0 时，`vTaskListTasks()` 可用。


<a name="list12.6" title="Listing 12.6 The vTaskListTasks() API function prototype"></a>

```c
void vTaskListTasks( char * pcWriteBuffer, size_t uxBufferLength );
```
***清单 12.6*** *vTaskListTasks() API 函数原型*

**vTaskListTasks() 参数**

- `pcWriteBuffer`

	指向字符缓冲区的指针，用于写入格式化的人类可读表格。
	该缓冲区应足够容纳生成的报告。每个任务约 40 字节通常足够。

- `uxBufferLength`

	`pcWriteBuffer` 的长度。

图 12.7 展示了 `vTaskListTasks()` 的输出示例。输出中：

- 每一行对应一个任务。

- 第一列为任务名。

- 第二列为任务状态，其中 'X' 为 Running，'R' 为 Ready，'B' 为 Blocked，
	'S' 为 Suspended，'D' 为 Deleted。任务仅在短时间内显示为 Deleted：
	从 `vTaskDelete()` 删除任务到空闲任务释放其内部数据结构与栈内存之间。
	之后任务不再存在，使用其句柄将无效。

- 第三列为任务优先级。

- 第四列为任务栈高水位线（见 `usStackHighWaterMark`）。

- 第五列为任务唯一编号（见 `xTaskNumber`）。


<a name="fig12.7" title="Figure 12.7 Example output generated by vTaskListTasks()"></a>

* * *
![](media/image88.png)   
***图 12.7*** *vTaskListTasks() 输出示例*
* * *

> 注意：
> `vTaskListTasks` 的旧版本为 `vTaskList`。`vTaskList` 假定 `pcWriteBuffer`
> 长度为 `configSTATS_BUFFER_MAX_LENGTH`。该函数仅为向后兼容而保留。
> 新应用建议使用 `vTaskListTasks` 并显式提供 `pcWriteBuffer` 长度。


<a name="list12.7" title="Listing 12.7 The vTaskList() API function prototype"></a>

```c
void vTaskList( signed char *pcWriteBuffer );
```
***清单 12.7*** *vTaskList() API 函数原型*

	**vTaskList() 参数**

	- `pcWriteBuffer`
    
		指向字符缓冲区的指针，用于写入格式化的人类可读表格。
		该缓冲区必须足够大，因为函数不进行边界检查。


### 12.5.6 vTaskGetRunTimeStatistics() 辅助函数

`vTaskGetRunTimeStatistics()` 将收集到的运行时间统计格式化为人类可读 ASCII 表格。

`vTaskGetRunTimeStatistics()` 处理器开销较大，会使调度器长时间挂起，建议仅用于调试，
而非生产实时系统。

当 `configGENERATE_RUN_TIME_STATS` 设为 1，`configUSE_STATS_FORMATTING_FUNCTIONS` 设为
大于 0，且 `configUSE_TRACE_FACILITY` 设为 1 时，`vTaskGetRunTimeStatistics()` 可用。


<a name="list12.8" title="Listing 12.8 The vTaskGetRunTimeStatistics() API function prototype"></a>

```c
void vTaskGetRunTimeStatistics( char * pcWriteBuffer, size_t uxBufferLength );
```
***清单 12.8*** *vTaskGetRunTimeStatistics() API 函数原型*

**vTaskGetRunTimeStatistics() 参数**

- `pcWriteBuffer`

	指向字符缓冲区的指针，用于写入格式化的人类可读表格。
	该缓冲区应足够容纳生成的报告。每个任务约 40 字节通常足够。

- `uxBufferLength` 

	`pcWriteBuffer` 的长度。

图 12.8 展示了 `vTaskGetRunTimeStatistics()` 的输出示例。输出中：

- 每一行对应一个任务。

- 第一列为任务名。

- 第二列为任务处于 *Running* 状态的绝对时间（见 `ulRunTimeCounter`）。

- 第三列为任务处于 *Running* 状态的时间占系统启动以来总时间的百分比。
	由于统计与计算使用整数并向下取整，显示百分比总和通常小于 100%。


<a name="fig12.8" title="Figure 12.8 Example output generated by vTaskGetRunTimeStatistics()"></a>

* * *
![](media/image89.png)   
***图 12.8*** *vTaskGetRunTimeStatistics() 输出示例*
* * *

> 注意：
> `vTaskGetRunTimeStatistics` 的旧版本为 `vTaskGetRunTimeStats`。
> `vTaskGetRunTimeStats` 假定 `pcWriteBuffer` 长度为
> `configSTATS_BUFFER_MAX_LENGTH`。该函数仅为向后兼容保留。
> 新应用建议使用 `vTaskGetRunTimeStatistics` 并显式提供 `pcWriteBuffer` 长度。


 <a name="list12.9" title="Listing 12.9 The vTaskGetRunTimeStats() API function prototype"></a>

 ```c
 void vTaskGetRunTimeStats( signed char *pcWriteBuffer );
 ```
 ***清单 12.9*** *vTaskGetRunTimeStats() API 函数原型*
 
	**vTaskGetRunTimeStats() 参数**

	- `pcWriteBuffer`

		指向字符缓冲区的指针，用于写入格式化的人类可读表格。
		该缓冲区必须足够大，因为函数不进行边界检查。


### 12.5.7 生成与显示运行时间统计：示例

本示例使用假设的 16 位定时器生成 32 位运行时间统计时钟。计数器被配置为在
16 位值达到最大时产生中断（溢出中断）。ISR 统计溢出次数。

32 位值由溢出次数作为高 16 位、当前 16 位计数值作为低 16 位组合而成。
ISR 伪代码见清单 12.10。


<a name="list12.10" title="Listing 12.10 16-bit timer overflow interrupt handler used to count timer overflows"></a>

```c
void TimerOverflowInterruptHandler( void )
{
		/* 仅统计中断次数。 */
		ulOverflowCount++;

		/* 清除中断。 */
		ClearTimerInterrupt();
}
```
***清单 12.10*** *用于统计定时器溢出的 16 位定时器溢出 ISR*

清单 12.11 展示了在 FreeRTOSConfig.h 中添加的宏，用于启用运行时间统计收集。


<a name="list12.11" title="Listing 12.11 Macros added to FreeRTOSConfig.h to enable the collection of run-time statistics"></a>

```c
/* 将 configGENERATE_RUN_TIME_STATS 设为 1 以启用运行时间统计收集。
	 设为 1 后，必须同时定义 portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() 以及
	 portGET_RUN_TIME_COUNTER_VALUE() 或 portALT_GET_RUN_TIME_COUNTER_VALUE(x)。 */
#define configGENERATE_RUN_TIME_STATS 1

/* portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() 定义为调用配置假设 16 位定时器的函数
	（函数实现未展示）。 */
void vSetupTimerForRunTimeStats( void );
#define portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()  vSetupTimerForRunTimeStats()

/* portALT_GET_RUN_TIME_COUNTER_VALUE() 定义为将其参数设为当前运行时间计数值。
	 返回的时间值为 32 位，由 16 位定时器溢出次数左移到 32 位数的高两字节，
	 再与当前 16 位计数值按位或组成。 */
#define portALT_GET_RUN_TIME_COUNTER_VALUE( ulCountValue )                  \
{                                                                           \
		extern volatile unsigned long ulOverflowCount;                          \
																																						\
		/* 断开计数器时钟连接，避免在使用其值时发生变化。 */                      \
		PauseTimer();                                                           \
																																						\
		/* 将溢出次数移入返回 32 位值的最高两个字节。 */                           \
		ulCountValue = ( ulOverflowCount << 16UL );                             \
																																						\
		/* 当前计数值用作返回 32 位值的最低两个字节。 */                           \
		ulCountValue |= ( unsigned long ) ReadTimerCount();                     \
																																						\
		/* 重新连接计数器时钟。 */                                              \
		ResumeTimer();                                                          \
}
```
***清单 12.11*** *在 FreeRTOSConfig.h 中启用运行时间统计的宏*

清单 12.12 的任务每 5 秒打印一次运行时间统计。


<a name="list12.12" title="Listing 12.12 The task that prints out the collected run-time statistics"></a>

```c
#define RUN_TIME_STATS_STRING_BUFFER_LENGTH       512

/* 为清晰起见，本代码清单省略了对 fflush() 的调用。 */
static void prvStatsTask( void *pvParameters )
{
		TickType_t xLastExecutionTime;

		/* 用于保存格式化运行时间统计文本的缓冲区需要很大，
			 因此声明为 static 以避免分配在任务栈上，这会使该函数不可重入。 */
		static signed char cStringBuffer[ RUN_TIME_STATS_STRING_BUFFER_LENGTH ];

		/* 该任务每 5 秒运行一次。 */
		const TickType_t xBlockPeriod = pdMS_TO_TICKS( 5000 );

		/* 将 xLastExecutionTime 初始化为当前时间。这是唯一需要显式写入该变量
			 的时刻。之后该变量会在 vTaskDelayUntil() 内部更新。 */
		xLastExecutionTime = xTaskGetTickCount();

		/* 与多数任务一样，该任务在无限循环中实现。 */
		for( ;; )
		{
				/* 等待直到该任务下一次运行的时间到达。 */
				xTaskDelayUntil( &xLastExecutionTime, xBlockPeriod );

				/* 从运行时间统计生成文本表格，必须能放入 cStringBuffer 数组。 */
				vTaskGetRunTimeStatistics( cStringBuffer, RUN_TIME_STATS_STRING_BUFFER_LENGTH );

				/* 打印运行时间统计表的列标题。 */
				printf( "\nTask\t\tAbs\t\t\t%%\n" );
				printf( "-------------------------------------------------------------\n" );

				/* 打印运行时间统计本身。数据表包含多行，因此调用 vPrintMultipleLines()
					 而不是直接调用 printf()。vPrintMultipleLines() 逐行调用 printf()，
					 以确保行缓冲按预期工作。 */ 
				vPrintMultipleLines( cStringBuffer );
		}
}
```
***清单 12.12*** *打印运行时间统计的任务*


## 12.6 Trace Hook 宏

Trace 宏被放置在 FreeRTOS 源码的关键位置。默认情况下这些宏为空定义，不生成代码，
也没有运行时开销。通过覆盖默认空定义，应用编写者可：

- 在不修改 FreeRTOS 源码的情况下插入用户代码。

- 以目标硬件可用方式输出详细的执行顺序信息。Trace 宏覆盖足够多的源码位置，
	可用于创建完整、详细的调度活动跟踪与性能日志。


### 12.6.1 可用 Trace Hook 宏

受篇幅限制，无法逐一详述所有宏。以下列出对应用编写者最有用的一部分。

以下描述中多次提到 `pxCurrentTCB`。`pxCurrentTCB` 是 FreeRTOS 私有变量，保存
*Running* 状态任务的句柄。该变量在 FreeRTOS/Source/tasks.c 中可被调用宏使用。

**常用 Trace Hook 宏示例**

- `traceTASK_INCREMENT_TICK(xTickCount)`

	在 tick 中断中、tick 计数递增前调用。参数 `xTickCount` 传入新的 tick 计数值。

- `traceTASK_SWITCHED_OUT()`

	在选择新任务运行前调用。此时 `pxCurrentTCB` 指向即将离开 *Running* 状态的任务。

- `traceTASK_SWITCHED_IN()`

	在任务被选中运行后调用。此时 `pxCurrentTCB` 指向即将进入 *Running* 状态的任务。

- `traceBLOCKING_ON_QUEUE_RECEIVE(pxQueue)`
  
	当前任务因尝试从空队列读取或“获取”空信号量/互斥量而进入 *Blocked* 状态前调用。
	`pxQueue` 传入目标队列或信号量句柄。

- `traceBLOCKING_ON_QUEUE_SEND(pxQueue)`
  
	当前任务因尝试向满队列写入而进入 *Blocked* 状态前调用。`pxQueue` 传入目标队列句柄。

- `traceQUEUE_SEND(pxQueue)`
  
	在 `xQueueSend()`、`xQueueSendToFront()`、`xQueueSendToBack()` 或信号量“释放”
	成功时调用。`pxQueue` 传入目标队列或信号量句柄。

- `traceQUEUE_SEND_FAILED(pxQueue)`

	在 `xQueueSend()`、`xQueueSendToFront()`、`xQueueSendToBack()` 或信号量“释放”
	失败时调用。若队列已满且在指定阻塞时间内仍为满，则发送/释放失败。
	`pxQueue` 传入目标队列或信号量句柄。

- `traceQUEUE_RECEIVE(pxQueue)`

	在 `xQueueReceive()` 或信号量“获取”成功时调用。
	`pxQueue` 传入目标队列或信号量句柄。

- `traceQUEUE_RECEIVE_FAILED(pxQueue)`

	在 `xQueueReceive()` 或信号量“获取”失败时调用。若队列/信号量为空且在指定阻塞时间内
	仍为空，则接收/获取失败。`pxQueue` 传入目标队列或信号量句柄。

- `traceQUEUE_SEND_FROM_ISR(pxQueue)`

	在 `xQueueSendFromISR()` 发送成功时调用。`pxQueue` 传入目标队列句柄。

- `traceQUEUE_SEND_FROM_ISR_FAILED(pxQueue)`

	在 `xQueueSendFromISR()` 发送失败时调用。若队列已满则发送失败。
	`pxQueue` 传入目标队列句柄。

- `traceQUEUE_RECEIVE_FROM_ISR(pxQueue)`

	在 `xQueueReceiveFromISR()` 接收成功时调用。`pxQueue` 传入目标队列句柄。

- `traceQUEUE_RECEIVE_FROM_ISR_FAILED(pxQueue)`

	在 `xQueueReceiveFromISR()` 因队列为空而接收失败时调用。
	`pxQueue` 传入目标队列句柄。

- `traceTASK_DELAY_UNTIL( xTimeToWake )`

	在 `xTaskDelayUntil()` 内、调用任务进入 *Blocked* 状态前调用。

- `traceTASK_DELAY()`

	在 `vTaskDelay()` 内、调用任务进入 *Blocked* 状态前调用。


### 12.6.2 定义 Trace Hook 宏

每个 Trace 宏都有默认空定义。可在 FreeRTOSConfig.h 中重新定义以覆盖默认实现。
若宏定义过长或复杂，可在新头文件中实现，并在 FreeRTOSConfig.h 中包含该头文件。

根据软件工程最佳实践，FreeRTOS 严格执行数据隐藏策略。Trace 宏允许将用户代码
插入 FreeRTOS 源码，因此 Trace 宏可见的数据类型与应用代码不同：

- 在 FreeRTOS/Source/tasks.c 内，任务句柄是指向任务数据结构（任务控制块，TCB）的指针；
	在 tasks.c 外，任务句柄为 `void *` 指针。

- 在 FreeRTOS/Source/queue.c 内，队列句柄是指向队列数据结构的指针；
	在 queue.c 外，队列句柄为 `void *` 指针。

> *若 Trace 宏直接访问通常为私有的 FreeRTOS 数据结构，必须非常谨慎，
> 因为这些私有结构可能在不同 FreeRTOS 版本之间发生变化。*


### 12.6.3 FreeRTOS 感知调试器插件

以下 IDE 提供了 FreeRTOS 感知插件（列表可能不完整）：

![](media/image90.png)

- Eclipse (StateViewer)

- Eclipse (ThreadSpy)

- IAR

- ARM DS-5

- Atollic TrueStudio

- Microchip MPLAB

- iSYSTEM WinIDEA

- STM32CubeIDE
