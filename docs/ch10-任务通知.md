# 10 任务通知

## 10.1 简介

FreeRTOS 应用通常由一系列相互独立的任务组成，任务之间通过通信协作提供系统功能。
任务通知是一种高效机制，使一个任务能够直接通知另一个任务。

### 10.1.1 通过中间对象通信

本书已介绍了多种任务间通信方式。到目前为止的方式都需要创建一个通信对象。
通信对象的例子包括队列、事件组及各种信号量。

使用通信对象时，事件与数据并非直接发送给接收任务或接收 ISR，而是发送到通信对象。
同样，任务与 ISR 也是从通信对象接收事件与数据，而非直接从发送事件或数据的任务或 ISR
接收。图 10.1 展示了这一点。


<a name="fig10.1" title="Figure 10.1 A communication object being used to send an event from one task to another"></a>

* * *
![](media/image76.png)    
***图 10.1*** *使用通信对象将事件从一个任务发送到另一个任务*
* * *

### 10.1.2 任务通知——直接到任务的通信

“任务通知”允许任务彼此交互，并与 ISR 同步，而无需单独的通信对象。
通过任务通知，任务或 ISR 可直接向接收任务发送事件。如图 10.2 所示。


<a name="fig10.2" title="Figure 10.2 A task notification used to send an event directly from one task to another"></a>

* * *
![](media/image77.png)    
***图 10.2*** *使用任务通知直接将事件从一个任务发送到另一个任务*
* * *

任务通知功能是可选的。要启用任务通知功能，请在 FreeRTOSConfig.h 中将
`configUSE_TASK_NOTIFICATIONS` 设为 1。

当 `configUSE_TASK_NOTIFICATIONS` 设为 1 时，每个任务至少拥有一个“通知状态”，
其值为“Pending”或“Not-Pending”，以及一个“通知值”（32 位无符号整数）。
任务接收到通知时，通知状态变为 pending；任务读取通知值时，通知状态变为 not-pending。
若 `configTASK_NOTIFICATION_ARRAY_ENTRIES` 设为大于 1 的值，则存在多个通知状态与
通知值，以索引区分。

任务可以在 *Blocked* 状态（可选超时）等待通知状态变为 pending。

### 10.1.3 范围

本章讨论：

- 任务的通知状态与通知值。
- 何时以及如何用任务通知替代通信对象（如信号量）。
- 使用任务通知替代通信对象的优势。

## 10.2 任务通知：优势与限制

### 10.2.1 任务通知的性能优势

使用任务通知向任务发送事件或数据，比使用队列、信号量或事件组执行等价操作要快得多。

### 10.2.2 任务通知的 RAM 占用优势

同样，使用任务通知向任务发送事件或数据，比使用队列、信号量或事件组占用更少 RAM。
原因在于通信对象（队列、信号量、事件组）必须先创建才能使用，而任务通知启用后只有
固定开销。任务通知的 RAM 成本为：每任务 `configTASK_NOTIFICATION_ARRAY_ENTRIES`
* 5 字节。`configTASK_NOTIFICATION_ARRAY_ENTRIES` 默认值为 1，因此默认每任务
5 字节。

### 10.2.3 任务通知的限制

任务通知更快且更省 RAM，但并非所有场景都能使用任务通知。以下场景中任务通知不适用：

- 向 ISR 发送事件或数据

  通信对象可用于在 ISR 与任务之间双向传递事件与数据。

  任务通知可用于从 ISR 向任务发送事件与数据，但不能用于从任务向 ISR 发送事件或数据。

- 允许多个接收任务

  任何知道通信对象句柄的任务或 ISR 都可访问通信对象。任意数量的任务与 ISR 都可
  处理发送到同一通信对象的事件与数据。

  任务通知直接发送给接收任务，因此只能由被通知任务处理。实际应用中这通常不是限制，
  因为多任务/ISR 向同一对象发送很常见，而多个任务/ISR 从同一对象接收却较少。

- 缓冲多个数据项

  队列可同时存放多个数据项。已发送但尚未接收的数据会缓存在队列中。

  任务通知通过更新接收任务的通知值发送数据，但通知值同一时刻只能保存一个值。

- 向多个任务广播

  事件组可同时向多个任务发送事件。

  任务通知直接发送给单个任务，因此只能由该任务处理。

- 等待发送完成

  当通信对象暂时无法写入（例如队列满）时，写入任务可选择进入 *Blocked* 状态
  等待写操作完成。

  若任务向已存在 pending 通知的任务发送任务通知，则发送任务无法阻塞等待接收任务
  清除通知状态。正如后文所示，在使用任务通知的常见场景中，这很少成为限制。

## 10.3 使用任务通知

### 10.3.1 任务通知 API 选项

任务通知功能强大，常可替代二值信号量、计数信号量、事件组，甚至在某些场景下替代队列。
这种广泛用途通过 `xTaskNotify()` 发送任务通知，以及 `xTaskNotifyWait()` 接收任务通知实现。

然而在多数情况下，并不需要 `xTaskNotify()` 与 `xTaskNotifyWait()` 的全部灵活性。
因此提供了更简单但灵活性较低的替代函数：`xTaskNotifyGive()` 作为 `xTaskNotify()` 的简化版，
`ulTaskNotifyTake()` 作为 `xTaskNotifyWait()` 的简化版。

任务通知系统并不限于单个通知事件。配置参数 `configTASK_NOTIFICATION_ARRAY_ENTRIES`
默认值为 1。若设为大于 1，则在每个任务中创建通知数组，可按索引管理通知。
每个任务通知 API 都有索引版本。使用非索引版本会访问 notification[0]（数组首项）。
索引版本以 `Indexed` 后缀标识，例如 `xTaskNotify` 的索引版本为 `xTaskNotifyIndexed`。
为简化起见，本书仅使用非索引版本。

任务通知 API 实际由宏实现，这些宏会调用对应的 `Generic` 版本 API。
为简化表述，本书将这些宏统称为函数。

#### 10.3.1.1 API 函数完整列表 <sup>27</sup>

- `xTaskNotifyGive`
- `xTaskNotifyGiveIndexed`
- `vTaskNotifyGiveFromISR`
- `vTaskNotifyGiveIndexedFromISR`
- `vTaskNotifyTake`
- `vTaskNotifyTakeIndexed`
- `xTaskNotify`
- `xTaskNotifyIndexed`
- `xTaskNotifyWait`
- `xTaskNotifyWaitIndexed`
- `xTaskNotifyStateClear`
- `xTaskNotifyStateClearIndexed`
- `ulTaskNotifyValueClear`
- `ulTaskNotifyValueClearIndexed`
- `xTaskNotifyAndQueryIndexedFromISR`
- `xTaskNotifyAndQueryFromISR`
- `xTaskNotifyFromISR`
- `xTaskNotifyIndexedFromISR`
- `xTaskNotifyAndQuery`
- `xTaskNotifyAndQueryIndexed`

*(27): 这些函数实际上是宏实现。*

> 注意：没有用于接收通知的 `FromISR` 函数，因为通知总是发送给任务，而中断不与任何任务关联。

### 10.3.2 xTaskNotifyGive() API 函数

`xTaskNotifyGive()` 直接向任务发送通知，并递增（加 1）接收任务的通知值。
调用 `xTaskNotifyGive()` 会将接收任务的通知状态设为 pending（若此前非 pending）。

`xTaskNotifyGive()` 作为比二值或计数信号量更轻量、更快的替代方法。


<a name="list10.1" title="Listing 10.1 The xTaskNotifyGive() API function prototype"></a>


```c
BaseType_t xTaskNotifyGive( TaskHandle_t xTaskToNotify );
BaseType_t xTaskNotifyGiveIndexed( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify );
```

***清单 10.1*** *xTaskNotifyGive() API 函数原型*

**xTaskNotifyGive()/xTaskNotifyGiveIndexed() 参数与返回值**

- `xTaskToNotify`

  被通知任务的句柄——可参考 `xTaskCreate()` API 的 `pxCreatedTask` 参数获取任务句柄。

- `uxIndexToNotify`

  通知数组索引。

- 返回值

  `xTaskNotifyGive()` 是调用 `xTaskNotify()` 的宏，宏传入的参数使得 `pdPASS`
  成为唯一可能的返回值。`xTaskNotify()` 将在本章后面介绍。

### 10.3.3 vTaskNotifyGiveFromISR() API 函数

`vTaskNotifyGiveFromISR()` 是 `xTaskNotifyGive()` 的中断安全版本，可在 ISR 中使用。


<a name="list10.2" title="Listing 10.2 The vTaskNotifyGiveFromISR() API function prototype"></a>


```c
void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
									  BaseType_t *pxHigherPriorityTaskWoken );
```

***清单 10.2*** *vTaskNotifyGiveFromISR() API 函数原型*

**vTaskNotifyGiveFromISR() 参数与返回值**

- `xTaskToNotify`

  被通知任务的句柄——可参考 `xTaskCreate()` API 的 `pxCreatedTask` 参数获取任务句柄。

- `pxHigherPriorityTaskWoken`

  若被通知任务正阻塞等待通知，则发送通知将使其离开 *Blocked* 状态。

  若 `vTaskNotifyGiveFromISR()` 使任务离开 *Blocked* 状态，且该任务优先级高于
  当前执行任务（被中断的任务），则 `vTaskNotifyGiveFromISR()` 会将
  `*pxHigherPriorityTaskWoken` 置为 `pdTRUE`。

  若 `vTaskNotifyGiveFromISR()` 将该值置为 `pdTRUE`，则应在退出中断前执行
  上下文切换，确保中断直接返回到最高优先级 *Ready* 任务。

  与所有中断安全 API 一样，`pxHigherPriorityTaskWoken` 在使用前必须初始化为 `pdFALSE`。

### 10.3.4 ulTaskNotifyTake() API 函数

`ulTaskNotifyTake()` 允许任务在 *Blocked* 状态等待通知值大于 0，并在返回前
对通知值执行递减（减 1）或清零。

`ulTaskNotifyTake()` 作为比二值或计数信号量更轻量、更快的替代方法。


<a name="list10.3" title="Listing 10.3 The ulTaskNotifyTake() API function prototype"></a>


```c
uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t
xTicksToWait );
```

***清单 10.3*** *ulTaskNotifyTake() API 函数原型*

**ulTaskNotifyTake() 参数与返回值**

- `xClearCountOnExit`

  若 `xClearCountOnExit` 为 `pdTRUE`，则在 `ulTaskNotifyTake()` 返回前
  将调用任务的通知值清零。

  若 `xClearCountOnExit` 为 `pdFALSE`，且调用任务通知值大于 0，
  则在 `ulTaskNotifyTake()` 返回前对通知值递减。

- `xTicksToWait`

  调用任务在 *Blocked* 状态等待通知值大于 0 的最长时间。

  阻塞时间以 tick 为单位，绝对时间取决于 tick 频率。
  可使用 `pdMS_TO_TICKS()` 将毫秒转换为 tick。

  若 FreeRTOSConfig.h 中 `INCLUDE_vTaskSuspend` 设为 1，将 `xTicksToWait` 设为
  `portMAX_DELAY` 会使任务无限期等待（无超时）。

- 返回值

  返回值为调用任务的通知值在被清零或递减 *之前* 的值，具体取决于
  `xClearCountOnExit`。

  若指定了阻塞时间（`xTicksToWait` 非 0）且返回值非 0，则可能调用任务进入 *Blocked*
  状态等待通知值大于 0，且在超时前收到通知。

  若指定了阻塞时间（`xTicksToWait` 非 0）且返回值为 0，则调用任务进入 *Blocked*
  状态等待通知值大于 0，但在超时前未发生。


<a name="example10.1" title="Example 10.1 Using a task notification in place of a semaphore, method 1"></a>
---
***示例 10.1*** *用任务通知替代信号量（方法 1）*

---

示例 7.1 使用二值信号量在 ISR 中解除任务阻塞，实现任务与中断同步。本示例复现
示例 7.1 的功能，但用“直接任务通知”替代二值信号量。

清单 10.4 展示与中断同步的任务实现。示例 7.1 中的 `xSemaphoreTake()` 被
`ulTaskNotifyTake()` 替代。

`ulTaskNotifyTake()` 的 `xClearCountOnExit` 设为 `pdTRUE`，因此在返回前
接收任务的通知值会被清零。于是需要在每次 `ulTaskNotifyTake()` 之间处理所有已就绪
事件。示例 7.1 使用二值信号量时，需要从硬件判断待处理事件数，这在某些场景并不现实。
示例 10.1 中，待处理事件数由 `ulTaskNotifyTake()` 返回。

在 `ulTaskNotifyTake` 调用之间发生的中断事件会被锁存到任务的通知值中，
若任务已有 pending 通知，则 `ulTaskNotifyTake()` 将立即返回。


<a name="list10.4" title="Listing 10.4 The implementation of the task to which the interrupt processing is deferred (the task that..."></a>


```c
/* 周期任务产生软件中断的频率。 */
const TickType_t xInterruptFrequency = pdMS_TO_TICKS( 500UL );

static void vHandlerTask( void *pvParameters )
{
	 /* xMaxExpectedBlockTime 设为略大于事件之间的最大期望时间。 */
	 const TickType_t xMaxExpectedBlockTime = xInterruptFrequency +
															pdMS_TO_TICKS( 10 );
	 uint32_t ulEventsToProcess;

	 /* 与多数任务一样，该任务在无限循环中实现。 */
	 for( ;; )
	 {
		  /* 等待来自中断服务例程直接发送给该任务的通知。 */
		  ulEventsToProcess = ulTaskNotifyTake( pdTRUE, xMaxExpectedBlockTime );
		  if( ulEventsToProcess != 0 )
		  {
				/* 到达此处说明至少发生了一个事件。在此循环直到处理完
					所有待处理事件（本例仅为每个事件打印一条消息）。 */
				while( ulEventsToProcess > 0 )
				{
					 vPrintString( "Handler task - Processing event.\r\n" );
					 ulEventsToProcess--;
				}
		  }
		  else
		  {
				/* 若执行到此处，则表示在期望时间内未收到中断，
					（在实际应用中）可能需要执行错误恢复操作。 */
		  }
	 }
}
```

***清单 10.4*** *示例 10.1 中延迟处理中断的任务实现（与中断同步的任务）*

用于产生软件中断的周期任务在中断生成前后都会输出消息，以便观察执行顺序。

清单 10.5 展示中断处理程序。该 ISR 几乎只做一件事：向延迟处理中断的任务直接发送通知。


<a name="list10.5" title="Listing 10.5 The implementation of the interrupt service routine used in Example 10.1"></a>


```c
static uint32_t ulExampleInterruptHandler( void )
{
	 BaseType_t xHigherPriorityTaskWoken;

	 /* xHigherPriorityTaskWoken 参数必须初始化为 pdFALSE，若需要上下文切换，
		 中断安全 API 会在内部将其置为 pdTRUE。 */
	 xHigherPriorityTaskWoken = pdFALSE;

	 /* 直接向延迟处理中断的任务发送通知。 */
	 vTaskNotifyGiveFromISR( /* 要通知的任务句柄，该句柄在任务创建时保存。 */
									 xHandlerTask,

									 /* xHigherPriorityTaskWoken 按常规方式使用。 */
									 &xHigherPriorityTaskWoken );

	 /* 将 xHigherPriorityTaskWoken 传给 portYIELD_FROM_ISR()。
		 若 vTaskNotifyGiveFromISR() 在内部将 xHigherPriorityTaskWoken 设为 pdTRUE，
		 调用 portYIELD_FROM_ISR() 将请求上下文切换。若 xHigherPriorityTaskWoken
		 仍为 pdFALSE，则调用 portYIELD_FROM_ISR() 不会产生效果。
		 Windows 移植中 portYIELD_FROM_ISR() 的实现包含返回语句，因此该函数
		 未显式返回值。 */
	 portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
}
```

***清单 10.5*** *示例 10.1 中使用的 ISR 实现*

示例 10.1 的输出如图 10.3 所示。正如预期，它与示例 7.1 的输出完全一致。
中断生成后 `vHandlerTask()` 立即进入 *Running* 状态，因此任务输出将周期任务输出分割。
图 10.4 给出进一步说明。


<a name="fig10.3" title="Figure 10.3 The output produced when Example 7.1 is executed"></a>
<a name="fig10.4" title="Figure 10.4 The sequence of execution when Example 10.1 is executed"></a>

* * *
![](media/image78.png)    
***图 10.3*** *示例 7.1 的输出*

![](media/image79.png)    
***图 10.4*** *示例 10.1 的执行顺序*
* * *

<a name="example10.2" title="Example 10.2 Using a task notification in place of a semaphore, method 2"></a>
---
***示例 10.2*** *用任务通知替代信号量（方法 2）*

---

在示例 10.1 中，`ulTaskNotifyTake()` 的 `xClearOnExit` 参数设为 `pdTRUE`。
示例 10.2 在示例 10.1 基础上略作修改，以演示 `xClearOnExit` 设为 `pdFALSE` 时的行为。

当 `xClearOnExit` 为 `pdFALSE` 时，`ulTaskNotifyTake()` 只会递减通知值，而不会清零。
因此通知计数等于已发生事件数与已处理事件数之差，这让 `vHandlerTask()` 的结构
可以简化两点：

1. 待处理事件数由通知值维护，无需使用本地变量。

2. 每次 `ulTaskNotifyTake()` 之间只需处理一个事件。

示例 10.2 的 `vHandlerTask()` 实现见清单 10.6。


<a name="list10.6" title="Listing 10.6 The implementation of the task to which the interrupt processing is deferred (the task..."></a>


```c
static void vHandlerTask( void *pvParameters )
{
	 /* xMaxExpectedBlockTime 设为略大于事件之间的最大期望时间。 */
	 const TickType_t xMaxExpectedBlockTime = xInterruptFrequency + 
															pdMS_TO_TICKS( 10 );

	 /* 与多数任务一样，该任务在无限循环中实现。 */
	 for( ;; )
	 {
		  /* 等待来自中断服务例程直接发送给该任务的通知。
			 xClearCountOnExit 现在为 pdFALSE，因此 ulTaskNotifyTake() 将递减
			 该任务的通知值，而不是清零。 */
		  if( ulTaskNotifyTake( pdFALSE, xMaxExpectedBlockTime ) != 0 )
		  {
				/* 到达此处表示事件已发生。处理事件（此处仅打印消息）。 */
				vPrintString( "Handler task - Processing event.\r\n" );
		  }
		  else
		  {
				/* 若执行到此处，则表示在期望时间内未收到中断，
					（在实际应用中）可能需要执行错误恢复操作。 */
		  }
	 }
}
```

***清单 10.6*** *示例 10.2 中延迟处理中断任务的实现（与中断同步的任务）*

为演示目的，ISR 也被修改为每次中断发送多个任务通知，从而模拟高频多次中断。
示例 10.2 的 ISR 实现见清单 10.7。


<a name="list10.7" title="Listing 10.7 The implementation of the interrupt service routine used in Example 10.2"></a>


```c
static uint32_t ulExampleInterruptHandler( void )
{
	 BaseType_t xHigherPriorityTaskWoken;

	 xHigherPriorityTaskWoken = pdFALSE;

	 /* 多次向处理任务发送通知。第一次“give”会解除任务阻塞，后续“give”
		 用于演示接收任务的通知值被用来计数（锁存）事件，从而让任务依次处理每个事件。 */
	 vTaskNotifyGiveFromISR( xHandlerTask, &xHigherPriorityTaskWoken );
	 vTaskNotifyGiveFromISR( xHandlerTask, &xHigherPriorityTaskWoken );
	 vTaskNotifyGiveFromISR( xHandlerTask, &xHigherPriorityTaskWoken );

	 portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
}
```

***清单 10.7*** *示例 10.2 中使用的 ISR 实现*

示例 10.2 的输出如图 10.5 所示。可见每次中断生成时 `vHandlerTask()` 会处理全部
三个事件。


<a name="fig10.5" title="Figure 10.5 The output produced when Example 10.2 is executed"></a>

* * *
![](media/image80.jpg)    
***图 10.5*** *示例 10.2 的输出*
* * *

### 10.3.5 xTaskNotify() 与 xTaskNotifyFromISR() API 函数

`xTaskNotify()` 是比 `xTaskNotifyGive()` 更强大的版本，可按以下方式更新接收任务的
通知值：

- 递增（加 1）接收任务通知值，此时 `xTaskNotify()` 等同于 `xTaskNotifyGive()`。

- 在接收任务通知值中置位一个或多个 bit，使通知值成为事件组的轻量、快速替代方案。

- 仅在接收任务自上次更新后已读取通知值的情况下，写入一个新数值。
  这使通知值具备与长度为 1 的队列相似的功能。

- 无论接收任务是否已读取通知值，都写入一个新数值。
  这使通知值具备与 `xQueueOverwrite()` 相似的功能，行为有时称为“邮箱（mailbox）”。

`xTaskNotify()` 比 `xTaskNotifyGive()` 更灵活、更强大，但因此也更复杂。

`xTaskNotifyFromISR()` 是 `xTaskNotify()` 的中断安全版本，可在 ISR 中使用，并带有
额外的 `pxHigherPriorityTaskWoken` 参数。

调用 `xTaskNotify()` 将始终把接收任务通知状态设为 pending（若此前非 pending）。


<a name="list10.8" title="Listing 10.8 Prototypes for the xTaskNotify() and xTaskNotifyFromISR() API functions"></a>


```c
BaseType_t xTaskNotify( TaskHandle_t xTaskToNotify,
								uint32_t ulValue,
								eNotifyAction eAction );

BaseType_t xTaskNotifyFromISR( TaskHandle_t xTaskToNotify,
										 uint32_t ulValue,
										 eNotifyAction eAction,
										 BaseType_t *pxHigherPriorityTaskWoken );
```

***清单 10.8*** *xTaskNotify() 与 xTaskNotifyFromISR() API 函数原型*

**xTaskNotify() 参数与返回值**

- `xTaskToNotify`

  被通知任务的句柄——可参考 `xTaskCreate()` API 的 `pxCreatedTask` 参数获取任务句柄。

- `ulValue`

  `ulValue` 的使用方式由 `eNotifyAction` 决定，见下文。

- `eNotifyAction`

  枚举类型，指定如何更新接收任务的通知值，见下文。

- 返回值

  `xTaskNotify()` 通常返回 `pdPASS`，*仅在下面说明的一个情况例外*。

**xTaskNotify() 的 eNotifyAction 参数取值及对接收任务通知值的影响**

- `eNoAction`

  仅将接收任务通知状态设为 pending，不更新通知值。`xTaskNotify()` 的 `ulValue`
  参数未使用。

  `eNoAction` 使任务通知成为二值信号量的更快、更轻量替代方案。

- `eSetBits`

  将接收任务通知值与 `xTaskNotify()` 的 `ulValue` 进行按位 OR。
  例如 `ulValue` 为 0x01 时，将置位接收任务通知值的 bit 0；
  `ulValue` 为 0x06（二进制 0110）时，将置位 bit 1 与 bit 2。

  `eSetBits` 使任务通知成为事件组的更快、更轻量替代方案。

- `eIncrement`

  递增接收任务通知值。`xTaskNotify()` 的 `ulValue` 参数未使用。

  `eIncrement` 使任务通知成为二值或计数信号量的更快、更轻量替代方案，
  等价于更简单的 `xTaskNotifyGive()`。

- `eSetValueWithoutOverwrite`

  若在调用 `xTaskNotify()` 前接收任务已有 pending 通知，则不执行任何操作，
  并返回 `pdFAIL`。

  若在调用前接收任务没有 pending 通知，则将通知值设为 `ulValue`。

- `eSetValueWithOverwrite`

  无论接收任务在调用前是否已有 pending 通知，都将通知值设为 `ulValue`。

### 10.3.6 xTaskNotifyWait() API 函数

`xTaskNotifyWait()` 是 `ulTaskNotifyTake()` 的增强版。它允许任务在通知状态尚未
pending 时，带可选超时等待通知变为 pending。`xTaskNotifyWait()` 提供在函数入口与
出口清除通知值指定 bit 的选项。


<a name="list10.9" title="Listing 10.9 The xTaskNotifyWait() API function prototype"></a>


```c
BaseType_t xTaskNotifyWait( uint32_t   ulBitsToClearOnEntry,
									 uint32_t   ulBitsToClearOnExit,
									 uint32_t   *pulNotificationValue,
									 TickType_t xTicksToWait );
```

***清单 10.9*** *xTaskNotifyWait() API 函数原型*

**xTaskNotifyWait() 参数与返回值**

- `ulBitsToClearOnEntry`

  若调用前该任务没有 pending 通知，则在函数入口将通知值中 `ulBitsToClearOnEntry`
  指定的 bit 清零。

  例如，`ulBitsToClearOnEntry` 为 0x01 时清除通知值 bit 0；
  `ulBitsToClearOnEntry` 设为 0xffffffff（`ULONG_MAX`）则清除全部 bit，使通知值清零。

- `ulBitsToClearOnExit`

  若任务因收到通知而退出 `xTaskNotifyWait()`，或在调用时已存在 pending 通知，
  则在函数退出前将通知值中 `ulBitsToClearOnExit` 指定的 bit 清零。

  清零发生在通知值保存到 `*pulNotificationValue` 之后（见下文 `pulNotificationValue`）。

  例如，`ulBitsToClearOnExit` 为 0x03 时，退出前会清除通知值 bit 0 与 bit 1。

  `ulBitsToClearOnExit` 设为 0xffffffff（`ULONG_MAX`）则清除全部 bit，使通知值清零。

- `pulNotificationValue`

  用于返回任务通知值。写入 `*pulNotificationValue` 的值是清除 `ulBitsToClearOnExit`
  指定位之前的通知值。

  `pulNotificationValue` 为可选参数，若不需要，可设为 NULL。

- `xTicksToWait`

  调用任务在 *Blocked* 状态等待通知状态变为 pending 的最长时间。

  阻塞时间以 tick 为单位，绝对时间取决于 tick 频率。
  可使用 `pdMS_TO_TICKS()` 将毫秒转换为 tick。

  若 FreeRTOSConfig.h 中 `INCLUDE_vTaskSuspend` 设为 1，将 `xTicksToWait` 设为
  `portMAX_DELAY` 会使任务无限期等待（无超时）。

- 返回值

  有两种可能返回值：

  - `pdTRUE`

	 表示 `xTaskNotifyWait()` 因收到通知而返回，或因调用时已有 pending 通知而返回。

	 若指定了阻塞时间（`xTicksToWait` 非 0），调用任务可能进入 *Blocked* 状态等待
	 通知状态变为 pending，但在超时前收到通知。

  - `pdFALSE`

	 表示 `xTaskNotifyWait()` 返回时未收到通知。

	 若 `xTicksToWait` 非 0，则调用任务会在 *Blocked* 状态等待通知状态变为 pending，
	 但在超时前未发生。

### 10.3.7 任务通知在外设驱动中的使用：UART 示例

外设驱动库提供对硬件接口的常见操作函数。例如 UART、SPI、ADC、以太网等外设
常有驱动库。驱动库函数通常包括外设初始化、发送数据、接收数据等。

某些外设操作耗时较长，例如高精度 ADC 转换、UART 发送大数据包。驱动库函数可通过
轮询（反复读取）外设状态寄存器判断完成，但这种轮询几乎总是浪费，因为在无任何有用
处理时会占用 100% 处理器时间。在多任务系统中尤其昂贵，因为轮询任务可能阻止低
优先级任务执行。

为避免浪费处理时间，RTOS 感知的高效驱动应基于中断，并允许发起耗时操作的任务
选择在 *Blocked* 状态等待操作完成。这样，在操作进行时低优先级任务可运行，
任务仅在可有效利用处理时间时才消耗处理时间。

RTOS 感知驱动常使用二值信号量将任务置于 *Blocked* 状态。清单 10.10 的伪代码
展示了在 UART 发送函数中使用该技术：

- `xUART` 为描述 UART 外设的结构体，保存状态信息。其 `xTxSemaphore` 成员为
  `SemaphoreHandle_t` 类型，假定已创建。

- `xUART_Send()` 不含互斥逻辑。若多个任务要使用 `xUART_Send()`，应用编写者需在
  应用层管理互斥，例如调用前先获取互斥量。

- `xSemaphoreTake()` 用于在启动 UART 发送后将任务置于 *Blocked* 状态。

- `xSemaphoreGiveFromISR()` 用于发送完成后（UART 发送完成中断触发时）解除阻塞。


<a name="list10.10" title="Listing 10.10 Pseudo code demonstrating how a binary semaphore can be used in a driver library transmit..."></a>


```c
/* 驱动库函数：向 UART 发送数据。 */

BaseType_t xUART_Send( xUART *pxUARTInstance, 
							  uint8_t *pucDataSource, 
							  size_t uxLength )
{
	 BaseType_t xReturn;

	 /* 通过无超时获取信号量，确保 UART 发送信号量当前不可用。 */
	 xSemaphoreTake( pxUARTInstance->xTxSemaphore, 0 );

	 /* 启动发送。 */
	 UART_low_level_send( pxUARTInstance, pucDataSource, uxLength );

	 /* 在信号量上阻塞等待发送完成。若成功获取信号量，则 xReturn 设为 pdPASS；
		 若获取超时，则 xReturn 设为 pdFAIL。注意若 UART_low_level_send() 与
		 xSemaphoreTake() 之间发生中断，事件会被锁存在二值信号量中，
		 xSemaphoreTake() 将立即返回。 */
	 xReturn = xSemaphoreTake( pxUARTInstance->xTxSemaphore, 
										pxUARTInstance->xTxTimeout );

	 return xReturn;
}
/*-----------------------------------------------------------*/

/* UART 发送结束中断的服务例程，在最后一个字节发送完成后执行。 */
void xUART_TransmitEndISR( xUART *pxUARTInstance )
{
	 BaseType_t xHigherPriorityTaskWoken = pdFALSE;

	 /* 清除中断。 */
	 UART_low_level_interrupt_clear( pxUARTInstance );

	 /* 释放 Tx 信号量以表示发送结束。若任务因等待该信号量而处于 Blocked 状态，
		 则将其从 Blocked 状态移出。 */
	 xSemaphoreGiveFromISR( pxUARTInstance->xTxSemaphore, 
									&xHigherPriorityTaskWoken );
	 portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
}
```

***清单 10.10*** *在驱动发送函数中使用二值信号量的伪代码*

清单 10.10 所示方法可行且常用，但存在一些缺点：

- 库使用多个信号量，增加 RAM 占用。

- 信号量必须先创建才能使用，因此使用信号量的库必须先显式初始化。

- 信号量是通用对象，适用于多种场景；其内部逻辑允许多个任务等待同一信号量，
  并在信号量可用时以确定性方式选择一个任务解除阻塞。执行该逻辑需要时间，
  在清单 10.10 的场景中并不必要，因为不可能同时有多个任务等待同一信号量。

清单 10.11 展示如何使用任务通知替代二值信号量，以避免上述缺点。

> *注意：若库使用任务通知，库文档必须明确说明：调用库函数可能改变调用任务的通知状态与通知值。*

在清单 10.11 中：

- `xUART` 结构体的 `xTxSemaphore` 被替换为 `xTaskToNotify`。
  `xTaskToNotify` 为 `TaskHandle_t` 类型，用于保存等待 UART 操作完成的任务句柄。

- `xTaskGetCurrentTaskHandle()` 用于获取 *Running* 状态任务句柄。

- 库不创建任何 FreeRTOS 对象，因此无额外 RAM 开销，且无需显式初始化。

- 任务通知直接发送给等待 UART 操作完成的任务，因此无需执行多余逻辑。

`xUART` 结构体中的 `xTaskToNotify` 会在任务与 ISR 中被访问，因此必须考虑
处理器如何更新该值：

- 若 `xTaskToNotify` 可由一次内存写操作更新，则可在临界区之外更新，如清单 10.11。
  当 `xTaskToNotify` 为 32 位变量（`TaskHandle_t` 为 32 位类型）且处理器为 32 位时
  就属于这种情况。

- 若更新 `xTaskToNotify` 需要多次内存写操作，则必须在临界区中更新；否则 ISR 可能
  在其不一致状态下访问 `xTaskToNotify`。例如 `xTaskToNotify` 为 32 位变量而处理器
  为 16 位时，需要两次 16 位写操作才能更新 32 位。

在 FreeRTOS 内部，`TaskHandle_t` 是指针，因此 `sizeof( TaskHandle_t )` 始终等于
`sizeof( void * )`。


<a name="list10.11" title="Listing 10.11 Pseudo code demonstrating how a task notification can be used in a driver library transmit..."></a>


```c
/* 驱动库函数：向 UART 发送数据。 */
BaseType_t xUART_Send( xUART *pxUARTInstance, 
							  uint8_t *pucDataSource, 
							  size_t uxLength )
{
	 BaseType_t xReturn;

	 /* 保存调用该函数的任务句柄。正文说明了以下语句是否需要临界区保护。 */
	 pxUARTInstance->xTaskToNotify = xTaskGetCurrentTaskHandle();

	 /* 通过将 xClearCountOnExit 设为 pdTRUE、阻塞时间设为 0（不阻塞）
		 调用 ulTaskNotifyTake()，确保调用任务当前无待处理通知。 */
	 ulTaskNotifyTake( pdTRUE, 0 );

	 /* 启动发送。 */
	 UART_low_level_send( pxUARTInstance, pucDataSource, uxLength );

	 /* 阻塞直到收到发送完成通知。若收到通知，则 xReturn 设为 1，
		 因为 ISR 会将该任务通知值递增至 1（pdTRUE）。若操作超时，
		 则 xReturn 为 0（pdFALSE），因为通知值自上面清零后未被改变。
		 注意若 ISR 在 UART_low_level_send() 与 ulTaskNotifyTake() 之间执行，
		 事件会被锁存在任务通知值中，ulTaskNotifyTake() 将立即返回。 */
	 xReturn = ( BaseType_t ) ulTaskNotifyTake( pdTRUE, 
															  pxUARTInstance->xTxTimeout );

	 return xReturn;
}
/*-----------------------------------------------------------*/

/* UART 最后一个字节发送完成后执行的 ISR。 */
void xUART_TransmitEndISR( xUART *pxUARTInstance )
{
	 BaseType_t xHigherPriorityTaskWoken = pdFALSE;

	 /* 若没有任务等待通知，此函数不应执行。使用断言测试该条件。
		 此步骤并非严格必要，但有助于调试。configASSERT() 见第 12.2 节。 */
	 configASSERT( pxUARTInstance->xTaskToNotify != NULL );

	 /* 清除中断。 */
	 UART_low_level_interrupt_clear( pxUARTInstance );

	 /* 直接向调用 xUART_Send() 的任务发送通知。若该任务因等待通知而处于
		 Blocked 状态，则将其从 Blocked 状态移出。 */
	 vTaskNotifyGiveFromISR( pxUARTInstance->xTaskToNotify,
									 &xHigherPriorityTaskWoken );

	 /* 现在没有任务等待通知。将 xUART 结构体的 xTaskToNotify 成员设回 NULL。
		 此步骤并非严格必要，但有助于调试。 */
	 pxUARTInstance->xTaskToNotify = NULL;
	 portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
}
```

***清单 10.11*** *在驱动发送函数中使用任务通知的伪代码*

任务通知也可在接收函数中替代信号量，清单 10.12 给出了 RTOS 感知 UART 接收函数的
伪代码。参考清单 10.12：

- `xUART_Receive()` 不包含互斥逻辑。若多个任务使用 `xUART_Receive()`，应用编写者需
  在应用层管理互斥，例如调用前先获取互斥量。

- UART 接收 ISR 将接收到的字符放入 RAM 缓冲区，`xUART_Receive()` 从缓冲区读出字符。

- `xUART_Receive()` 的 `uxWantedBytes` 指定要接收的字符数。若缓冲区字符不足，
  调用任务进入 *Blocked* 状态等待通知（缓冲区字符数增加）。`while()` 循环重复该流程，
  直到缓冲区字符足够或超时。

- 调用任务可能多次进入 *Blocked* 状态，因此阻塞时间需要根据已耗时间调整。
  该调整确保 `xUART_Receive()` 总耗时不超过 `xUART` 结构体 `xRxTimeout` 指定的超时。
  阻塞时间通过 FreeRTOS 辅助函数 `vTaskSetTimeOutState()` 与 `xTaskCheckForTimeOut()` 调整。


<a name="list10.12" title="Listing 10.12 Pseudo code demonstrating how a task notification can be used in a driver library receive..."></a>


```c
/* 驱动库函数：从 UART 接收数据。 */

size_t xUART_Receive( xUART *pxUARTInstance, 
							 uint8_t *pucBuffer,
							 size_t uxWantedBytes )
{
	 size_t uxReceived = 0;
	 TickType_t xTicksToWait;
	 TimeOut_t xTimeOut;

	 /* 记录进入该函数的时间。 */
	 vTaskSetTimeOutState( &xTimeOut );

	 /* xTicksToWait 为超时值——初始设为该 UART 实例的最大接收超时。 */
	 xTicksToWait = pxUARTInstance->xRxTimeout;

	 /* 保存调用该函数的任务句柄。正文说明了以下语句是否需要临界区保护。 */
	 pxUARTInstance->xTaskToNotify = xTaskGetCurrentTaskHandle();

	 /* 循环直到缓冲区包含所需字节数，或发生超时。 */
	 while( UART_bytes_in_rx_buffer( pxUARTInstance ) < uxWantedBytes )
	 {
		  /* 检查超时，并调整 xTicksToWait 以考虑已在该函数中消耗的时间。 */
		  if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) != pdFALSE )
		  {
				/* 在所需字节数可用前超时，退出循环。 */
				break;
		  }

		  /* 接收缓冲区尚未包含所需字节数。最多等待 xTicksToWait 个 tick，
			  以便接收 ISR 将更多数据放入缓冲区。不必担心调用任务在调用本函数
			  时已存在待处理通知；若存在，只会让该 while 循环多迭代一次。 */
		  ulTaskNotifyTake( pdTRUE, xTicksToWait );
	 }

	 /* 没有任务等待接收通知，因此将 xTaskToNotify 设回 NULL。
		 正文说明了以下语句是否需要临界区保护。 */
	 pxUARTInstance->xTaskToNotify = NULL;

	 /* 尝试从接收缓冲区读取 uxWantedBytes 字节到 pucBuffer。
		 返回实际读取的字节数（可能小于 uxWantedBytes）。 */
	 uxReceived = UART_read_from_receive_buffer( pxUARTInstance, 
																pucBuffer,
																uxWantedBytes );
	 return uxReceived;
}

/*-----------------------------------------------------------*/

/* UART 接收中断的中断服务例程 */
void xUART_ReceiveISR( xUART *pxUARTInstance )
{
	 BaseType_t xHigherPriorityTaskWoken = pdFALSE;

	 /* 将接收数据拷贝到该 UART 的接收缓冲区并清除中断。 */
	 UART_low_level_receive( pxUARTInstance );

	 /* 若有任务在等待新数据通知，则立即通知它。 */
	 if( pxUARTInstance->xTaskToNotify != NULL )
	 {
		  vTaskNotifyGiveFromISR( pxUARTInstance->xTaskToNotify,
										  &xHigherPriorityTaskWoken );
		  portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
	 }
}
```

***清单 10.12*** *在驱动接收函数中使用任务通知的伪代码*

### 10.3.8 任务通知在外设驱动中的使用：ADC 示例

上一节展示了使用 `vTaskNotifyGiveFromISR()` 从 ISR 向任务发送通知。
`vTaskNotifyGiveFromISR()` 简单易用，但能力有限：只能发送无数据的通知事件，
无法携带数据。本节展示如何使用 `xTaskNotifyFromISR()` 发送包含数据的通知事件。
清单 10.13 的伪代码给出了 ADC 相关 ISR 的 RTOS 感知实现示例，其中：

- 假设 ADC 转换至少每 50ms 触发一次。

- `ADC_ConversionEndISR()` 为 ADC 转换完成中断 ISR，每次新 ADC 值可用时触发。

- `vADCTask()` 任务负责处理 ADC 输出值，任务句柄在创建时保存到 `xADCTaskToNotify`。

- `ADC_ConversionEndISR()` 使用 `xTaskNotifyFromISR()`，`eAction` 设为
  `eSetValueWithoutOverwrite`，向 `vADCTask()` 发送通知并把 ADC 结果写入通知值。

- `vADCTask()` 使用 `xTaskNotifyWait()` 等待新 ADC 值，并从通知值中读取转换结果。


<a name="list10.13" title="Listing 10.13 Pseudo code demonstrating how a task notification can be used to pass a value to a task"></a>


```c
/* 使用 ADC 的任务。 */
void vADCTask( void *pvParameters )
{
	 uint32_t ulADCValue;
	 BaseType_t xResult;

	 /* 触发 ADC 转换的频率。 */
	 const TickType_t xADCConversionFrequency = pdMS_TO_TICKS( 50 );

	 for( ;; )
	 {
		  /* 等待下一次 ADC 转换结果。 */
		  xResult = xTaskNotifyWait(
						  /* 新的 ADC 值将覆盖旧值，因此在等待新通知值之前无需清除任何位。 */
						  0,
						  /* 后续 ADC 值会覆盖已有值，因此在退出 xTaskNotifyWait() 前无需清除任何位。 */
						  0,
						  /* 用于保存任务通知值（包含最新 ADC 转换结果）的变量地址。 */
						  &ulADCValue,
						  /* 每 xADCConversionFrequency 个 tick 应收到一个新 ADC 值。 */
						  xADCConversionFrequency * 2 );

		  if( xResult == pdPASS )
		  {
				/* 收到新的 ADC 值，立即处理。 */
				ProcessADCResult( ulADCValue );
		  }
		  else
		  {
				/* xTaskNotifyWait() 未在期望时间内返回，
					 可能是触发 ADC 转换的输入异常或 ADC 本身异常。此处处理错误。 */
		  }
	 }
}

/*-----------------------------------------------------------*/

/* 每次 ADC 转换完成时执行的中断服务例程。 */
void ADC_ConversionEndISR( xADC *pxADCInstance )
{
	 uint32_t ulConversionResult;
	 BaseType_t xHigherPriorityTaskWoken = pdFALSE, xResult;

	 /* 读取新的 ADC 值并清除中断。 */
	 ulConversionResult = ADC_low_level_read( pxADCInstance );

	 /* 将通知及 ADC 转换结果直接发送给 vADCTask()。 */
	 xResult = xTaskNotifyFromISR( xADCTaskToNotify, /* xTaskToNotify 参数 */
													 ulConversionResult, /* ulValue 参数 */
													 eSetValueWithoutOverwrite, /* eAction 参数。 */
											 &xHigherPriorityTaskWoken );

	 /* 若 xTaskNotifyFromISR() 返回 pdFAIL，则任务未能跟上 ADC 值产生速率。
		 configASSERT() 见第 11.2 节。 */
	 configASSERT( xResult == pdPASS );
	 portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
}
```

***清单 10.13*** *使用任务通知向任务传递数值的伪代码*

### 10.3.9 任务通知在应用中的直接使用

本节通过一个假想应用进一步展示任务通知的强大能力，该应用包含以下功能：

- 应用通过缓慢的互联网连接与远端数据服务器通信，以发送数据并请求数据。
  后文将远端数据服务器称为 *云服务器*。

- 请求数据后，请求任务必须在 *Blocked* 状态等待所请求数据到达。

- 发送数据后，发送任务必须在 *Blocked* 状态等待云服务器确认数据正确接收。

软件设计示意见图 10.6。在图 10.6 中：

- 多条到云服务器的互联网连接处理被封装在一个 FreeRTOS 任务中。该任务在应用内
  充当代理服务器，称为 *服务器任务*。

- 应用任务调用 `CloudRead()` 读取云服务器数据。`CloudRead()` 不直接与云服务器通信，
  而是通过队列向服务器任务发送读取请求，并通过任务通知接收服务器任务返回的数据。

- 应用任务调用 `CloudWrite()` 写数据到云服务器。`CloudWrite()` 不直接与云服务器通信，
  而是通过队列向服务器任务发送写请求，并通过任务通知接收服务器任务返回的写结果。

`CloudRead()` 与 `CloudWrite()` 发送给服务器任务的结构体见清单 10.14。


<a name="fig10.6" title="Figure 10.6 The communication paths from the application tasks to the cloud server, and back again"></a>

* * *
![](media/image81.png)    
***图 10.6*** *应用任务与云服务器之间的通信路径*
* * *


<a name="list10.14" title="Listing 10.14 The structure and data type sent on a queue to the server task"></a>


```c
typedef enum CloudOperations
{
	 eRead, /* 向云服务器发送数据。 */
	 eWrite /* 从云服务器接收数据。 */
} Operation_t;

typedef struct CloudCommand
{
	 Operation_t eOperation; /* 要执行的操作（读或写）。 */
	 uint32_t ulDataID; /* 标识正在读取或写入的数据。 */
	 uint32_t ulDataValue; /* 仅在写入云服务器数据时使用。 */
	 TaskHandle_t xTaskToNotify;/* 执行该操作的任务句柄。 */
} CloudCommand_t;
```

***清单 10.14*** *发送到服务器任务队列的结构体与数据类型*

`CloudRead()` 的伪代码见清单 10.15。该函数向服务器任务发送请求，然后调用
`xTaskNotifyWait()` 在 *Blocked* 状态等待服务器返回所请求数据。

清单 10.16 展示服务器任务如何处理读请求。当从云服务器收到数据后，服务器任务
通过 `xTaskNotify()`（`eAction` 设为 `eSetValueWithOverwrite`）解除应用任务阻塞
并发送数据。

清单 10.16 为简化场景，假设 `GetCloudData()` 不需要等待云服务器返回。


<a name="list10.15" title="Listing 10.15 The Implementation of the Cloud Read API Function"></a>


```c
/* ulDataID 用于标识要读取的数据。pulValue 保存写入云服务器返回数据的变量地址。 */
BaseType_t CloudRead( uint32_t ulDataID, uint32_t *pulValue )
{
	 CloudCommand_t xRequest;
	 BaseType_t xReturn;

	 /* 设定 CloudCommand_t 结构体成员以匹配此次读请求。 */
	 xRequest.eOperation = eRead; /* 这是读取数据的请求。 */
	 xRequest.ulDataID = ulDataID; /* 标识要读取数据的代码。 */
	 xRequest.xTaskToNotify = xTaskGetCurrentTaskHandle(); /* 调用任务的句柄。 */

	 /* 通过以 0 的阻塞时间读取通知值，确保没有待处理通知，然后将结构体发送给服务器任务。 */
	 xTaskNotifyWait( 0, 0, NULL, 0 );
	 xQueueSend( xServerTaskQueue, &xRequest, portMAX_DELAY );

	 /* 等待服务器任务的通知。服务器任务将从云服务器收到的值直接写入本任务的
		 通知值，因此在进入或退出 xTaskNotifyWait() 时无需清除任何位。
		 接收值将写入 *pulValue，因此传入 pulValue 作为写入通知值的地址。 */
	 xReturn = xTaskNotifyWait( 0, /* 入口不清零任何位 */
									 0, /* 退出不清零任何位 */
									 pulValue, /* 通知值写入 *pulValue */
									 pdMS_TO_TICKS( 250 ) ); /* 最多等待 250ms */

	 /* 若 xReturn 为 pdPASS，表示已获得值；若 xReturn 为 pdFAIL，则请求超时。 */
	 return xReturn;
}
```

***清单 10.15*** *CloudRead API 函数实现*


<a name="list10.16" title="Listing 10.16 The Server Task Processing a Read Request"></a>


```c
void ServerTask( void *pvParameters )
{
	 CloudCommand_t xCommand;
	 uint32_t ulReceivedValue;

	 for( ;; )
	 {
		  /* 等待从任务接收下一个 CloudCommand_t 结构体。 */
		  xQueueReceive( xServerTaskQueue, &xCommand, portMAX_DELAY );

		  switch( xCommand.eOperation ) /* 是读请求还是写请求？ */
		  {
				case eRead:

					 /* 从远端云服务器获取所请求的数据项。 */
					 ulReceivedValue = GetCloudData( xCommand.ulDataID );

					 /* 调用 xTaskNotify() 将通知及从云服务器收到的值发送给发起请求的任务。
						 任务句柄从 CloudCommand_t 结构体获取。 */
					 xTaskNotify( xCommand.xTaskToNotify, /* 任务句柄在结构体中 */
										ulReceivedValue, /* 云数据作为通知值发送 */
									  eSetValueWithOverwrite );
					 break;

					 /* 其他 switch 分支放在这里。 */
		  }
	 }
}
```

***清单 10.16*** *服务器任务处理读请求*

`CloudWrite()` 的伪代码见清单 10.17。为演示目的，`CloudWrite()` 返回一个按位状态码，
状态码的每一位都有独立含义。清单 10.17 顶部的 `#define` 给出了四个示例状态位。

任务清除四个状态位，发送请求给服务器任务，然后调用 `xTaskNotifyWait()` 在
*Blocked* 状态等待状态通知。


<a name="list10.17" title="Listing 10.17 The Implementation of the Cloud Write API Function"></a>


```c
/* 云写操作使用的状态位。 */
#define SEND_SUCCESSFUL_BIT ( 0x01 << 0 )
#define OPERATION_TIMED_OUT_BIT ( 0x01 << 1 )
#define NO_INTERNET_CONNECTION_BIT ( 0x01 << 2 )
#define CANNOT_LOCATE_CLOUD_SERVER_BIT ( 0x01 << 3 )

/* 具有四个状态位的掩码。 */
#define CLOUD_WRITE_STATUS_BIT_MASK ( SEND_SUCCESSFUL_BIT |
												  OPERATION_TIMED_OUT_BIT |
												  NO_INTERNET_CONNECTION_BIT |
												  CANNOT_LOCATE_CLOUD_SERVER_BIT )

uint32_t CloudWrite( uint32_t ulDataID, uint32_t ulDataValue )
{
	 CloudCommand_t xRequest;
	 uint32_t ulNotificationValue;

	 /* 设定 CloudCommand_t 结构体成员以匹配此次写请求。 */
	 xRequest.eOperation = eWrite; /* 这是写数据请求 */
	 xRequest.ulDataID = ulDataID; /* 标识正在写入数据的代码 */
	 xRequest.ulDataValue = ulDataValue; /* 写入云服务器的数据值。 */
	 xRequest.xTaskToNotify = xTaskGetCurrentTaskHandle(); /* 调用任务的句柄。 */

	 /* 调用 xTaskNotifyWait() 清除与写操作相关的三个状态位，
		 将 ulBitsToClearOnExit 设为 CLOUD_WRITE_STATUS_BIT_MASK，阻塞时间设为 0。
		 不需要当前通知值，因此 pulNotificationValue 设为 NULL。 */
	 xTaskNotifyWait( 0, CLOUD_WRITE_STATUS_BIT_MASK, NULL, 0 );

	 /* 将请求发送给服务器任务。 */
	 xQueueSend( xServerTaskQueue, &xRequest, portMAX_DELAY );

	 /* 等待服务器任务的通知。服务器任务将按位状态码写入本任务的通知值，
		 并保存到 ulNotificationValue。 */
	 xTaskNotifyWait( 0, /* 入口不清零任何位。 */
								CLOUD_WRITE_STATUS_BIT_MASK, /* 退出时将相关位置 0。 */
								&ulNotificationValue, /* 通知值。 */
								pdMS_TO_TICKS( 250 ) ); /* 最多等待 250ms。 */

	 /* 将状态码返回给调用任务。 */
	 return ( ulNotificationValue & CLOUD_WRITE_STATUS_BIT_MASK );
}
```

***清单 10.17*** *CloudWrite API 函数实现*

服务器任务处理写请求的伪代码见清单 10.18。当数据发送到云服务器后，服务器任务通过
`xTaskNotify()`（`eAction` 设为 `eSetBits`）解除应用任务阻塞并发送按位状态码。
接收任务的通知值中只有 `CLOUD_WRITE_STATUS_BIT_MASK` 指定的位会被改变，因此接收任务
可用通知值中的其他位做其他用途。

清单 10.18 为简化场景，假设 `SetCloudData()` 不需要等待云服务器确认。


<a name="list10.18" title="Listing 10.18 The Server Task Processing a Send Request"></a>


```c
void ServerTask( void *pvParameters )
{
	 CloudCommand_t xCommand;
	 uint32_t ulBitwiseStatusCode;

	 for( ;; )
	 {
		  /* 等待下一条消息。 */
		  xQueueReceive( xServerTaskQueue, &xCommand, portMAX_DELAY );

		  /* 是读请求还是写请求？ */
		  switch( xCommand.eOperation )
		  {
				case eWrite:

				/* 将数据发送到远端云服务器。SetCloudData() 返回按位状态码，
					 仅使用 CLOUD_WRITE_STATUS_BIT_MASK 定义的位（见清单 10.17）。 */
				ulBitwiseStatusCode = SetCloudData( xCommand.ulDataID,
																xCommand.ulDataValue );

				/* 向发起写请求的任务发送通知。使用 eSetBits 动作，使
					 ulBitwiseStatusCode 中置位的状态位在被通知任务的通知值中置位，
					 其他位保持不变。任务句柄从 CloudCommand_t 结构体获取。 */
				xTaskNotify( xCommand.xTaskToNotify, /* 任务句柄在结构体中。 */
									ulBitwiseStatusCode,    /* 云数据作为通知值发送。 */
								 eSetBits );
				break;

				/* 其他 switch 分支放在这里。 */
		  }
	 }
}
```

***清单 10.18*** *服务器任务处理发送请求*
