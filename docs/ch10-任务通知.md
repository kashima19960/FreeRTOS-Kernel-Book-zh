# 10 任务通知

## 10.1 简介

FreeRTOS 应用通常由一系列相互独立的任务组成，任务之间通过通信协作提供系统功能。
任务通知是一种高效机制，使一个任务能够直接通知另一个任务。

### 10.1.1 通过中间对象通信

本书已介绍了多种任务间通信方式。到目前为止的方式都需要创建一个通信对象。
通信对象的例子包括队列、事件组及各种信号量。

使用通信对象时，事件与数据并非直接发送给接收任务或接收 ISR，而是发送到通信对象。
同样，任务与 ISR 也是从通信对象接收事件与数据，而非直接从发送事件或数据的任务或 ISR
接收。图 10.1 展示了这一点。


<a name="fig10.1" title="Figure 10.1 A communication object being used to send an event from one task to another"></a>

* * *
![](media/image76.png)    
***图 10.1*** *使用通信对象将事件从一个任务发送到另一个任务*
* * *

### 10.1.2 任务通知——直接到任务的通信

“任务通知”允许任务彼此交互，并与 ISR 同步，而无需单独的通信对象。
通过任务通知，任务或 ISR 可直接向接收任务发送事件。如图 10.2 所示。


<a name="fig10.2" title="Figure 10.2 A task notification used to send an event directly from one task to another"></a>

* * *
![](media/image77.png)    
***图 10.2*** *使用任务通知直接将事件从一个任务发送到另一个任务*
* * *

任务通知功能是可选的。要启用任务通知功能，请在 FreeRTOSConfig.h 中将
`configUSE_TASK_NOTIFICATIONS` 设为 1。

当 `configUSE_TASK_NOTIFICATIONS` 设为 1 时，每个任务至少拥有一个“通知状态”，
其值为“Pending”或“Not-Pending”，以及一个“通知值”（32 位无符号整数）。
任务接收到通知时，通知状态变为 pending；任务读取通知值时，通知状态变为 not-pending。
若 `configTASK_NOTIFICATION_ARRAY_ENTRIES` 设为大于 1 的值，则存在多个通知状态与
通知值，以索引区分。

任务可以在 *Blocked* 状态（可选超时）等待通知状态变为 pending。

### 10.1.3 范围

本章讨论：

- 任务的通知状态与通知值。
- 何时以及如何用任务通知替代通信对象（如信号量）。
- 使用任务通知替代通信对象的优势。

## 10.2 任务通知：优势与限制

### 10.2.1 任务通知的性能优势

使用任务通知向任务发送事件或数据，比使用队列、信号量或事件组执行等价操作要快得多。

### 10.2.2 任务通知的 RAM 占用优势

同样，使用任务通知向任务发送事件或数据，比使用队列、信号量或事件组占用更少 RAM。
原因在于通信对象（队列、信号量、事件组）必须先创建才能使用，而任务通知启用后只有
固定开销。任务通知的 RAM 成本为：每任务 `configTASK_NOTIFICATION_ARRAY_ENTRIES`
* 5 字节。`configTASK_NOTIFICATION_ARRAY_ENTRIES` 默认值为 1，因此默认每任务
5 字节。

### 10.2.3 任务通知的限制

任务通知更快且更省 RAM，但并非所有场景都能使用任务通知。以下场景中任务通知不适用：

- 向 ISR 发送事件或数据

  通信对象可用于在 ISR 与任务之间双向传递事件与数据。

  任务通知可用于从 ISR 向任务发送事件与数据，但不能用于从任务向 ISR 发送事件或数据。

- 允许多个接收任务

  任何知道通信对象句柄的任务或 ISR 都可访问通信对象。任意数量的任务与 ISR 都可
  处理发送到同一通信对象的事件与数据。

  任务通知直接发送给接收任务，因此只能由被通知任务处理。实际应用中这通常不是限制，
  因为多任务/ISR 向同一对象发送很常见，而多个任务/ISR 从同一对象接收却较少。

- 缓冲多个数据项

  队列可同时存放多个数据项。已发送但尚未接收的数据会缓存在队列中。

  任务通知通过更新接收任务的通知值发送数据，但通知值同一时刻只能保存一个值。

- 向多个任务广播

  事件组可同时向多个任务发送事件。

  任务通知直接发送给单个任务，因此只能由该任务处理。

- 等待发送完成

  当通信对象暂时无法写入（例如队列满）时，写入任务可选择进入 *Blocked* 状态
  等待写操作完成。

  若任务向已存在 pending 通知的任务发送任务通知，则发送任务无法阻塞等待接收任务
  清除通知状态。正如后文所示，在使用任务通知的常见场景中，这很少成为限制。

## 10.3 使用任务通知

### 10.3.1 任务通知 API 选项

任务通知功能强大，常可替代二值信号量、计数信号量、事件组，甚至在某些场景下替代队列。
这种广泛用途通过 `xTaskNotify()` 发送任务通知，以及 `xTaskNotifyWait()` 接收任务通知实现。

然而在多数情况下，并不需要 `xTaskNotify()` 与 `xTaskNotifyWait()` 的全部灵活性。
因此提供了更简单但灵活性较低的替代函数：`xTaskNotifyGive()` 作为 `xTaskNotify()` 的简化版，
`ulTaskNotifyTake()` 作为 `xTaskNotifyWait()` 的简化版。

任务通知系统并不限于单个通知事件。配置参数 `configTASK_NOTIFICATION_ARRAY_ENTRIES`
默认值为 1。若设为大于 1，则在每个任务中创建通知数组，可按索引管理通知。
每个任务通知 API 都有索引版本。使用非索引版本会访问 notification[0]（数组首项）。
索引版本以 `Indexed` 后缀标识，例如 `xTaskNotify` 的索引版本为 `xTaskNotifyIndexed`。
为简化起见，本书仅使用非索引版本。

任务通知 API 实际由宏实现，这些宏会调用对应的 `Generic` 版本 API。
为简化表述，本书将这些宏统称为函数。

#### 10.3.1.1 API 函数完整列表 <sup>27</sup>

- `xTaskNotifyGive`
- `xTaskNotifyGiveIndexed`
- `vTaskNotifyGiveFromISR`
- `vTaskNotifyGiveIndexedFromISR`
- `vTaskNotifyTake`
- `vTaskNotifyTakeIndexed`
- `xTaskNotify`
- `xTaskNotifyIndexed`
- `xTaskNotifyWait`
- `xTaskNotifyWaitIndexed`
- `xTaskNotifyStateClear`
- `xTaskNotifyStateClearIndexed`
- `ulTaskNotifyValueClear`
- `ulTaskNotifyValueClearIndexed`
- `xTaskNotifyAndQueryIndexedFromISR`
- `xTaskNotifyAndQueryFromISR`
- `xTaskNotifyFromISR`
- `xTaskNotifyIndexedFromISR`
- `xTaskNotifyAndQuery`
- `xTaskNotifyAndQueryIndexed`

*(27): 这些函数实际上是宏实现。*

> 注意：没有用于接收通知的 `FromISR` 函数，因为通知总是发送给任务，而中断不与任何任务关联。

### 10.3.2 xTaskNotifyGive() API 函数

`xTaskNotifyGive()` 直接向任务发送通知，并递增（加 1）接收任务的通知值。
调用 `xTaskNotifyGive()` 会将接收任务的通知状态设为 pending（若此前非 pending）。

`xTaskNotifyGive()` 作为比二值或计数信号量更轻量、更快的替代方法。


<a name="list10.1" title="Listing 10.1 The xTaskNotifyGive() API function prototype"></a>


```c
BaseType_t xTaskNotifyGive( TaskHandle_t xTaskToNotify );
BaseType_t xTaskNotifyGiveIndexed( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify );
```

***清单 10.1*** *xTaskNotifyGive() API 函数原型*

**xTaskNotifyGive()/xTaskNotifyGiveIndexed() 参数与返回值**

- `xTaskToNotify`

  被通知任务的句柄——可参考 `xTaskCreate()` API 的 `pxCreatedTask` 参数获取任务句柄。

- `uxIndexToNotify`

  通知数组索引。

- 返回值

  `xTaskNotifyGive()` 是调用 `xTaskNotify()` 的宏，宏传入的参数使得 `pdPASS`
  成为唯一可能的返回值。`xTaskNotify()` 将在本章后面介绍。

### 10.3.3 vTaskNotifyGiveFromISR() API 函数

`vTaskNotifyGiveFromISR()` 是 `xTaskNotifyGive()` 的中断安全版本，可在 ISR 中使用。


<a name="list10.2" title="Listing 10.2 The vTaskNotifyGiveFromISR() API function prototype"></a>


```c
void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
									  BaseType_t *pxHigherPriorityTaskWoken );
```

***清单 10.2*** *vTaskNotifyGiveFromISR() API 函数原型*

**vTaskNotifyGiveFromISR() 参数与返回值**

- `xTaskToNotify`

  被通知任务的句柄——可参考 `xTaskCreate()` API 的 `pxCreatedTask` 参数获取任务句柄。

- `pxHigherPriorityTaskWoken`

  若被通知任务正阻塞等待通知，则发送通知将使其离开 *Blocked* 状态。

  若 `vTaskNotifyGiveFromISR()` 使任务离开 *Blocked* 状态，且该任务优先级高于
  当前执行任务（被中断的任务），则 `vTaskNotifyGiveFromISR()` 会将
  `*pxHigherPriorityTaskWoken` 置为 `pdTRUE`。

  若 `vTaskNotifyGiveFromISR()` 将该值置为 `pdTRUE`，则应在退出中断前执行
  上下文切换，确保中断直接返回到最高优先级 *Ready* 任务。

  与所有中断安全 API 一样，`pxHigherPriorityTaskWoken` 在使用前必须初始化为 `pdFALSE`。

### 10.3.4 ulTaskNotifyTake() API 函数

`ulTaskNotifyTake()` 允许任务在 *Blocked* 状态等待通知值大于 0，并在返回前
对通知值执行递减（减 1）或清零。

`ulTaskNotifyTake()` 作为比二值或计数信号量更轻量、更快的替代方法。


<a name="list10.3" title="Listing 10.3 The ulTaskNotifyTake() API function prototype"></a>


```c
uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t
xTicksToWait );
```

***清单 10.3*** *ulTaskNotifyTake() API 函数原型*

**ulTaskNotifyTake() 参数与返回值**

- `xClearCountOnExit`

  若 `xClearCountOnExit` 为 `pdTRUE`，则在 `ulTaskNotifyTake()` 返回前
  将调用任务的通知值清零。

  若 `xClearCountOnExit` 为 `pdFALSE`，且调用任务通知值大于 0，
  则在 `ulTaskNotifyTake()` 返回前对通知值递减。

- `xTicksToWait`

  调用任务在 *Blocked* 状态等待通知值大于 0 的最长时间。

  阻塞时间以 tick 为单位，绝对时间取决于 tick 频率。
  可使用 `pdMS_TO_TICKS()` 将毫秒转换为 tick。

  若 FreeRTOSConfig.h 中 `INCLUDE_vTaskSuspend` 设为 1，将 `xTicksToWait` 设为
  `portMAX_DELAY` 会使任务无限期等待（无超时）。

- 返回值

  返回值为调用任务的通知值在被清零或递减 *之前* 的值，具体取决于
  `xClearCountOnExit`。

  若指定了阻塞时间（`xTicksToWait` 非 0）且返回值非 0，则可能调用任务进入 *Blocked*
  状态等待通知值大于 0，且在超时前收到通知。

  若指定了阻塞时间（`xTicksToWait` 非 0）且返回值为 0，则调用任务进入 *Blocked*
  状态等待通知值大于 0，但在超时前未发生。


<a name="example10.1" title="Example 10.1 Using a task notification in place of a semaphore, method 1"></a>
---
***示例 10.1*** *用任务通知替代信号量（方法 1）*

---

示例 7.1 使用二值信号量在 ISR 中解除任务阻塞，实现任务与中断同步。本示例复现
示例 7.1 的功能，但用“直接任务通知”替代二值信号量。

清单 10.4 展示与中断同步的任务实现。示例 7.1 中的 `xSemaphoreTake()` 被
`ulTaskNotifyTake()` 替代。

`ulTaskNotifyTake()` 的 `xClearCountOnExit` 设为 `pdTRUE`，因此在返回前
接收任务的通知值会被清零。于是需要在每次 `ulTaskNotifyTake()` 之间处理所有已就绪
事件。示例 7.1 使用二值信号量时，需要从硬件判断待处理事件数，这在某些场景并不现实。
示例 10.1 中，待处理事件数由 `ulTaskNotifyTake()` 返回。

在 `ulTaskNotifyTake` 调用之间发生的中断事件会被锁存到任务的通知值中，
若任务已有 pending 通知，则 `ulTaskNotifyTake()` 将立即返回。


<a name="list10.4" title="Listing 10.4 The implementation of the task to which the interrupt processing is deferred (the task that..."></a>


```c
/* The rate at which the periodic task generates software interrupts. */
const TickType_t xInterruptFrequency = pdMS_TO_TICKS( 500UL );

static void vHandlerTask( void *pvParameters )
{
	 /* xMaxExpectedBlockTime is set to be a little longer than the maximum
		 expected time between events. */
	 const TickType_t xMaxExpectedBlockTime = xInterruptFrequency +
															pdMS_TO_TICKS( 10 );
	 uint32_t ulEventsToProcess;

	 /* As per most tasks, this task is implemented within an infinite loop. */
	 for( ;; )
	 {
		  /* Wait to receive a notification sent directly to this task from the
			  interrupt service routine. */
		  ulEventsToProcess = ulTaskNotifyTake( pdTRUE, xMaxExpectedBlockTime );
		  if( ulEventsToProcess != 0 )
		  {
				/* To get here at least one event must have occurred. Loop here 
					until all the pending events have been processed (in this case,
					just print out a message for each event). */
				while( ulEventsToProcess > 0 )
				{
					 vPrintString( "Handler task - Processing event.\r\n" );
					 ulEventsToProcess--;
				}
		  }
		  else
		  {
				/* If this part of the function is reached then an interrupt did 
					not arrive within the expected time, and (in a real application)
					it may be necessary to perform some error recovery operations. */
		  }
	 }
}
```

***清单 10.4*** *示例 10.1 中延迟处理中断的任务实现（与中断同步的任务）*

用于产生软件中断的周期任务在中断生成前后都会输出消息，以便观察执行顺序。

清单 10.5 展示中断处理程序。该 ISR 几乎只做一件事：向延迟处理中断的任务直接发送通知。


<a name="list10.5" title="Listing 10.5 The implementation of the interrupt service routine used in Example 10.1"></a>


```c
static uint32_t ulExampleInterruptHandler( void )
{
	 BaseType_t xHigherPriorityTaskWoken;

	 /* The xHigherPriorityTaskWoken parameter must be initialized to pdFALSE as
		 it will get set to pdTRUE inside the interrupt safe API function if a
		 context switch is required. */
	 xHigherPriorityTaskWoken = pdFALSE;

	 /* Send a notification directly to the task to which interrupt processing 
		 is being deferred. */
	 vTaskNotifyGiveFromISR( /* The handle of the task to which the notification
										 is being sent. The handle was saved when the task
										 was created. */
									 xHandlerTask,

									 /* xHigherPriorityTaskWoken is used in the usual 
										 way. */
									 &xHigherPriorityTaskWoken );

	 /* Pass the xHigherPriorityTaskWoken value into portYIELD_FROM_ISR(). If 
		 xHigherPriorityTaskWoken was set to pdTRUE inside vTaskNotifyGiveFromISR()
		 then calling portYIELD_FROM_ISR() will request a context switch. If
		 xHigherPriorityTaskWoken is still pdFALSE then calling 
		 portYIELD_FROM_ISR() will have no effect. The implementation of
		 portYIELD_FROM_ISR() used by the Windows port includes a return statement,
		 which is why this function does not explicitly return a value. */
	 portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
}
```

***清单 10.5*** *示例 10.1 中使用的 ISR 实现*

示例 10.1 的输出如图 10.3 所示。正如预期，它与示例 7.1 的输出完全一致。
中断生成后 `vHandlerTask()` 立即进入 *Running* 状态，因此任务输出将周期任务输出分割。
图 10.4 给出进一步说明。


<a name="fig10.3" title="Figure 10.3 The output produced when Example 7.1 is executed"></a>
<a name="fig10.4" title="Figure 10.4 The sequence of execution when Example 10.1 is executed"></a>

* * *
![](media/image78.png)    
***图 10.3*** *示例 7.1 的输出*

![](media/image79.png)    
***图 10.4*** *示例 10.1 的执行顺序*
* * *

<a name="example10.2" title="Example 10.2 Using a task notification in place of a semaphore, method 2"></a>
---
***示例 10.2*** *用任务通知替代信号量（方法 2）*

---

在示例 10.1 中，`ulTaskNotifyTake()` 的 `xClearOnExit` 参数设为 `pdTRUE`。
示例 10.2 在示例 10.1 基础上略作修改，以演示 `xClearOnExit` 设为 `pdFALSE` 时的行为。

当 `xClearOnExit` 为 `pdFALSE` 时，`ulTaskNotifyTake()` 只会递减通知值，而不会清零。
因此通知计数等于已发生事件数与已处理事件数之差，这让 `vHandlerTask()` 的结构
可以简化两点：

1. 待处理事件数由通知值维护，无需使用本地变量。

2. 每次 `ulTaskNotifyTake()` 之间只需处理一个事件。

示例 10.2 的 `vHandlerTask()` 实现见清单 10.6。


<a name="list10.6" title="Listing 10.6 The implementation of the task to which the interrupt processing is deferred (the task..."></a>


```c
static void vHandlerTask( void *pvParameters )
{
	 /* xMaxExpectedBlockTime is set to be a little longer than the maximum 
		 expected time between events. */
	 const TickType_t xMaxExpectedBlockTime = xInterruptFrequency + 
															pdMS_TO_TICKS( 10 );

	 /* As per most tasks, this task is implemented within an infinite loop. */
	 for( ;; )
	 {
		  /* Wait to receive a notification sent directly to this task from the
			  interrupt service routine. The xClearCountOnExit parameter is now
			  pdFALSE, so the task's notification value will be decremented by
			  ulTaskNotifyTake(), and not cleared to zero. */
		  if( ulTaskNotifyTake( pdFALSE, xMaxExpectedBlockTime ) != 0 )
		  {
				/* To get here an event must have occurred. Process the event (in 
					this case just print out a message). */
				vPrintString( "Handler task - Processing event.\r\n" );
		  }
		  else
		  {
				/* If this part of the function is reached then an interrupt did 
					not arrive within the expected time, and (in a real application)
					it may be necessary to perform some error recovery operations. */
		  }
	 }
}
```

***清单 10.6*** *示例 10.2 中延迟处理中断任务的实现（与中断同步的任务）*

为演示目的，ISR 也被修改为每次中断发送多个任务通知，从而模拟高频多次中断。
示例 10.2 的 ISR 实现见清单 10.7。


<a name="list10.7" title="Listing 10.7 The implementation of the interrupt service routine used in Example 10.2"></a>


```c
static uint32_t ulExampleInterruptHandler( void )
{
	 BaseType_t xHigherPriorityTaskWoken;

	 xHigherPriorityTaskWoken = pdFALSE;

	 /* Send a notification to the handler task multiple times. The first
		 'give' will unblock the task, the following 'gives' are to demonstrate 
		 that the receiving task's notification value is being used to count 
		 (latch) events - allowing the task to process each event in turn. */
	 vTaskNotifyGiveFromISR( xHandlerTask, &xHigherPriorityTaskWoken );
	 vTaskNotifyGiveFromISR( xHandlerTask, &xHigherPriorityTaskWoken );
	 vTaskNotifyGiveFromISR( xHandlerTask, &xHigherPriorityTaskWoken );

	 portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
}
```

***清单 10.7*** *示例 10.2 中使用的 ISR 实现*

示例 10.2 的输出如图 10.5 所示。可见每次中断生成时 `vHandlerTask()` 会处理全部
三个事件。


<a name="fig10.5" title="Figure 10.5 The output produced when Example 10.2 is executed"></a>

* * *
![](media/image80.jpg)    
***图 10.5*** *示例 10.2 的输出*
* * *

### 10.3.5 xTaskNotify() 与 xTaskNotifyFromISR() API 函数

`xTaskNotify()` 是比 `xTaskNotifyGive()` 更强大的版本，可按以下方式更新接收任务的
通知值：

- 递增（加 1）接收任务通知值，此时 `xTaskNotify()` 等同于 `xTaskNotifyGive()`。

- 在接收任务通知值中置位一个或多个 bit，使通知值成为事件组的轻量、快速替代方案。

- 仅在接收任务自上次更新后已读取通知值的情况下，写入一个新数值。
  这使通知值具备与长度为 1 的队列相似的功能。

- 无论接收任务是否已读取通知值，都写入一个新数值。
  这使通知值具备与 `xQueueOverwrite()` 相似的功能，行为有时称为“邮箱（mailbox）”。

`xTaskNotify()` 比 `xTaskNotifyGive()` 更灵活、更强大，但因此也更复杂。

`xTaskNotifyFromISR()` 是 `xTaskNotify()` 的中断安全版本，可在 ISR 中使用，并带有
额外的 `pxHigherPriorityTaskWoken` 参数。

调用 `xTaskNotify()` 将始终把接收任务通知状态设为 pending（若此前非 pending）。


<a name="list10.8" title="Listing 10.8 Prototypes for the xTaskNotify() and xTaskNotifyFromISR() API functions"></a>


```c
BaseType_t xTaskNotify( TaskHandle_t xTaskToNotify,
								uint32_t ulValue,
								eNotifyAction eAction );

BaseType_t xTaskNotifyFromISR( TaskHandle_t xTaskToNotify,
										 uint32_t ulValue,
										 eNotifyAction eAction,
										 BaseType_t *pxHigherPriorityTaskWoken );
```

***清单 10.8*** *xTaskNotify() 与 xTaskNotifyFromISR() API 函数原型*

**xTaskNotify() 参数与返回值**

- `xTaskToNotify`

  被通知任务的句柄——可参考 `xTaskCreate()` API 的 `pxCreatedTask` 参数获取任务句柄。

- `ulValue`

  `ulValue` 的使用方式由 `eNotifyAction` 决定，见下文。

- `eNotifyAction`

  枚举类型，指定如何更新接收任务的通知值，见下文。

- 返回值

  `xTaskNotify()` 通常返回 `pdPASS`，*仅在下面说明的一个情况例外*。

**xTaskNotify() 的 eNotifyAction 参数取值及对接收任务通知值的影响**

- `eNoAction`

  仅将接收任务通知状态设为 pending，不更新通知值。`xTaskNotify()` 的 `ulValue`
  参数未使用。

  `eNoAction` 使任务通知成为二值信号量的更快、更轻量替代方案。

- `eSetBits`

  将接收任务通知值与 `xTaskNotify()` 的 `ulValue` 进行按位 OR。
  例如 `ulValue` 为 0x01 时，将置位接收任务通知值的 bit 0；
  `ulValue` 为 0x06（二进制 0110）时，将置位 bit 1 与 bit 2。

  `eSetBits` 使任务通知成为事件组的更快、更轻量替代方案。

- `eIncrement`

  递增接收任务通知值。`xTaskNotify()` 的 `ulValue` 参数未使用。

  `eIncrement` 使任务通知成为二值或计数信号量的更快、更轻量替代方案，
  等价于更简单的 `xTaskNotifyGive()`。

- `eSetValueWithoutOverwrite`

  若在调用 `xTaskNotify()` 前接收任务已有 pending 通知，则不执行任何操作，
  并返回 `pdFAIL`。

  若在调用前接收任务没有 pending 通知，则将通知值设为 `ulValue`。

- `eSetValueWithOverwrite`

  无论接收任务在调用前是否已有 pending 通知，都将通知值设为 `ulValue`。

### 10.3.6 xTaskNotifyWait() API 函数

`xTaskNotifyWait()` 是 `ulTaskNotifyTake()` 的增强版。它允许任务在通知状态尚未
pending 时，带可选超时等待通知变为 pending。`xTaskNotifyWait()` 提供在函数入口与
出口清除通知值指定 bit 的选项。


<a name="list10.9" title="Listing 10.9 The xTaskNotifyWait() API function prototype"></a>


```c
BaseType_t xTaskNotifyWait( uint32_t   ulBitsToClearOnEntry,
									 uint32_t   ulBitsToClearOnExit,
									 uint32_t   *pulNotificationValue,
									 TickType_t xTicksToWait );
```

***清单 10.9*** *xTaskNotifyWait() API 函数原型*

**xTaskNotifyWait() 参数与返回值**

- `ulBitsToClearOnEntry`

  若调用前该任务没有 pending 通知，则在函数入口将通知值中 `ulBitsToClearOnEntry`
  指定的 bit 清零。

  例如，`ulBitsToClearOnEntry` 为 0x01 时清除通知值 bit 0；
  `ulBitsToClearOnEntry` 设为 0xffffffff（`ULONG_MAX`）则清除全部 bit，使通知值清零。

- `ulBitsToClearOnExit`

  若任务因收到通知而退出 `xTaskNotifyWait()`，或在调用时已存在 pending 通知，
  则在函数退出前将通知值中 `ulBitsToClearOnExit` 指定的 bit 清零。

  清零发生在通知值保存到 `*pulNotificationValue` 之后（见下文 `pulNotificationValue`）。

  例如，`ulBitsToClearOnExit` 为 0x03 时，退出前会清除通知值 bit 0 与 bit 1。

  `ulBitsToClearOnExit` 设为 0xffffffff（`ULONG_MAX`）则清除全部 bit，使通知值清零。

- `pulNotificationValue`

  用于返回任务通知值。写入 `*pulNotificationValue` 的值是清除 `ulBitsToClearOnExit`
  指定位之前的通知值。

  `pulNotificationValue` 为可选参数，若不需要，可设为 NULL。

- `xTicksToWait`

  调用任务在 *Blocked* 状态等待通知状态变为 pending 的最长时间。

  阻塞时间以 tick 为单位，绝对时间取决于 tick 频率。
  可使用 `pdMS_TO_TICKS()` 将毫秒转换为 tick。

  若 FreeRTOSConfig.h 中 `INCLUDE_vTaskSuspend` 设为 1，将 `xTicksToWait` 设为
  `portMAX_DELAY` 会使任务无限期等待（无超时）。

- 返回值

  有两种可能返回值：

  - `pdTRUE`

	 表示 `xTaskNotifyWait()` 因收到通知而返回，或因调用时已有 pending 通知而返回。

	 若指定了阻塞时间（`xTicksToWait` 非 0），调用任务可能进入 *Blocked* 状态等待
	 通知状态变为 pending，但在超时前收到通知。

  - `pdFALSE`

	 表示 `xTaskNotifyWait()` 返回时未收到通知。

	 若 `xTicksToWait` 非 0，则调用任务会在 *Blocked* 状态等待通知状态变为 pending，
	 但在超时前未发生。

### 10.3.7 任务通知在外设驱动中的使用：UART 示例

外设驱动库提供对硬件接口的常见操作函数。例如 UART、SPI、ADC、以太网等外设
常有驱动库。驱动库函数通常包括外设初始化、发送数据、接收数据等。

某些外设操作耗时较长，例如高精度 ADC 转换、UART 发送大数据包。驱动库函数可通过
轮询（反复读取）外设状态寄存器判断完成，但这种轮询几乎总是浪费，因为在无任何有用
处理时会占用 100% 处理器时间。在多任务系统中尤其昂贵，因为轮询任务可能阻止低
优先级任务执行。

为避免浪费处理时间，RTOS 感知的高效驱动应基于中断，并允许发起耗时操作的任务
选择在 *Blocked* 状态等待操作完成。这样，在操作进行时低优先级任务可运行，
任务仅在可有效利用处理时间时才消耗处理时间。

RTOS 感知驱动常使用二值信号量将任务置于 *Blocked* 状态。清单 10.10 的伪代码
展示了在 UART 发送函数中使用该技术：

- `xUART` 为描述 UART 外设的结构体，保存状态信息。其 `xTxSemaphore` 成员为
  `SemaphoreHandle_t` 类型，假定已创建。

- `xUART_Send()` 不含互斥逻辑。若多个任务要使用 `xUART_Send()`，应用编写者需在
  应用层管理互斥，例如调用前先获取互斥量。

- `xSemaphoreTake()` 用于在启动 UART 发送后将任务置于 *Blocked* 状态。

- `xSemaphoreGiveFromISR()` 用于发送完成后（UART 发送完成中断触发时）解除阻塞。


<a name="list10.10" title="Listing 10.10 Pseudo code demonstrating how a binary semaphore can be used in a driver library transmit..."></a>


```c
/* Driver library function to send data to a UART. */

BaseType_t xUART_Send( xUART *pxUARTInstance, 
							  uint8_t *pucDataSource, 
							  size_t uxLength )
{
	 BaseType_t xReturn;

	 /* Ensure the UART's transmit semaphore is not already available by 
		 attempting to take the semaphore without a timeout. */
	 xSemaphoreTake( pxUARTInstance->xTxSemaphore, 0 );

	 /* Start the transmission. */
	 UART_low_level_send( pxUARTInstance, pucDataSource, uxLength );

	 /* Block on the semaphore to wait for the transmission to complete. If 
		 the semaphore is obtained then xReturn will get set to pdPASS. If the 
		 semaphore take operation times out then xReturn will get set to pdFAIL. 
		 Note that, if the interrupt occurs between UART_low_level_send() being 
		 called, and xSemaphoreTake() being called, then the event will be 
		 latched in the binary semaphore, and the call to xSemaphoreTake() will 
		 return immediately. */
	 xReturn = xSemaphoreTake( pxUARTInstance->xTxSemaphore, 
										pxUARTInstance->xTxTimeout );

	 return xReturn;
}
/*-----------------------------------------------------------*/

/* The service routine for the UART's transmit end interrupt, which executes 
	after the last byte has been sent to the UART. */
void xUART_TransmitEndISR( xUART *pxUARTInstance )
{
	 BaseType_t xHigherPriorityTaskWoken = pdFALSE;

	 /* Clear the interrupt. */
	 UART_low_level_interrupt_clear( pxUARTInstance );

	 /* Give the Tx semaphore to signal the end of the transmission. If a task 
		 is Blocked waiting for the semaphore then the task will be removed from
		 the Blocked state. */
	 xSemaphoreGiveFromISR( pxUARTInstance->xTxSemaphore, 
									&xHigherPriorityTaskWoken );
	 portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
}
```

***清单 10.10*** *在驱动发送函数中使用二值信号量的伪代码*

清单 10.10 所示方法可行且常用，但存在一些缺点：

- 库使用多个信号量，增加 RAM 占用。

- 信号量必须先创建才能使用，因此使用信号量的库必须先显式初始化。

- 信号量是通用对象，适用于多种场景；其内部逻辑允许多个任务等待同一信号量，
  并在信号量可用时以确定性方式选择一个任务解除阻塞。执行该逻辑需要时间，
  在清单 10.10 的场景中并不必要，因为不可能同时有多个任务等待同一信号量。

清单 10.11 展示如何使用任务通知替代二值信号量，以避免上述缺点。

> *注意：若库使用任务通知，库文档必须明确说明：调用库函数可能改变调用任务的通知状态与通知值。*

在清单 10.11 中：

- `xUART` 结构体的 `xTxSemaphore` 被替换为 `xTaskToNotify`。
  `xTaskToNotify` 为 `TaskHandle_t` 类型，用于保存等待 UART 操作完成的任务句柄。

- `xTaskGetCurrentTaskHandle()` 用于获取 *Running* 状态任务句柄。

- 库不创建任何 FreeRTOS 对象，因此无额外 RAM 开销，且无需显式初始化。

- 任务通知直接发送给等待 UART 操作完成的任务，因此无需执行多余逻辑。

`xUART` 结构体中的 `xTaskToNotify` 会在任务与 ISR 中被访问，因此必须考虑
处理器如何更新该值：

- 若 `xTaskToNotify` 可由一次内存写操作更新，则可在临界区之外更新，如清单 10.11。
  当 `xTaskToNotify` 为 32 位变量（`TaskHandle_t` 为 32 位类型）且处理器为 32 位时
  就属于这种情况。

- 若更新 `xTaskToNotify` 需要多次内存写操作，则必须在临界区中更新；否则 ISR 可能
  在其不一致状态下访问 `xTaskToNotify`。例如 `xTaskToNotify` 为 32 位变量而处理器
  为 16 位时，需要两次 16 位写操作才能更新 32 位。

在 FreeRTOS 内部，`TaskHandle_t` 是指针，因此 `sizeof( TaskHandle_t )` 始终等于
`sizeof( void * )`。


<a name="list10.11" title="Listing 10.11 Pseudo code demonstrating how a task notification can be used in a driver library transmit..."></a>


```c
/* Driver library function to send data to a UART. */
BaseType_t xUART_Send( xUART *pxUARTInstance, 
							  uint8_t *pucDataSource, 
							  size_t uxLength )
{
	 BaseType_t xReturn;

	 /* Save the handle of the task that called this function. The book text
		 contains notes as to whether the following line needs to be protected 
		 by a critical section or not. */
	 pxUARTInstance->xTaskToNotify = xTaskGetCurrentTaskHandle();

	 /* Ensure the calling task does not already have a notification pending by 
		 calling ulTaskNotifyTake() with the xClearCountOnExit parameter set to 
		 pdTRUE, and a block time of 0 (don't block). */
	 ulTaskNotifyTake( pdTRUE, 0 );

	 /* Start the transmission. */
	 UART_low_level_send( pxUARTInstance, pucDataSource, uxLength );

	 /* Block until notified that the transmission is complete. If the 
		 notification is received then xReturn will be set to 1 because the ISR 
		 will have incremented this task's notification value to 1 (pdTRUE). If 
		 the operation times out then xReturn will be 0 (pdFALSE) because this 
		 task's notification value will not have been changed since it was 
		 cleared to 0 above. Note that, if the ISR executes between the calls to
		 UART_low_level_send() and the call to ulTaskNotifyTake(), then the 
		 event will be latched in the task's notification value, and the call to 
		 ulTaskNotifyTake() will return immediately. */
	 xReturn = ( BaseType_t ) ulTaskNotifyTake( pdTRUE, 
															  pxUARTInstance->xTxTimeout );

	 return xReturn;
}
/*-----------------------------------------------------------*/

/* The ISR that executes after the last byte has been sent to the UART. */
void xUART_TransmitEndISR( xUART *pxUARTInstance )
{
	 BaseType_t xHigherPriorityTaskWoken = pdFALSE;

	 /* This function should not execute unless there is a task waiting to be 
		 notified. Test this condition with an assert. This step is not strictly
		 necessary, but will aid debugging. configASSERT() is described in 
		 section 12.2. */
	 configASSERT( pxUARTInstance->xTaskToNotify != NULL );

	 /* Clear the interrupt. */
	 UART_low_level_interrupt_clear( pxUARTInstance );

	 /* Send a notification directly to the task that called xUART_Send(). If 
		 the task is Blocked waiting for the notification then the task will be 
		 removed from the Blocked state. */
	 vTaskNotifyGiveFromISR( pxUARTInstance->xTaskToNotify,
									 &xHigherPriorityTaskWoken );

	 /* Now there are no tasks waiting to be notified. Set the xTaskToNotify 
		 member of the xUART structure back to NULL. This step is not strictly 
		 necessary but will aid debugging. */
	 pxUARTInstance->xTaskToNotify = NULL;
	 portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
}
```

***清单 10.11*** *在驱动发送函数中使用任务通知的伪代码*

任务通知也可在接收函数中替代信号量，清单 10.12 给出了 RTOS 感知 UART 接收函数的
伪代码。参考清单 10.12：

- `xUART_Receive()` 不包含互斥逻辑。若多个任务使用 `xUART_Receive()`，应用编写者需
  在应用层管理互斥，例如调用前先获取互斥量。

- UART 接收 ISR 将接收到的字符放入 RAM 缓冲区，`xUART_Receive()` 从缓冲区读出字符。

- `xUART_Receive()` 的 `uxWantedBytes` 指定要接收的字符数。若缓冲区字符不足，
  调用任务进入 *Blocked* 状态等待通知（缓冲区字符数增加）。`while()` 循环重复该流程，
  直到缓冲区字符足够或超时。

- 调用任务可能多次进入 *Blocked* 状态，因此阻塞时间需要根据已耗时间调整。
  该调整确保 `xUART_Receive()` 总耗时不超过 `xUART` 结构体 `xRxTimeout` 指定的超时。
  阻塞时间通过 FreeRTOS 辅助函数 `vTaskSetTimeOutState()` 与 `xTaskCheckForTimeOut()` 调整。


<a name="list10.12" title="Listing 10.12 Pseudo code demonstrating how a task notification can be used in a driver library receive..."></a>


```c
/* Driver library function to receive data from a UART. */

size_t xUART_Receive( xUART *pxUARTInstance, 
							 uint8_t *pucBuffer,
							 size_t uxWantedBytes )
{
	 size_t uxReceived = 0;
	 TickType_t xTicksToWait;
	 TimeOut_t xTimeOut;

	 /* Record the time at which this function was entered. */
	 vTaskSetTimeOutState( &xTimeOut );

	 /* xTicksToWait is the timeout value - it is initially set to the maximum 
		 receive timeout for this UART instance. */
	 xTicksToWait = pxUARTInstance->xRxTimeout;

	 /* Save the handle of the task that called this function. The book text 
		 contains notes as to whether the following line needs to be protected 
		 by a critical section or not. */
	 pxUARTInstance->xTaskToNotify = xTaskGetCurrentTaskHandle();

	 /* Loop until the buffer contains the wanted number of bytes, or a
		 timeout occurs. */
	 while( UART_bytes_in_rx_buffer( pxUARTInstance ) < uxWantedBytes )
	 {
		  /* Look for a timeout, adjusting xTicksToWait to account for the time
			  spent in this function so far. */
		  if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) != pdFALSE )
		  {
				/* Timed out before the wanted number of bytes were available, 
					exit the loop. */
				break;
		  }

		  /* The receive buffer does not yet contain the required amount of 
			  bytes. Wait for a maximum of xTicksToWait ticks to be notified that 
			  the receive interrupt service routine has placed more data into the 
			  buffer. It does not matter if the calling task already had a 
			  notification pending when it called this function, if it did, it
			  would just iteration around this while loop one extra time. */
		  ulTaskNotifyTake( pdTRUE, xTicksToWait );
	 }

	 /* No tasks are waiting for receive notifications, so set xTaskToNotify
		 back to NULL. The book text contains notes as to whether the following 
		 line needs to be protected by a critical section or not. */
	 pxUARTInstance->xTaskToNotify = NULL;

	 /* Attempt to read uxWantedBytes from the receive buffer into pucBuffer. 
		 The actual number of bytes read (which might be less than uxWantedBytes)
		 is returned. */
	 uxReceived = UART_read_from_receive_buffer( pxUARTInstance, 
																pucBuffer,
																uxWantedBytes );
	 return uxReceived;
}

/*-----------------------------------------------------------*/

/* The interrupt service routine for the UART's receive interrupt */
void xUART_ReceiveISR( xUART *pxUARTInstance )
{
	 BaseType_t xHigherPriorityTaskWoken = pdFALSE;

	 /* Copy received data into this UART's receive buffer and clear the
		 interrupt. */
	 UART_low_level_receive( pxUARTInstance );

	 /* If a task is waiting to be notified of the new data then notify it now. */
	 if( pxUARTInstance->xTaskToNotify != NULL )
	 {
		  vTaskNotifyGiveFromISR( pxUARTInstance->xTaskToNotify,
										  &xHigherPriorityTaskWoken );
		  portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
	 }
}
```

***清单 10.12*** *在驱动接收函数中使用任务通知的伪代码*

### 10.3.8 任务通知在外设驱动中的使用：ADC 示例

上一节展示了使用 `vTaskNotifyGiveFromISR()` 从 ISR 向任务发送通知。
`vTaskNotifyGiveFromISR()` 简单易用，但能力有限：只能发送无数据的通知事件，
无法携带数据。本节展示如何使用 `xTaskNotifyFromISR()` 发送包含数据的通知事件。
清单 10.13 的伪代码给出了 ADC 相关 ISR 的 RTOS 感知实现示例，其中：

- 假设 ADC 转换至少每 50ms 触发一次。

- `ADC_ConversionEndISR()` 为 ADC 转换完成中断 ISR，每次新 ADC 值可用时触发。

- `vADCTask()` 任务负责处理 ADC 输出值，任务句柄在创建时保存到 `xADCTaskToNotify`。

- `ADC_ConversionEndISR()` 使用 `xTaskNotifyFromISR()`，`eAction` 设为
  `eSetValueWithoutOverwrite`，向 `vADCTask()` 发送通知并把 ADC 结果写入通知值。

- `vADCTask()` 使用 `xTaskNotifyWait()` 等待新 ADC 值，并从通知值中读取转换结果。


<a name="list10.13" title="Listing 10.13 Pseudo code demonstrating how a task notification can be used to pass a value to a task"></a>


```c
/* A task that uses an ADC. */
void vADCTask( void *pvParameters )
{
	 uint32_t ulADCValue;
	 BaseType_t xResult;

	 /* The rate at which ADC conversions are triggered. */
	 const TickType_t xADCConversionFrequency = pdMS_TO_TICKS( 50 );

	 for( ;; )
	 {
		  /* Wait for the next ADC conversion result. */
		  xResult = xTaskNotifyWait(
						  /* The new ADC value will overwrite the old value, so there
							  is no need to clear any bits before waiting for the new 
							  notification value. */
						  0,
						  /* Future ADC values will overwrite the existing value, so
							  there is no need to clear any bits before exiting 
							  xTaskNotifyWait(). */
						  0,
						  /* The address of the variable into which the task's 
							  notification value (which holds the latest ADC 
							  conversion result) will be copied. */
						  &ulADCValue,
						  /* A new ADC value should be received every 
							  xADCConversionFrequency ticks. */
						  xADCConversionFrequency * 2 );

		  if( xResult == pdPASS )
		  {
				/* A new ADC value was received. Process it now. */
				ProcessADCResult( ulADCValue );
		  }
		  else
		  {
				/* The call to xTaskNotifyWait() did not return within the expected
					time, something must be wrong with the input that triggers the 
					ADC conversion, or with the ADC itself. Handle the error here. */
		  }
	 }
}

/*-----------------------------------------------------------*/

/* The interrupt service routine that executes each time an ADC conversion 
	completes. */
void ADC_ConversionEndISR( xADC *pxADCInstance )
{
	 uint32_t ulConversionResult;
	 BaseType_t xHigherPriorityTaskWoken = pdFALSE, xResult;

	 /* Read the new ADC value and clear the interrupt. */
	 ulConversionResult = ADC_low_level_read( pxADCInstance );

	 /* Send a notification, and the ADC conversion result, directly to
		 vADCTask(). */
	 xResult = xTaskNotifyFromISR( xADCTaskToNotify, /* xTaskToNotify parameter */
											 ulConversionResult, /* ulValue parameter */
											 eSetValueWithoutOverwrite, /* eAction parameter. */
											 &xHigherPriorityTaskWoken );

	 /* If the call to xTaskNotifyFromISR() returns pdFAIL then the task is not
		 keeping up with the rate at which ADC values are being generated. 
		 configASSERT() is described in section 11.2. */
	 configASSERT( xResult == pdPASS );
	 portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
}
```

***清单 10.13*** *使用任务通知向任务传递数值的伪代码*

### 10.3.9 任务通知在应用中的直接使用

本节通过一个假想应用进一步展示任务通知的强大能力，该应用包含以下功能：

- 应用通过缓慢的互联网连接与远端数据服务器通信，以发送数据并请求数据。
  后文将远端数据服务器称为 *云服务器*。

- 请求数据后，请求任务必须在 *Blocked* 状态等待所请求数据到达。

- 发送数据后，发送任务必须在 *Blocked* 状态等待云服务器确认数据正确接收。

软件设计示意见图 10.6。在图 10.6 中：

- 多条到云服务器的互联网连接处理被封装在一个 FreeRTOS 任务中。该任务在应用内
  充当代理服务器，称为 *服务器任务*。

- 应用任务调用 `CloudRead()` 读取云服务器数据。`CloudRead()` 不直接与云服务器通信，
  而是通过队列向服务器任务发送读取请求，并通过任务通知接收服务器任务返回的数据。

- 应用任务调用 `CloudWrite()` 写数据到云服务器。`CloudWrite()` 不直接与云服务器通信，
  而是通过队列向服务器任务发送写请求，并通过任务通知接收服务器任务返回的写结果。

`CloudRead()` 与 `CloudWrite()` 发送给服务器任务的结构体见清单 10.14。


<a name="fig10.6" title="Figure 10.6 The communication paths from the application tasks to the cloud server, and back again"></a>

* * *
![](media/image81.png)    
***图 10.6*** *应用任务与云服务器之间的通信路径*
* * *


<a name="list10.14" title="Listing 10.14 The structure and data type sent on a queue to the server task"></a>


```c
typedef enum CloudOperations
{
	 eRead, /* Send data to the cloud server. */
	 eWrite /* Receive data from the cloud server. */
} Operation_t;

typedef struct CloudCommand
{
	 Operation_t eOperation; /* The operation to perform (read or write). */
	 uint32_t ulDataID; /* Identifies the data being read or written. */
	 uint32_t ulDataValue; /* Only used when writing data to the cloud server. */
	 TaskHandle_t xTaskToNotify;/* The handle of the task performing the operation. */
} CloudCommand_t;
```

***清单 10.14*** *发送到服务器任务队列的结构体与数据类型*

`CloudRead()` 的伪代码见清单 10.15。该函数向服务器任务发送请求，然后调用
`xTaskNotifyWait()` 在 *Blocked* 状态等待服务器返回所请求数据。

清单 10.16 展示服务器任务如何处理读请求。当从云服务器收到数据后，服务器任务
通过 `xTaskNotify()`（`eAction` 设为 `eSetValueWithOverwrite`）解除应用任务阻塞
并发送数据。

清单 10.16 为简化场景，假设 `GetCloudData()` 不需要等待云服务器返回。


<a name="list10.15" title="Listing 10.15 The Implementation of the Cloud Read API Function"></a>


```c
/* ulDataID identifies the data to read. pulValue holds the address of the 
	variable into which the data received from the cloud server is to be written. */
BaseType_t CloudRead( uint32_t ulDataID, uint32_t *pulValue )
{
	 CloudCommand_t xRequest;
	 BaseType_t xReturn;

	 /* Set the CloudCommand_t structure members to be correct for this read
		 request. */
	 xRequest.eOperation = eRead; /* This is a request to read data. */
	 xRequest.ulDataID = ulDataID; /* A code that identifies the data to read. */
	 xRequest.xTaskToNotify = xTaskGetCurrentTaskHandle(); /* Handle of the
																				 calling task. */

	 /* Ensure there are no notifications already pending by reading the
		 notification value with a block time of 0, then send the structure to 
		 the server task. */
	 xTaskNotifyWait( 0, 0, NULL, 0 );
	 xQueueSend( xServerTaskQueue, &xRequest, portMAX_DELAY );

	 /* Wait for a notification from the server task. The server task writes
		 the value received from the cloud server directly into this task's 
		 notification value, so there is no need to clear any bits in the 
		 notification value on entry to or exit from the xTaskNotifyWait() 
		 function. The received value is written to *pulValue, so pulValue is
		 passed as the address to which the notification value is written. */
	 xReturn = xTaskNotifyWait( 0, /* No bits cleared on entry */
										 0, /* No bits to clear on exit */
										 pulValue, /* Notification value into *pulValue */
										 pdMS_TO_TICKS( 250 ) ); /* Wait 250ms maximum */

	 /* If xReturn is pdPASS, then the value was obtained. If xReturn is pdFAIL,
		 then the request timed out. */
	 return xReturn;
}
```

***清单 10.15*** *CloudRead API 函数实现*


<a name="list10.16" title="Listing 10.16 The Server Task Processing a Read Request"></a>


```c
void ServerTask( void *pvParameters )
{
	 CloudCommand_t xCommand;
	 uint32_t ulReceivedValue;

	 for( ;; )
	 {
		  /* Wait for the next CloudCommand_t structure to be received from a task */
		  xQueueReceive( xServerTaskQueue, &xCommand, portMAX_DELAY );

		  switch( xCommand.eOperation ) /* Was it a read or write request? */
		  {
				case eRead:

					 /* Obtain the requested data item from the remote cloud server */
					 ulReceivedValue = GetCloudData( xCommand.ulDataID );

					 /* Call xTaskNotify() to send both a notification and the value
						 received from the cloud server to the task that made the 
						 request. The handle of the task is obtained from the 
						 CloudCommand_t structure. */
					 xTaskNotify( xCommand.xTaskToNotify, /* The task's handle is in
																		  the structure */
									  ulReceivedValue, /* Cloud data sent as notification 
																 value */
									  eSetValueWithOverwrite );
					 break;

					 /* Other switch cases go here. */
		  }
	 }
}
```

***清单 10.16*** *服务器任务处理读请求*

`CloudWrite()` 的伪代码见清单 10.17。为演示目的，`CloudWrite()` 返回一个按位状态码，
状态码的每一位都有独立含义。清单 10.17 顶部的 `#define` 给出了四个示例状态位。

任务清除四个状态位，发送请求给服务器任务，然后调用 `xTaskNotifyWait()` 在
*Blocked* 状态等待状态通知。


<a name="list10.17" title="Listing 10.17 The Implementation of the Cloud Write API Function"></a>


```c
/* Status bits used by the cloud write operation. */
#define SEND_SUCCESSFUL_BIT ( 0x01 << 0 )
#define OPERATION_TIMED_OUT_BIT ( 0x01 << 1 )
#define NO_INTERNET_CONNECTION_BIT ( 0x01 << 2 )
#define CANNOT_LOCATE_CLOUD_SERVER_BIT ( 0x01 << 3 )

/* A mask that has the four status bits set. */
#define CLOUD_WRITE_STATUS_BIT_MASK ( SEND_SUCCESSFUL_BIT |
												  OPERATION_TIMED_OUT_BIT |
												  NO_INTERNET_CONNECTION_BIT |
												  CANNOT_LOCATE_CLOUD_SERVER_BIT )

uint32_t CloudWrite( uint32_t ulDataID, uint32_t ulDataValue )
{
	 CloudCommand_t xRequest;
	 uint32_t ulNotificationValue;

	 /* Set the CloudCommand_t structure members to be correct for this
		 write request. */
	 xRequest.eOperation = eWrite; /* This is a request to write data */
	 xRequest.ulDataID = ulDataID; /* A code that identifies the data being
												 written */
	 xRequest.ulDataValue = ulDataValue; /* Value of the data written to the
														 cloud server. */
	 xRequest.xTaskToNotify = xTaskGetCurrentTaskHandle(); /* Handle of the 
																				 calling task. */

	 /* Clear the three status bits relevant to the write operation by calling
		 xTaskNotifyWait() with the ulBitsToClearOnExit parameter set to
		 CLOUD_WRITE_STATUS_BIT_MASK, and a block time of 0. The current
		 notification value is not required, so the pulNotificationValue 
		 parameter is set to NULL. */
	 xTaskNotifyWait( 0, CLOUD_WRITE_STATUS_BIT_MASK, NULL, 0 );

	 /* Send the request to the server task. */
	 xQueueSend( xServerTaskQueue, &xRequest, portMAX_DELAY );

	 /* Wait for a notification from the server task. The server task writes
		 a bitwise status code into this task's notification value, which is 
		 written to ulNotificationValue. */
	 xTaskNotifyWait( 0, /* No bits cleared on entry. */
							CLOUD_WRITE_STATUS_BIT_MASK, /* Clear relevant bits to 0 on exit. */
							&ulNotificationValue, /* Notified value. */
							pdMS_TO_TICKS( 250 ) ); /* Wait a maximum of 250ms. */

	 /* Return the status code to the calling task. */
	 return ( ulNotificationValue & CLOUD_WRITE_STATUS_BIT_MASK );
}
```

***清单 10.17*** *CloudWrite API 函数实现*

服务器任务处理写请求的伪代码见清单 10.18。当数据发送到云服务器后，服务器任务通过
`xTaskNotify()`（`eAction` 设为 `eSetBits`）解除应用任务阻塞并发送按位状态码。
接收任务的通知值中只有 `CLOUD_WRITE_STATUS_BIT_MASK` 指定的位会被改变，因此接收任务
可用通知值中的其他位做其他用途。

清单 10.18 为简化场景，假设 `SetCloudData()` 不需要等待云服务器确认。


<a name="list10.18" title="Listing 10.18 The Server Task Processing a Send Request"></a>


```c
void ServerTask( void *pvParameters )
{
	 CloudCommand_t xCommand;
	 uint32_t ulBitwiseStatusCode;

	 for( ;; )
	 {
		  /* Wait for the next message. */
		  xQueueReceive( xServerTaskQueue, &xCommand, portMAX_DELAY );

		  /* Was it a read or write request? */
		  switch( xCommand.eOperation )
		  {
				case eWrite:

				/* Send the data to the remote cloud server. SetCloudData() returns
					a bitwise status code that only uses the bits defined by the
					CLOUD_WRITE_STATUS_BIT_MASK definition (shown in Listing 10.17). */
				ulBitwiseStatusCode = SetCloudData( xCommand.ulDataID,
																xCommand.ulDataValue );

				/* Send a notification to the task that made the write request. 
					The eSetBits action is used so any status bits set in 
					ulBitwiseStatusCode will be set in the notification value of 
					the task being notified. All the other bits remain unchanged. 
					The handle of the task is obtained from the CloudCommand_t
					structure. */
				xTaskNotify( xCommand.xTaskToNotify, /* The task's handle is in 
																	 the structure. */
								 ulBitwiseStatusCode,    /* Cloud data sent as 
																	 notification value. */
								 eSetBits );
				break;

				/* Other switch cases go here. */
		  }
	 }
}
```

***清单 10.18*** *服务器任务处理发送请求*
