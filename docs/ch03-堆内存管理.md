# 3 堆内存管理

## 3.1 简介

### 3.1.1 前置条件

成为一名合格的 C 程序员是使用 FreeRTOS 的前提，因此本章假设读者熟悉以下概念：

- 构建 C 工程的编译与链接阶段。
- 栈与堆的概念。
- 标准 C 库的 `malloc()` 与 `free()` 函数。

### 3.1.2 范围

本章覆盖：

- FreeRTOS 何时分配 RAM。
- FreeRTOS 提供的五种示例内存分配方案。
- 如何选择内存分配方案。

### 3.1.3 静态与动态内存分配的切换

后续章节将介绍任务、队列、信号量、事件组等内核对象。用于保存这些对象的 RAM
可以在编译时静态分配，也可以在运行时动态分配。动态分配可降低设计与规划成本，
简化 API，并最小化 RAM 占用。静态分配更具确定性，免去了处理分配失败的需要，
也消除了堆碎片的风险（即堆中总空闲内存充足但无法形成可用的连续块）。

使用静态内存创建内核对象的 FreeRTOS API 函数仅在 FreeRTOSConfig.h 中
`configSUPPORT_STATIC_ALLOCATION` 设为 1 时可用。使用动态内存创建内核对象的
FreeRTOS API 函数仅在 FreeRTOSConfig.h 中 `configSUPPORT_DYNAMIC_ALLOCATION`
设为 1 或未定义时可用。同时将两个常量都设为 1 是有效的。

关于 `configSUPPORT_STATIC_ALLOCATION` 的更多信息见 3.4 节《使用静态内存分配》。

### 3.1.4 使用动态内存分配

动态内存分配是 C 语言编程概念，并非 FreeRTOS 或多任务所特有。它与 FreeRTOS
相关，是因为内核对象可以选择使用动态分配内存创建，同时通用的 C 库 `malloc()`
和 `free()` 函数可能由于以下一个或多个原因而不适用：

- 在小型嵌入式系统中并不总是可用。
- 实现相对庞大，占用宝贵的代码空间。
- 很少具有线程安全性。
- 不具确定性；执行时间会随调用而变化。
- 可能产生碎片（堆中总空闲足够，但无法形成可用连续块）。
- 会使链接器配置更复杂。
- 如果堆空间增长到与其他变量所用内存重叠，可能产生难以调试的错误。

### 3.1.5 动态内存分配的选项

早期版本的 FreeRTOS 使用内存池分配方案：在编译时预先分配不同大小的内存块池，
然后由内存分配函数返回内存块。尽管块分配在实时系统中很常见，但由于其在极小型
嵌入式系统中 RAM 利用率低而导致大量支持请求，因此从 FreeRTOS 中移除了。

FreeRTOS 目前将内存分配视为可移植层的一部分（而非核心代码的一部分）。
这是因为不同嵌入式系统对动态内存分配与时序的要求不同，单一算法只能适用于
部分应用。此外，将动态内存分配从核心代码中移除，使应用编写者在合适时能提供
自己的实现。

当 FreeRTOS 需要 RAM 时，会调用 `pvPortMalloc()` 而非 `malloc()`。同样，
当 FreeRTOS 释放先前分配的 RAM 时，会调用 `vPortFree()` 而非 `free()`。
`pvPortMalloc()` 与标准 C 库 `malloc()` 的函数原型相同，`vPortFree()` 与
标准 C 库 `free()` 的函数原型相同。

`pvPortMalloc()` 与 `vPortFree()` 是公开函数，因此也可在应用代码中调用。

FreeRTOS 提供了 `pvPortMalloc()` 与 `vPortFree()` 的五种示例实现，均在本章
介绍。FreeRTOS 应用可以使用其中一种示例实现，或提供自己的实现。

这五种示例分别定义在 heap\_1.c、heap\_2.c、heap\_3.c、heap\_4.c 与 heap\_5.c
源文件中，它们位于 FreeRTOS/Source/portable/MemMang 目录。


## 3.2 示例内存分配方案

### 3.2.1 Heap\_1

在小型、专用嵌入式系统中，常见做法是在启动 FreeRTOS 调度器之前仅创建任务与
其他内核对象。此时，内核只会在应用开始执行实时功能之前（动态地）分配内存，
且该内存会在应用生命周期内一直保持分配状态。这意味着所选分配方案无需考虑
确定性与碎片等更复杂的问题，而可以优先考虑代码规模与简单性等属性。

heap\_1.c 实现了 `pvPortMalloc()` 的一个极简版本，并未实现 `vPortFree()`。
从不删除任务或其他内核对象的应用有可能使用 heap\_1。某些商业关键与安全关键
系统虽然会禁止动态内存分配，但也可能采用 heap\_1。关键系统常因非确定性、
碎片化与分配失败的不确定性而禁止动态分配。heap\_1 始终具确定性且不会产生碎片。

heap\_1 对 `pvPortMalloc()` 的实现只是每次调用时将一个名为 FreeRTOS 堆的
`uint8_t` 数组细分为更小块。FreeRTOSConfig.h 中的 `configTOTAL_HEAP_SIZE`
常量设置该数组的字节大小。将堆实现为静态数组会让 FreeRTOS 看起来占用很多 RAM，
因为该堆成为 FreeRTOS 数据的一部分。

每个动态创建的任务会导致对 `pvPortMalloc()` 的两次调用：第一次用于分配
任务控制块（TCB），第二次用于分配任务栈。图 3.1 展示了 heap\_1 在创建任务时
如何细分该数组。

参见图 3.1：

- **A** 表示创建任何任务之前的数组——整个数组为空闲。

- **B** 表示创建一个任务后的数组。

- **C** 表示创建三个任务后的数组。


<a name="fig3.1" title="图 3.1 每次创建任务时从 heap\_1 数组分配 RAM"></a>

* * *
![](media/image05.png)
***图 3.1*** *每次创建任务时从 heap\_1 数组分配 RAM*
* * *


### 3.2.2 Heap\_2

heap\_2 已被功能更强的 heap\_4 取代。heap\_2 仅为向后兼容而保留在 FreeRTOS
分发包中，不建议用于新设计。

heap\_2.c 也通过细分由 `configTOTAL_HEAP_SIZE` 常量设置大小的数组来工作。
它使用最佳匹配算法分配内存，并且与 heap\_1 不同，确实实现了 `vPortFree()`。
同样，将堆实现为静态数组会让 FreeRTOS 看起来占用很多 RAM，因为堆成为
FreeRTOS 数据的一部分。

最佳匹配算法确保 `pvPortMalloc()` 使用大小最接近请求字节数的空闲内存块。
例如，考虑以下场景：

- 堆中有三个空闲内存块，大小分别为 5 字节、25 字节和 100 字节。
- `pvPortMalloc()` 请求 20 字节 RAM。

能容纳所请求字节数的最小空闲块是 25 字节块，因此 `pvPortMalloc()` 将 25 字节块
拆分为 20 字节块与 5 字节块，然后返回指向 20 字节块的指针[^2]。新的 5 字节块
仍可用于未来的 `pvPortMalloc()` 调用。

[^2]: 这是过度简化的描述，因为 heap\_2 会在堆区域中保存块大小信息，
因此两个拆分块的大小之和实际会小于 25。

与 heap\_4 不同，heap\_2 不会将相邻空闲块合并为更大的块，因此比 heap\_4 更易碎片化。
不过，如果已分配并随后释放的块总是相同大小，碎片就不是问题。

<a name="fig3.2" title="图 3.2 在创建与删除任务时从 heap\_2 数组分配和释放 RAM"></a>

* * *
![](media/image06.png)
***图 3.2*** *在创建与删除任务时从 heap\_2 数组分配和释放 RAM*
* * *

图 3.2 展示了在创建、删除并再次创建任务时最佳匹配算法的工作方式。参见图 3.2：

- **A** 表示分配三个任务后的数组。数组顶部仍有一大块空闲内存。

- **B** 表示删除一个任务后的数组。顶部的大块空闲内存仍然存在。
	此时还出现了两个较小的空闲块，它们之前分别存放被删除任务的 TCB 和栈。

- **C** 表示再次创建一个任务后的情况。创建任务会在 `xTaskCreate()` API 函数
	内部触发两次 `pvPortMalloc()` 调用：一次分配新的 TCB，另一次分配任务栈。
	本书 3.4 节描述了 `xTaskCreate()`。

	每个 TCB 的大小相同，因此最佳匹配算法会复用曾用于被删除任务 TCB 的那块 RAM。

	如果新任务分配的栈大小与先前删除任务的栈大小相同，那么最佳匹配算法会复用
	曾用于被删除任务栈的那块 RAM。

	数组顶部较大的未分配块保持不变。

heap\_2 不具确定性，但通常比大多数标准库 `malloc()` 与 `free()` 实现更快。


### 3.2.3 Heap\_3

heap\_3.c 使用标准库 `malloc()` 与 `free()`，因此堆大小由链接器配置决定，
`configTOTAL_HEAP_SIZE` 常量不再使用。

heap\_3 通过在 `malloc()` 与 `free()` 执行期间临时挂起 FreeRTOS 调度器来保证
其线程安全。第 8 章《资源管理》涵盖线程安全与调度器挂起。


### 3.2.4 Heap\_4

与 heap\_1 和 heap\_2 一样，heap\_4 通过将数组细分为更小的块来工作。
同样，该数组是静态分配并由 `configTOTAL_HEAP_SIZE` 设定大小，使 FreeRTOS 看起来
占用大量 RAM，因为堆成为 FreeRTOS 数据的一部分。

heap\_4 使用首次匹配算法分配内存。与 heap\_2 不同，heap\_4 会将相邻空闲内存块
合并（coalesce）成一个更大的块，从而降低内存碎片风险。

首次匹配算法确保 `pvPortMalloc()` 使用第一个足以容纳请求字节数的空闲内存块。
例如，考虑以下场景：

- 堆中有三个空闲块，按其在数组中的顺序分别为 5 字节、200 字节与 100 字节。
- `pvPortMalloc()` 请求 20 字节 RAM。

第一个能够容纳请求字节数的空闲块是 200 字节块，因此 `pvPortMalloc()` 将其拆分
为 20 字节块与 180 字节块[^3]，然后返回指向 20 字节块的指针。新的 180 字节块
仍可用于未来的 `pvPortMalloc()` 调用。

[^3]: 这是过度简化的描述，因为 heap\_4 会在堆区域中保存块大小信息，
因此两个拆分块的大小之和实际会小于 200 字节。

heap\_4 会将相邻空闲块合并为更大的块，从而降低碎片风险，适合频繁分配与释放
不同大小 RAM 块的应用。


<a name="fig3.3" title="图 3.3 从 heap\_4 数组分配与释放 RAM"></a>

* * *
![](media/image07.png)
***图 3.3*** *从 heap\_4 数组分配与释放 RAM*
* * *

图 3.3 展示了 heap\_4 的首次匹配算法与内存合并的工作方式。参见图 3.3：

- **A** 表示创建三个任务后的数组。顶部仍有一大块空闲内存。

- **B** 表示删除一个任务后的数组。顶部的大块空闲内存仍然存在。
	现在在被删除任务的 TCB 与栈所在位置出现了另一块空闲内存。
	与 heap\_2 示例不同，heap\_4 会将原先分别存放 TCB 与栈的两块内存合并为
	一块更大的空闲块。

- **C** 表示创建一个 FreeRTOS 队列后的情况。本书 5.3 节描述了用于动态分配
	队列的 `xQueueCreate()` API 函数。`xQueueCreate()` 调用 `pvPortMalloc()`
	为队列分配 RAM。由于 heap\_4 使用首次匹配算法，`pvPortMalloc()` 会从第一个
	足够大的空闲 RAM 块中分配内存，该块在图 3.3 中正是删除任务后释放的内存。
	队列并未用尽该空闲块，因此该块被拆分为两部分，未使用的部分仍可供未来
	`pvPortMalloc()` 调用。

- **D** 表示直接从应用代码调用 `pvPortMalloc()` 的情况，而非通过 FreeRTOS API。
	用户分配块足够小，能放入第一个空闲块（该块位于队列占用的内存与其后 TCB
	占用的内存之间）。

	删除任务释放的内存现已被分成三块；第一块保存队列，第二块保存用户分配的内存，
	第三块仍为空闲。

- **E** 表示删除队列后的情况，该操作会自动释放队列所占内存。
	此时用户分配块两侧都有空闲内存。

- **F** 表示释放用户分配内存后的情况。用户分配块原先占用的内存与两侧空闲内存
	被合并为一块更大的空闲块。

heap\_4 不具确定性，但通常比大多数标准库 `malloc()` 与 `free()` 实现更快。


### 3.2.5 Heap\_5

heap\_5 使用与 heap\_4 相同的分配算法。不同于 heap\_4 只能从单一数组分配内存，
heap\_5 可以将多个彼此分离的内存区域合并为单一堆。若 FreeRTOS 所运行系统的 RAM
在内存映射中不是一个连续（中间无空洞）的块，heap\_5 会很有用。


### 3.2.6 初始化 heap\_5：vPortDefineHeapRegions() API 函数

`vPortDefineHeapRegions()` 通过指定组成 heap\_5 的每个独立内存区域的起始地址与
大小来初始化 heap\_5。heap\_5 是唯一需要显式初始化的示例堆分配方案，在调用
`vPortDefineHeapRegions()` 之前不能使用。这意味着任务、队列、信号量等内核对象
在调用 `vPortDefineHeapRegions()` 之前不能动态创建。


<a name="list3.1" title="清单 3.1 vPortDefineHeapRegions() API 函数原型"></a>


```c
void vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions );
```
***清单 3.1*** *vPortDefineHeapRegions() API 函数原型*


`vPortDefineHeapRegions()` 的唯一参数是一个 `HeapRegion_t` 结构体数组。
每个结构体定义一个内存块的起始地址与大小，这些内存块将组成堆——整个结构体数组
定义完整的堆空间。


<a name="list3.2" title="清单 3.2 HeapRegion\_t 结构体"></a>


```c
typedef struct HeapRegion
{
		/* 将作为堆一部分的内存块起始地址。*/
		uint8_t *pucStartAddress;

		/* 该内存块的大小（字节）。 */
		size_t xSizeInBytes;

} HeapRegion_t;
```
***清单 3.2*** *HeapRegion\_t 结构体*


**参数：**

- `pxHeapRegions`

	指向 `HeapRegion_t` 结构体数组起始位置的指针。每个结构体定义一个将成为堆的
	内存块的起始地址与大小。

	数组中的 `HeapRegion_t` 结构体必须按起始地址排序；描述最低起始地址的结构体
	必须是数组中的第一个，描述最高起始地址的结构体必须是数组中的最后一个。

	用一个 `HeapRegion_t` 结构体标记数组末尾，该结构体的 `pucStartAddress`
	成员设为 `NULL`。

例如，考虑图 3.4 **A** 所示的假想内存映射，其中包含三个独立的 RAM 块：RAM1、
RAM2 与 RAM3。假定可执行代码位于只读存储器中（图中未示）。


<a name="fig3.4" title="图 3.4 内存映射"></a>

* * *
![](media/image08.png)
***图 3.4*** *内存映射*
* * *

清单 3.3 显示了一个 `HeapRegion_t` 结构体数组，用于完整描述这三块 RAM。


<a name="list3.3" title="清单 3.3 共同描述 3 个 RAM 区域的 HeapRegion\_t 结构体数组"></a>


```c
/* 定义三块 RAM 区域的起始地址与大小。 */
#define RAM1_START_ADDRESS ( ( uint8_t * ) 0x00010000 )
#define RAM1_SIZE ( 64 * 1024 )

#define RAM2_START_ADDRESS ( ( uint8_t * ) 0x00020000 )
#define RAM2_SIZE ( 32 * 1024 )

#define RAM3_START_ADDRESS ( ( uint8_t * ) 0x00030000 )
#define RAM3_SIZE ( 32 * 1024 )

/* 创建 HeapRegion_t 定义数组：每个 RAM 区域对应一个条目，
	 并以一个地址为 NULL 的 HeapRegion_t 结构体作为数组结尾。
	 HeapRegion_t 结构体必须按起始地址顺序排列，
	 起始地址最低的条目必须放在最前。 */
const HeapRegion_t xHeapRegions[] =
{
		{ RAM1_START_ADDRESS, RAM1_SIZE },
		{ RAM2_START_ADDRESS, RAM2_SIZE },
		{ RAM3_START_ADDRESS, RAM3_SIZE },
		{ NULL,               0         } /* 标记数组结束。 */
};

int main( void )
{
		/* 初始化 heap_5。 */
		vPortDefineHeapRegions( xHeapRegions );

		/* 在此添加应用代码。 */
}
```
***清单 3.3*** *共同描述 3 个 RAM 区域的 HeapRegion\_t 结构体数组*


尽管清单 3.3 正确描述了 RAM，但它并不实用，因为它将所有 RAM 都分配给了堆，
从而没有剩余 RAM 可供其他变量使用。

构建过程的链接阶段为每个变量分配 RAM 地址。可用于链接器分配的 RAM 通常由链接器
配置文件（如链接脚本）描述。在图 3.4 **B** 中，假定链接脚本包含 RAM1 的信息，
但未包含 RAM2 或 RAM3 的信息。结果是，链接器将变量放置在 RAM1 中，使得只有
RAM1 中地址 0x0001nnnn 以上的部分可供 heap\_5 使用。0x0001nnnn 的实际值取决于
应用中所有变量的总大小。链接器未使用 RAM2 与 RAM3，从而使 RAM2 与 RAM3 的全部
可供 heap\_5 使用。

清单 3.3 中的代码会导致 heap\_5 在地址 0x0001nnnn 以下分配的 RAM 与用于存放
变量的 RAM 重叠。如果将 `xHeapRegions[]` 数组中第一个 `HeapRegion_t` 结构体的
起始地址设置为 0x0001nnnn，而不是 0x00010000，则堆将不会与链接器使用的 RAM
重叠。然而，这并不是推荐的解决方案，因为：

- 起始地址可能不易确定。
- 链接器使用的 RAM 量可能在后续构建中变化，从而需要更新 `HeapRegion_t`
	结构体中使用的起始地址。
- 构建工具无法获知，也无法警告应用编写者，当链接器使用的 RAM 与 heap\_5 使用的
	RAM 发生重叠时。

清单 3.4 展示了更便捷且可维护的示例。它声明了一个名为 `ucHeap` 的数组。
`ucHeap` 是普通变量，因此被链接器放入 RAM1 的数据区。`xHeapRegions` 数组中的
第一个 `HeapRegion_t` 结构体描述了 `ucHeap` 的起始地址和大小，因此 `ucHeap`
成为 heap\_5 管理的内存的一部分。`ucHeap` 的大小可以增大，直到链接器使用的 RAM
占用了 RAM1 的全部空间，如图 3.4 **C** 所示。


<a name="list3.4" title="清单 3.4 描述 RAM2、RAM3 全部以及 RAM1 部分的 HeapRegion\_t 结构体数组"></a>

```c
/* 定义未被链接器使用的两块 RAM 区域的起始地址与大小。 */
#define RAM2_START_ADDRESS ( ( uint8_t * ) 0x00020000 )
#define RAM2_SIZE ( 32 * 1024 )

#define RAM3_START_ADDRESS ( ( uint8_t * ) 0x00030000 )
#define RAM3_SIZE ( 32 * 1024 )

/* 声明一个将成为 heap_5 所用堆一部分的数组。
	 该数组会被链接器放置在 RAM1 中。 */
#define RAM1_HEAP_SIZE ( 30 * 1024 )
static uint8_t ucHeap[ RAM1_HEAP_SIZE ];

/* 创建 HeapRegion_t 定义数组。与清单 3.3 不同，
	 当时第一个条目描述了 RAM1 的全部，因此 heap_5 会使用整个 RAM1；
	 这里第一个条目仅描述 ucHeap 数组，因此 heap_5 只会使用包含 ucHeap 的那部分 RAM1。
	 HeapRegion_t 结构体仍必须按起始地址顺序排列，
	 起始地址最低的条目必须放在最前。 */

const HeapRegion_t xHeapRegions[] =
{
		{ ucHeap,             RAM1_HEAP_SIZE },
		{ RAM2_START_ADDRESS, RAM2_SIZE },
		{ RAM3_START_ADDRESS, RAM3_SIZE },
		{ NULL,               0 }           /* 标记数组结束。 */
};
```
***清单 3.4*** *描述 RAM2、RAM3 全部以及 RAM1 部分的 HeapRegion\_t 结构体数组*


清单 3.4 中示例的优点包括：

- 无需使用硬编码的起始地址。
- `HeapRegion_t` 结构体中的地址由链接器自动设置，因此即便链接器在后续构建中
	使用的 RAM 量发生变化，该地址仍然正确。
- heap\_5 分配的 RAM 不可能与链接器放入 RAM1 的数据重叠。
- 如果 `ucHeap` 过大，应用将无法链接。


## 3.3 与堆相关的工具函数与宏

### 3.3.1 定义堆的起始地址

heap\_1、heap\_2 与 heap\_4 从一个静态分配的数组中分配内存，该数组由
`configTOTAL_HEAP_SIZE` 指定大小。本节将这些方案统称为 heap\_n。

有时需要将堆放置在特定内存地址。例如，动态创建任务的栈来自堆，因此可能需要
将堆放在内部高速内存而不是外部慢速内存中。（参见下文“小节：将任务栈放在快速
内存中”，其中介绍另一种为任务栈分配快速内存的方法。）
`configAPPLICATION_ALLOCATED_HEAP` 编译期配置常量允许应用声明该数组，以替代
原本在 heap\_n.c 源文件中的声明。将数组声明在应用代码中可让应用编写者指定其
起始地址。

如果在 FreeRTOSConfig.h 中将 `configAPPLICATION_ALLOCATED_HEAP` 设为 1，
使用 FreeRTOS 的应用必须分配一个名为 `ucHeap` 的 `uint8_t` 数组，并将其大小
设置为 `configTOTAL_HEAP_SIZE`。

将变量放在特定内存地址的语法依赖于所用编译器，请参考编译器文档。
以下给出两个编译器的示例：

- 清单 3.5 展示了 GCC 编译器的语法，用于声明该数组并将其放入名为 `.my_heap`
	的内存段。
- 清单 3.6 展示了 IAR 编译器的语法，用于声明该数组并将其放置在绝对地址
	0x20000000。


<a name="list3.5" title="清单 3.5 使用 GCC 语法声明 heap\_4 使用的数组，并将其放入名为 .my\_heap 的内存段"></a>


```c
uint8_t ucHeap[ configTOTAL_HEAP_SIZE ] __attribute__ ( ( section( ".my_heap" ) ) );
```
***清单 3.5*** *使用 GCC 语法声明 heap\_4 使用的数组，并将其放入名为 .my\_heap 的内存段*



<a name="list3.6" title="清单 3.6 使用 IAR 语法声明 heap\_4 使用的数组，并将其放置在绝对地址 0x20000000"></a>


```c
uint8_t ucHeap[ configTOTAL_HEAP_SIZE ] @ 0x20000000;
```
***清单 3.6*** *使用 IAR 语法声明 heap\_4 使用的数组，并将其放置在绝对地址 0x20000000*



### 3.3.2 xPortGetFreeHeapSize() API 函数

`xPortGetFreeHeapSize()` API 函数返回函数被调用时堆中仍空闲的字节数。
它不提供堆碎片信息。

`xPortGetFreeHeapSize()` 未在 heap\_3 中实现。


<a name="list3.7" title="清单 3.7 xPortGetFreeHeapSize() API 函数原型"></a>


```c
size_t xPortGetFreeHeapSize( void );
```
***清单 3.7*** *xPortGetFreeHeapSize() API 函数原型*


**返回值：**

- `xPortGetFreeHeapSize()` 返回调用时堆中未分配的字节数。


### 3.3.3 xPortGetMinimumEverFreeHeapSize() API 函数

`xPortGetMinimumEverFreeHeapSize()` API 函数返回自 FreeRTOS 应用开始执行以来，
堆中曾出现过的最小未分配字节数。

`xPortGetMinimumEverFreeHeapSize()` 的返回值反映应用距离耗尽堆空间曾经有多近。
例如，如果该函数返回 200，那么自应用启动以来，曾有某个时刻距离耗尽堆空间只剩
200 字节。

`xPortGetMinimumEverFreeHeapSize()` 还可用于优化堆大小。例如，若在执行已知
堆使用量最高的代码后，该函数返回 2000，则可将 `configTOTAL_HEAP_SIZE`
最多减少 2000 字节。

`xPortGetMinimumEverFreeHeapSize()` 仅在 heap\_4 与 heap\_5 中实现。


<a name="list3.8" title="清单 3.8 xPortGetMinimumEverFreeHeapSize() API 函数原型"></a>


```c
size_t xPortGetMinimumEverFreeHeapSize( void );
```
***清单 3.8*** *xPortGetMinimumEverFreeHeapSize() API 函数原型*


**返回值：**

- `xPortGetMinimumEverFreeHeapSize()` 返回自 FreeRTOS 应用开始执行以来，
	堆中出现过的最小未分配字节数。


### 3.3.4 vPortGetHeapStats() API 函数

heap\_4 与 heap\_5 实现了 `vPortGetHeapStats()`，该函数仅通过引用传入
`HeapStats_t` 结构体并填充其成员。

清单 3.9 显示 `vPortGetHeapStats()` 的函数原型。清单 3.10 显示 `HeapStats_t`
结构体成员。


<a name="list3.9" title="清单 3.9 vPortGetHeapStatus() API 函数原型"></a>


```c
void vPortGetHeapStats( HeapStats_t *xHeapStats );
```
***清单 3.9*** *vPortGetHeapStatus() API 函数原型*



<a name="list3.10" title="清单 3.10 HeapStatus\_t() 结构体"></a>


```c
/* vPortGetHeapStats() 函数原型。 */
void vPortGetHeapStats( HeapStats_t *xHeapStats );

/* HeapStats_t 结构体定义，所有大小均以字节为单位。 */
typedef struct xHeapStats
{
		/* 当前可用堆总大小——为所有空闲块大小之和，
			 而非最大可用块的大小。 */
		size_t xAvailableHeapSpaceInBytes;

		/* 调用 vPortGetHeapStats() 时，堆中最大空闲块的大小。 */
		size_t xSizeOfLargestFreeBlockInBytes;

		/* 调用 vPortGetHeapStats() 时，堆中最小空闲块的大小。 */
		size_t xSizeOfSmallestFreeBlockInBytes;

		/* 调用 vPortGetHeapStats() 时，堆中空闲内存块的数量。 */
		size_t xNumberOfFreeBlocks;

		/* 系统启动以来堆中出现过的最小总空闲内存量（所有空闲块之和）。 */
		size_t xMinimumEverFreeBytesRemaining;

		/* pvPortMalloc() 成功返回有效内存块的调用次数。 */
		size_t xNumberOfSuccessfulAllocations;

		/* vPortFree() 成功释放内存块的调用次数。 */
		size_t xNumberOfSuccessfulFrees;
} HeapStats_t;
```
***清单 3.10*** *HeapStatus\_t() 结构体*



### 3.3.5 收集按任务的堆使用统计

应用编写者可使用以下 trace 宏收集按任务统计的堆使用数据：
- `traceMALLOC`
- `traceFREE`

清单 3.11 展示了使用这些 trace 宏收集按任务堆使用统计的一种实现示例。

<a name="list3.11" title="清单 3.11 收集按任务堆使用统计"></a>


```c
#define mainNUM_ALLOCATION_ENTRIES          512
#define mainNUM_PER_TASK_ALLOCATION_ENTRIES 32

/*-----------------------------------------------------------*/

/*
 * +-----------------+--------------+----------------+-------------------+
 * |    分配任务     |   条目占用   |   分配大小     |   分配指针        |
 * +-----------------+--------------+----------------+-------------------+
 * |                 |              |                |                   |
 * +-----------------+--------------+----------------+-------------------+
 * |                 |              |                |                   |
 * +-----------------+--------------+----------------+-------------------+
 */
typedef struct AllocationEntry
{
		BaseType_t xInUse;
		TaskHandle_t xAllocatingTaskHandle;
		size_t uxAllocatedSize;
		void * pvAllocatedPointer;
} AllocationEntry_t;

AllocationEntry_t xAllocationEntries[ mainNUM_ALLOCATION_ENTRIES ];

/*
 * +------+-----------------------+----------------------+
 * | 任务 |   当前持有内存        |   最大曾持有内存     |
 * +------+-----------------------+----------------------+
 * |      |                       |                      |
 * +------+-----------------------+----------------------+
 * |      |                       |                      |
 * +------+-----------------------+----------------------+
 */
typedef struct PerTaskAllocationEntry
{
		TaskHandle_t xTask;
		size_t uxMemoryCurrentlyHeld;
		size_t uxMaxMemoryEverHeld;
} PerTaskAllocationEntry_t;

PerTaskAllocationEntry_t xPerTaskAllocationEntries[ mainNUM_PER_TASK_ALLOCATION_ENTRIES ];

/*-----------------------------------------------------------*/

void TracepvPortMalloc( size_t uxAllocatedSize, void * pv )
{
		size_t i;
		TaskHandle_t xAllocatingTaskHandle;
		AllocationEntry_t * pxAllocationEntry = NULL;
		PerTaskAllocationEntry_t * pxPerTaskAllocationEntry = NULL;

		if( xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED )
		{
				xAllocatingTaskHandle = xTaskGetCurrentTaskHandle();

				for( i = 0; i < mainNUM_ALLOCATION_ENTRIES; i++ )
				{
						if( xAllocationEntries[ i ].xInUse == pdFALSE )
						{
								pxAllocationEntry = &( xAllocationEntries[ i ] );
								break;
						}
				}

				/* 每任务表中是否已经有条目？ */
				for( i = 0; i < mainNUM_PER_TASK_ALLOCATION_ENTRIES; i++ )
				{
						if( xPerTaskAllocationEntries[ i ].xTask == xAllocatingTaskHandle )
						{
								pxPerTaskAllocationEntry = &( xPerTaskAllocationEntries[ i ] );
								break;
						}
				}

				/* 每任务表中还没有条目，查找空槽位。 */
				if( pxPerTaskAllocationEntry == NULL )
				{
						for( i = 0; i < mainNUM_PER_TASK_ALLOCATION_ENTRIES; i++ )
						{
								if( xPerTaskAllocationEntries[ i ].xTask == NULL )
								{
										pxPerTaskAllocationEntry = &( xPerTaskAllocationEntries[ i ] );
										break;
								}
						}
				}

				/* 确保两张表中都有可用空间。 */
				configASSERT( pxAllocationEntry != NULL );
				configASSERT( pxPerTaskAllocationEntry != NULL );

				pxAllocationEntry->xAllocatingTaskHandle = xAllocatingTaskHandle;
				pxAllocationEntry->xInUse = pdTRUE;
				pxAllocationEntry->uxAllocatedSize = uxAllocatedSize;
				pxAllocationEntry->pvAllocatedPointer = pv;

				pxPerTaskAllocationEntry->xTask = xAllocatingTaskHandle;
				pxPerTaskAllocationEntry->uxMemoryCurrentlyHeld += uxAllocatedSize;
				if( pxPerTaskAllocationEntry->uxMaxMemoryEverHeld < pxPerTaskAllocationEntry->uxMemoryCurrentlyHeld )
				{
						pxPerTaskAllocationEntry->uxMaxMemoryEverHeld = pxPerTaskAllocationEntry->uxMemoryCurrentlyHeld;
				}
		}
}
/*-----------------------------------------------------------*/

void TracevPortFree( void * pv )
{
		size_t i;
		AllocationEntry_t * pxAllocationEntry = NULL;
		PerTaskAllocationEntry_t * pxPerTaskAllocationEntry = NULL;

		for( i = 0; i < mainNUM_ALLOCATION_ENTRIES; i++ )
		{
				if( ( xAllocationEntries[ i ].xInUse == pdTRUE ) &&
						( xAllocationEntries[ i ].pvAllocatedPointer == pv ) )
				{
						pxAllocationEntry = &( xAllocationEntries [ i ] );
						break;
				}
		}

		/* 尝试释放一个从未分配过的内存块。 */
		configASSERT( pxAllocationEntry != NULL );

		for( i = 0; i < mainNUM_PER_TASK_ALLOCATION_ENTRIES; i++ )
		{
				if( xPerTaskAllocationEntries[ i ].xTask == pxAllocationEntry->xAllocatingTaskHandle )
				{
						pxPerTaskAllocationEntry = &( xPerTaskAllocationEntries[ i ] );
						break;
				}
		}

		/* 每任务表中必须存在对应条目。 */
		configASSERT( pxPerTaskAllocationEntry != NULL );

		pxPerTaskAllocationEntry->uxMemoryCurrentlyHeld -= pxAllocationEntry->uxAllocatedSize;

		pxAllocationEntry->xInUse = pdFALSE;
		pxAllocationEntry->xAllocatingTaskHandle = NULL;
		pxAllocationEntry->uxAllocatedSize = 0;
		pxAllocationEntry->pvAllocatedPointer = NULL;
}
/*-----------------------------------------------------------*/

/* 以下内容放入 FreeRTOSConfig.h： */
extern void TracepvPortMalloc( size_t uxAllocatedSize, void * pv );
extern void TracevPortFree( void * pv );

#define traceMALLOC( pvReturn, xAllocatedBlockSize ) \
TracepvPortMalloc( xAllocatedBlockSize, pvReturn )

#define traceFREE( pv, xAllocatedBlockSize ) \
TracevPortFree( pv )
```
***清单 3.11*** *收集按任务堆使用统计*

### 3.3.6 Malloc 失败钩子函数

与标准库 `malloc()` 类似，`pvPortMalloc()` 在无法分配所需 RAM 时会返回 NULL。
malloc 失败钩子（或回调）是一个由应用提供的函数，当 `pvPortMalloc()` 返回 NULL
时会被调用。要启用该回调，必须在 FreeRTOSConfig.h 中将
`configUSE_MALLOC_FAILED_HOOK` 设为 1。如果 malloc 失败钩子是在使用动态内存
分配创建内核对象的 FreeRTOS API 函数内部被调用，则该对象不会被创建。

如果在 FreeRTOSConfig.h 中将 `configUSE_MALLOC_FAILED_HOOK` 设为 1，应用必须
提供一个名为清单 3.12 所示、且具备相同原型的 malloc 失败钩子函数。应用可按
适合其需求的方式实现该函数。许多 FreeRTOS 示例将分配失败视为致命错误，但在
生产系统中更好的做法是优雅地从分配失败中恢复。


<a name="list3.12" title="清单 3.12 malloc 失败钩子函数名称与原型"></a>


```c
void vApplicationMallocFailedHook( void );
```
***清单 3.12*** *malloc 失败钩子函数名称与原型*



### 3.3.7 将任务栈放在快速内存中

由于任务栈读写频率很高，应放在快速内存中，但堆可能并不希望位于该位置。
FreeRTOS 使用 `pvPortMallocStack()` 与 `vPortFreeStack()` 宏，允许在 FreeRTOS
API 代码中分配的栈使用独立的内存分配器。如果希望任务栈来自由 `pvPortMalloc()`
管理的堆，则保持 `pvPortMallocStack()` 与 `vPortFreeStack()` 未定义，因为它们
默认分别调用 `pvPortMalloc()` 与 `vPortFree()`。否则，按清单 3.13 所示将宏定义
映射到应用提供的函数。


<a name="list3.13" title="清单 3.13 将 pvPortMallocStack() 与 vPortFreeStack() 宏映射到应用定义的内存分配器"></a>


```c
/* 由应用编写者提供的函数：从一块高速 RAM 区域分配与释放内存。 */

void *pvMallocFastMemory( size_t xWantedSize );

void vPortFreeFastMemory( void *pvBlockToFree );

/* 在 FreeRTOSConfig.h 中添加以下内容，将 pvPortMallocStack()
	 与 vPortFreeStack() 宏映射到使用高速内存的函数。 */

#define pvPortMallocStack( x ) pvMallocFastMemory( x )

#define vPortFreeStack( x ) vPortFreeFastMemory( x )
```
***清单 3.13*** *将 pvPortMallocStack() 与 vPortFreeStack() 宏映射到应用定义的内存分配器*



## 3.4 使用静态内存分配

3.1.4 节列出了一些动态内存分配的缺点。为避免这些问题，静态内存分配允许开发者
显式创建应用所需的每一个内存块。它具有以下优点：

- 所有所需内存在编译时即可确定。
- 所有内存具有确定性。

还有其他优点，但随之而来的也有一些复杂性。主要复杂性在于需要额外的用户函数
来管理部分内核内存，另一个复杂性是需要确保所有静态内存在合适的作用域中声明。


### 3.4.1 启用静态内存分配

在 FreeRTOSConfig.h 中将 `configSUPPORT_STATIC_ALLOCATION` 设为 1 即可启用静态
内存分配。启用后，内核将启用所有 `static` 版本的内核函数，包括：

- `xTaskCreateStatic`
- `xEventGroupCreateStatic`
- `xEventGroupGetStaticBuffer`
- `xQueueGenericCreateStatic`
- `xQueueGenericGetStaticBuffers`
- `xQueueCreateMutexStatic`
	- *若 `configUSE_MUTEXES` 为 1*
- `xQueueCreateCountingSemaphoreStatic`
	- *若 `configUSE_COUNTING_SEMAPHORES` 为 1*
- `xStreamBufferGenericCreateStatic`
- `xStreamBufferGetStaticBuffers`
- `xTimerCreateStatic`
	- *若 `configUSE_TIMERS` 为 1*
- `xTimerGetStaticBuffer`
	- *若 `configUSE_TIMERS` 为 1*

这些函数将在本书相应章节中解释。

### 3.4.2 静态内核内部内存

启用静态内存分配后，空闲任务与定时器任务（若启用）会使用由用户函数提供的静态
内存。这些用户函数包括：

- `vApplicationGetTimerTaskMemory`
	- *若 `configUSE_TIMERS` 为 1*
- `vApplicationGetIdleTaskMemory`


#### 3.4.2.1 vApplicationGetTimerTaskMemory

如果 `configSUPPORT_STATIC_ALLOCATION` 与 `configUSE_TIMERS` 都启用，内核会调用
`vApplicationGetTimerTaskMemory()`，以便应用为定时器任务 TCB 和栈创建并返回
内存缓冲区。该函数还会返回定时器任务栈的大小。清单 3.14 给出定时器任务内存函数
的建议实现。


<a name="list3.14" title="清单 3.14 vApplicationGetTimerTaskMemory 的典型实现"></a>


```c
void vApplicationGetTimerTaskMemory( StaticTask_t **ppxTimerTaskTCBBuffer,
																		 StackType_t **ppxTimerTaskStackBuffer,
																		 uint32_t *pulTimerTaskStackSize )
{
	/* 如果为定时器任务提供的缓冲区在本函数内声明，
	必须声明为 static——否则它们会被分配在栈上，
	函数返回后将不再存在。 */
	static StaticTask_t xTimerTaskTCB;
	static StackType_t uxTimerTaskStack[ configMINIMAL_STACK_SIZE ];

	/* 返回用于保存定时器任务状态的 StaticTask_t 结构体指针。 */
	*ppxTimerTaskTCBBuffer = &xTimerTaskTCB;

	/* 返回将用作定时器任务栈的数组。 */
	*ppxTimerTaskStackBuffer = uxTimerTaskStack;

	/* 返回 *ppxTimerTaskStackBuffer 指向数组的栈大小。
	注意栈大小以 StackType_t 的数量表示。 */
	*pulTimerTaskStackSize = sizeof(uxTimerTaskStack) / sizeof(*uxTimerTaskStack);
}
```
***清单 3.14*** *vApplicationGetTimerTaskMemory 的典型实现*


由于在包括 SMP 的任何系统中都只有一个定时器任务，解决定时器任务内存问题的一种
有效方案是在 `vApplicationGetTimeTaskMemory()` 函数中分配静态缓冲区，并将其指针
返回给内核。


#### 3.4.2.2 vApplicationGetIdleTaskMemory

当某个核心无可调度工作时，空闲任务将运行。空闲任务执行一些例行维护工作，
并在启用时触发用户的 `vTaskIdleHook()`。在对称多处理系统（SMP）中，其他核心还有
非维护型空闲任务，但这些任务在内部以 `configMINIMAL_STACK_SIZE` 字节静态分配。

调用 `vApplicationGetIdleTaskMemory` 允许应用为“主”空闲任务创建所需缓冲区。
清单 3.15 展示了使用静态局部变量创建所需缓冲区的 `vApplicationIdleTaskMemory()`
函数典型实现。


<a name="list3.15" title="清单 3.15 vApplicationGetIdleTaskMemory 的典型实现"></a>

```c
void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer,
																		StackType_t **ppxIdleTaskStackBuffer,
																		uint32_t *pulIdleTaskStackSize )
{
	static StaticTask_t xIdleTaskTCB;
	static StackType_t uxIdleTaskStack[ configMINIMAL_STACK_SIZE ];

	*ppxIdleTaskTCBBuffer = &xIdleTaskTCB;
	*ppxIdleTaskStackBuffer = uxIdleTaskStack;
	*pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
}
```
***清单 3.15*** *vApplicationGetIdleTaskMemory 的典型实现*


```
