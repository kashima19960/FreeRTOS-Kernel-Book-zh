# 6 软件定时器管理

## 6.1 章节介绍与范围

软件定时器用于在未来指定时间点，或以固定频率周期性地调度一个函数执行。
由软件定时器执行的函数称为软件定时器的回调函数。

软件定时器由 FreeRTOS 内核实现并受其控制，不需要硬件支持，也与硬件定时器或
硬件计数器无关。

注意，符合 FreeRTOS 以创新设计实现最高效率的理念，软件定时器不会占用处理时间，
除非软件定时器回调函数正在执行。

软件定时器功能是可选的。要启用软件定时器：

1. 将 FreeRTOS/Source/timers.c 作为工程的一部分进行构建。

2. 在应用的 FreeRTOSConfig.h 头文件中定义以下常量：

- `configUSE_TIMERS`

	在 FreeRTOSConfig.h 中将 `configUSE_TIMERS` 设为 1。

- `configTIMER_TASK_PRIORITY`

	设置定时器服务任务优先级，范围为 0 到 (`configMAX_PRIORITIES` - 1)。

- `configTIMER_QUEUE_LENGTH`

	设置定时器命令队列任意时刻可容纳的最大未处理命令数。

- `configTIMER_TASK_STACK_DEPTH`

	设置为定时器服务任务分配的栈大小（以字为单位，而非字节）。

### 6.1.1 范围

本章涵盖：

- 软件定时器与任务特性的差异。
- RTOS 守护任务。
- 定时器命令队列。
- 单次软件定时器与周期软件定时器的区别。
- 如何创建、启动、复位与修改软件定时器周期。


## 6.2 软件定时器回调函数

软件定时器回调函数以 C 函数实现，唯一特殊之处在于其原型：返回 `void`，且仅接受
一个软件定时器句柄作为参数。清单 6.1 展示该原型。


<a name="list" title="清单 6.1 软件定时器回调函数原型"></a>

```c
void ATimerCallback( TimerHandle_t xTimer );
```
***清单 6.1*** *软件定时器回调函数原型*

软件定时器回调函数从头执行到尾并正常返回，应保持短小，且不得进入 *Blocked* 状态。

> *注意：如后文所示，软件定时器回调函数在 FreeRTOS 调度器启动时自动创建的任务
> 上下文中执行。因此必须确保软件定时器回调函数不会调用会导致调用任务进入
> *Blocked* 状态的 FreeRTOS API。可以调用 `xQueueReceive()` 等函数，但仅在其
> `xTicksToWait` 参数（阻塞时间）为 0 时才可以。不可调用 `vTaskDelay()` 等函数，
> 因为 `vTaskDelay()` 总会让调用任务进入 *Blocked* 状态。*


## 6.3 软件定时器的属性与状态

### 6.3.1 软件定时器的周期

软件定时器的“周期”是指软件定时器启动与其回调函数执行之间的时间。

### 6.3.2 单次与自动重装载定时器

软件定时器有两种类型：

1. 单次定时器（One-shot）

	 启动后，单次定时器只执行一次回调函数。可手动重新启动，但不会自动重启。

1. 自动重装载定时器（Auto-reload）

	 启动后，自动重装载定时器每次到期都会自动重启，从而周期性执行回调函数。

图 6.1 展示单次定时器与自动重装载定时器的行为差异。虚线表示 tick 中断发生的时刻。


<a name="fig6.1" title="图 6.1 单次与自动重装载软件定时器的行为差异"></a>

* * *
![](media/image38.png)
***图 6.1*** *单次与自动重装载软件定时器的行为差异*
* * *

参见图 6.1：

- 定时器 1

	定时器 1 为单次定时器，周期为 6 个 tick。它在 t1 启动，因此 6 个 tick 后（t7）
	执行回调函数。由于是单次定时器，回调函数不会再次执行。

- 定时器 2

	定时器 2 为自动重装载定时器，周期为 5 个 tick。它在 t1 启动，因此在 t1 之后
	每隔 5 个 tick 执行回调函数。在图 6.1 中发生在 t6、t11 与 t16。


### 6.3.3 软件定时器状态

软件定时器可处于以下两种状态之一：

- 休眠（Dormant）

	休眠状态的软件定时器已存在，可通过句柄引用，但未运行，因此其回调函数不会执行。

- 运行（Running）

	运行状态的软件定时器在自进入 *Running* 状态以来经过一个周期时间，或自上次复位
	以来经过一个周期时间后执行回调函数。

图 6.2 与图 6.3 分别展示自动重装载定时器与单次定时器在休眠与运行状态之间的
转换。两者的关键差异在于定时器到期后的状态：自动重装载定时器执行回调后重新进入
运行状态；单次定时器执行回调后进入休眠状态。


<a name="fig6.2" title="图 6.2 自动重装载软件定时器状态与转换"></a>
<a name="fig6.3" title="图 6.3 单次软件定时器状态与转换"></a>

* * *
![](media/image39.png)
***图 6.2*** *自动重装载软件定时器状态与转换*

![](media/image40.png)
***图 6.3*** *单次软件定时器状态与转换*
* * *

`xTimerDelete()` API 函数用于删除定时器，且可在任意时刻调用。其原型见清单 6.2。


<a name="list6.2" title="清单 6.2 xTimerDelete() API 函数原型"></a>

```c
BaseType_t xTimerDelete( TimerHandle_t xTimer, TickType_t xTicksToWait );
```
***清单 6.2*** *xTimerDelete() API 函数原型*


**xTimerDelete() 参数与返回值**

- `xTimer`

	要删除的定时器句柄。

- `xTicksToWait`

	指定调用任务在 *Blocked* 状态中等待删除命令成功发送到定时器命令队列的时间（以 tick
	为单位），若在调用 `xTimerDelete()` 时队列已满则会等待。若 `xTimerDelete()` 在
	调度器启动前调用，则忽略 `xTicksToWait`。

- 返回值

	有两种可能返回值：

	- `pdPASS`

		表示删除命令已成功发送到定时器命令队列。

	- `pdFAIL`

		表示即使经过 `xBlockTime` 个 tick，仍无法将删除命令发送到定时器命令队列。


## 6.4 软件定时器的上下文

### 6.4.1 RTOS 守护（定时器服务）任务

所有软件定时器回调函数都在同一个 RTOS 守护（或“定时器服务”）任务的上下文中执行[^10]。

[^10]: 该任务曾称为“定时器服务任务”，因为最初仅用于执行软件定时器回调函数。
如今该任务也用于其他用途，因此使用更通用的名称“RTOS 守护任务”。

守护任务是标准 FreeRTOS 任务，会在调度器启动时自动创建。其优先级与栈大小分别由
`configTIMER_TASK_PRIORITY` 与 `configTIMER_TASK_STACK_DEPTH` 编译期配置常量设置，
这两个常量均定义在 FreeRTOSConfig.h 中。

软件定时器回调函数不得调用会导致调用任务进入 *Blocked* 状态的 FreeRTOS API，
否则守护任务将进入 *Blocked* 状态。


### 6.4.2 定时器命令队列

软件定时器 API 函数通过名为“定时器命令队列”的队列，将命令从调用任务发送到
守护任务，如图 6.4 所示。命令示例包括“启动定时器”“停止定时器”“复位定时器”。

定时器命令队列是标准 FreeRTOS 队列，会在调度器启动时自动创建。其长度由
FreeRTOSConfig.h 中的 `configTIMER_QUEUE_LENGTH` 编译期常量设置。


<a name="fig6.4" title="图 6.4 软件定时器 API 通过定时器命令队列与 RTOS 守护任务通信"></a>

* * *
![](media/image41.png)
***图 6.4*** *软件定时器 API 通过定时器命令队列与 RTOS 守护任务通信*
* * *


### 6.4.3 守护任务调度

守护任务与其他 FreeRTOS 任务一样被调度；只有当它是能够运行的最高优先级任务时，
才会处理命令或执行定时器回调函数。图 6.5 与图 6.6 展示 `configTIMER_TASK_PRIORITY`
设置对执行模式的影响。

图 6.5 显示当调用 `xTimerStart()` 的任务优先级高于守护任务时的执行模式。


<a name="fig6.5" title="图 6.5 调用 xTimerStart() 的任务优先级高于守护任务时的执行模式"></a>

* * *
![](media/image42.png)
***图 6.5*** *调用 xTimerStart() 的任务优先级高于守护任务时的执行模式*
* * *

参见图 6.5（Task 1 优先级高于守护任务，守护任务优先级高于空闲任务）：

1.  在 t1 时刻

		Task 1 处于 *Running* 状态，守护任务处于 *Blocked* 状态。

		当有命令发送到定时器命令队列时，守护任务会离开 *Blocked* 状态处理命令；当
		软件定时器到期时，守护任务会执行该定时器的回调函数。

1. 在 t2 时刻

	 Task 1 调用 `xTimerStart()`。

	 `xTimerStart()` 将命令发送到定时器命令队列，使守护任务离开 *Blocked* 状态。
	 Task 1 优先级高于守护任务，因此守护任务不会抢占 Task 1。

	 Task 1 仍处于 *Running* 状态，守护任务离开 *Blocked* 进入 *Ready* 状态。

1. 在 t3 时刻

	 Task 1 执行完 `xTimerStart()` API 函数。Task 1 从函数开始执行到结束都未离开
	 *Running* 状态。

1. 在 t4 时刻

	 Task 1 调用一个 API 使其进入 *Blocked* 状态。此时守护任务是 *Ready* 状态中
	 最高优先级任务，因此调度器选择守护任务进入 *Running* 状态，守护任务开始处理
	 Task 1 发送到定时器命令队列的命令。

	 > *注意：软件定时器到期的时间是从“启动定时器”命令发送到定时器命令队列的时刻
	 > 计算的，而不是从守护任务从队列中接收该命令的时刻计算。*

1. 在 t5 时刻

	 守护任务完成对 Task 1 命令的处理，并尝试从定时器命令队列接收更多数据。队列为空，
	 守护任务重新进入 *Blocked* 状态。之后如果有新命令发送到队列或软件定时器到期，
	 守护任务将再次离开 *Blocked* 状态。

	 此时空闲任务是 *Ready* 状态中最高优先级任务，调度器选择空闲任务进入
	 *Running* 状态。

图 6.6 展示与图 6.5 类似的场景，但这次守护任务优先级高于调用 `xTimerStart()` 的任务。


<a name="fig6.6" title="图 6.6 调用 xTimerStart() 的任务优先级低于守护任务时的执行模式"></a>

* * *
![](media/image43.png)
***图 6.6*** *调用 xTimerStart() 的任务优先级低于守护任务时的执行模式*
* * *

参见图 6.6（守护任务优先级高于 Task 1，Task 1 优先级高于空闲任务）：

1. 在 t1 时刻

	 与前例相同，Task 1 处于 *Running* 状态，守护任务处于 *Blocked* 状态。

1. 在 t2 时刻

	 Task 1 调用 `xTimerStart()`。

	 `xTimerStart()` 将命令发送到定时器命令队列，使守护任务离开 *Blocked* 状态。
	 守护任务优先级高于 Task 1，因此调度器选择守护任务进入 *Running* 状态。

	 Task 1 在完成 `xTimerStart()` 之前被守护任务抢占，此时处于 *Ready* 状态。

	 守护任务开始处理 Task 1 发送到定时器命令队列的命令。

1. 在 t3 时刻

	 守护任务完成对 Task 1 命令的处理并尝试从队列接收更多数据。队列为空，守护任务
	 重新进入 *Blocked* 状态。

	 Task 1 现在是 *Ready* 状态中最高优先级任务，因此调度器选择 Task 1 进入 *Running*
	 状态。

1. 在 t4 时刻

	 Task 1 在完成 `xTimerStart()` 之前被守护任务抢占，只有在重新进入 *Running* 状态
	 后才退出（返回）`xTimerStart()`。

1. 在 t5 时刻

	 Task 1 调用一个 API 导致其进入 *Blocked* 状态。此时空闲任务是 *Ready* 状态中
	 最高优先级任务，调度器选择空闲任务进入 *Running* 状态。

在图 6.5 的场景中，Task 1 发送命令到定时器命令队列与守护任务接收并处理该命令
之间存在时间差。在图 6.6 的场景中，守护任务在 Task 1 返回发送命令的函数之前就
已接收并处理命令。

发送到定时器命令队列的命令包含时间戳，用于补偿命令从应用任务发送到守护任务
处理之间的时间差。例如，当发送“启动定时器”命令以启动周期为 10 tick 的定时器时，
时间戳用于确保定时器在命令发送后 10 tick 到期，而不是在守护任务处理命令后 10 tick。


## 6.5 创建与启动软件定时器

### 6.5.1 xTimerCreate() API 函数

FreeRTOS 还提供 `xTimerCreateStatic()`，用于在编译期静态分配创建定时器所需内存。
软件定时器必须在使用前显式创建。

软件定时器通过 `TimerHandle_t` 类型变量引用。`xTimerCreate()` 用于创建软件定时器，
并返回指向该定时器的 `TimerHandle_t`。软件定时器创建时处于休眠状态。

软件定时器可以在调度器运行前创建，也可以在调度器启动后由任务创建。

[第 2.5 节：数据类型与编码风格指南](ch02-FreeRTOS%20内核分发包.md#25-数据类型与编码风格指南) 描述了
所用数据类型与命名规范。


<a name="list6.3" title="清单 6.3 xTimerCreate() API 函数原型"></a>

```c
TimerHandle_t xTimerCreate( const char * const pcTimerName,
														const TickType_t xTimerPeriodInTicks,
														const BaseType_t xAutoReload,
														void * const pvTimerID,
														TimerCallbackFunction_t pxCallbackFunction );
```
***清单 6.3*** *xTimerCreate() API 函数原型*

**xTimerCreate() 参数与返回值**

- `pcTimerName`

	定时器的描述性名称。FreeRTOS 不会使用该名称，仅作为调试辅助。
	使用可读名称识别定时器比使用句柄更容易。

- `xTimerPeriodInTicks`

	定时器周期（tick）。可使用 `pdMS_TO_TICKS()` 将毫秒转换为 tick。不能为 0。

- `xAutoReload`

	设为 `pdTRUE` 创建自动重装载定时器；设为 `pdFALSE` 创建单次定时器。

- `pvTimerID`

	每个软件定时器都有一个 ID 值。ID 为 `void *` 指针，应用可用于任何目的。
	当多个定时器共用同一回调函数时，ID 可用作定时器专用存储。本章示例将展示
	ID 的使用。

	`pvTimerID` 设置新建定时器的初始 ID 值。

- `pxCallbackFunction`

	软件定时器回调函数为符合清单 6.1 原型的 C 函数。`pxCallbackFunction` 是
	指向该回调函数的指针（即函数名）。

- 返回值

	若返回 NULL，表示堆内存不足，无法分配所需数据结构。

	若返回非 NULL，表示软件定时器创建成功，返回值即为定时器句柄。

	第 3 章提供了堆内存管理的更多信息。


### 6.5.2 xTimerStart() API 函数

`xTimerStart()` 用于启动处于休眠状态的软件定时器，或复位（重新启动）处于运行
状态的软件定时器。`xTimerStop()` 用于停止运行中的软件定时器。停止软件定时器等同
于将其转为休眠状态。

可以在调度器启动前调用 `xTimerStart()`，但定时器不会真正开始运行，直到调度器
启动时。

> *注意：切勿在中断服务例程中调用 `xTimerStart()`。应使用其中断安全版本
> `xTimerStartFromISR()`。*


<a name="list6.4" title="清单 6.4 xTimerStart() API 函数原型"></a>

```c
BaseType_t xTimerStart( TimerHandle_t xTimer, TickType_t xTicksToWait );
```
***清单 6.4*** *xTimerStart() API 函数原型*


**xTimerStart() 参数与返回值**

- `xTimer`

	要启动或复位的软件定时器句柄。该句柄由 `xTimerCreate()` 创建时返回。

- `xTicksToWait`

	`xTimerStart()` 使用定时器命令队列向守护任务发送“启动定时器”命令。`xTicksToWait`
	指定调用任务在队列已满时等待可用空间的最长时间（以 tick 为单位）。

	若 `xTicksToWait` 为 0 且队列已满，则 `xTimerStart()` 立即返回。

	阻塞时间以 tick 周期表示，绝对时间取决于 tick 频率。可使用 `pdMS_TO_TICKS()` 将
	毫秒转换为 tick。

	若 FreeRTOSConfig.h 中 `INCLUDE_vTaskSuspend` 设为 1，将 `xTicksToWait` 设为
	`portMAX_DELAY` 会使调用任务无限期等待（不超时），直到队列有空间。

	若在调度器启动前调用 `xTimerStart()`，则忽略 `xTicksToWait`，行为等同于将其设为 0。

- 返回值

	可能的返回值有两个：

	- `pdPASS`

		仅当“启动定时器”命令成功发送到定时器命令队列时返回 `pdPASS`。

		若守护任务优先级高于调用 `xTimerStart()` 的任务，调度器会确保在
		`xTimerStart()` 返回前处理该启动命令，因为守护任务会在命令进入队列后
		立即抢占调用任务。

		若指定了阻塞时间（`xTicksToWait` 非 0），调用任务可能进入 *Blocked* 状态等待
		队列空间，但在超时前成功写入队列。

	- `pdFAIL`

		若队列已满导致无法写入启动命令，则返回 `pdFAIL`。

		若指定了阻塞时间（`xTicksToWait` 非 0），调用任务会进入 *Blocked* 状态等待
		守护任务腾出空间，但在超时前未发生。


<a name="example6.1" title="示例 6.1 创建单次与自动重装载定时器"></a>
---
***示例 6.1*** *创建单次与自动重装载定时器*

---

该示例创建并启动一个单次定时器和一个自动重装载定时器，如清单 6.5 所示。


<a name="list6.5" title="清单 6.5 创建并启动示例 6.1 的定时器"></a>

```c
/* 为单次定时器和自动重装载定时器分配的周期分别为 3.333 秒
	 和 0.5 秒。 */
#define mainONE_SHOT_TIMER_PERIOD pdMS_TO_TICKS( 3333 )
#define mainAUTO_RELOAD_TIMER_PERIOD pdMS_TO_TICKS( 500 )

int main( void )
{
		TimerHandle_t xAutoReloadTimer, xOneShotTimer;
		BaseType_t xTimer1Started, xTimer2Started;

		/* 创建单次定时器，将创建得到的定时器句柄存入
			 xOneShotTimer。 */
		xOneShotTimer = xTimerCreate(
				/* 软件定时器的文本名称——FreeRTOS 不使用该名称。 */
																	"OneShot",
				/* 软件定时器的周期（tick）。 */
																	 mainONE_SHOT_TIMER_PERIOD,
				/* 将 uxAutoRealod 设为 pdFALSE 可创建单次软件定时器。 */
																	 pdFALSE,
				/* 本示例不使用定时器 ID。 */
																	 0,
				/* 创建的软件定时器要使用的回调函数。 */
																	 prvOneShotTimerCallback );

		/* 创建自动重装载定时器，将创建得到的定时器句柄存入
			 xAutoReloadTimer。 */
		xAutoReloadTimer = xTimerCreate(
				/* 软件定时器的文本名称——FreeRTOS 不使用该名称。 */
																		 "AutoReload",
				/* 软件定时器的周期（tick）。 */
																		 mainAUTO_RELOAD_TIMER_PERIOD,
				/* 将 uxAutoRealod 设为 pdTRUE 可创建自动重装载定时器。 */
																		 pdTRUE,
				/* 本示例不使用定时器 ID。 */
																		 0,
				/* 创建的软件定时器要使用的回调函数。 */
																		 prvAutoReloadTimerCallback );

		/* 检查软件定时器是否创建成功。 */
		if( ( xOneShotTimer != NULL ) && ( xAutoReloadTimer != NULL ) )
		{
				/* 启动软件定时器，阻塞时间设为 0（不阻塞）。
					 调度器尚未启动，因此这里指定的任何阻塞时间都会被忽略。 */
				xTimer1Started = xTimerStart( xOneShotTimer, 0 );
				xTimer2Started = xTimerStart( xAutoReloadTimer, 0 );

				/* xTimerStart() 的实现会使用定时器命令队列，
					 若定时器命令队列已满，xTimerStart() 将失败。
					 定时器服务任务要到调度器启动后才会创建，因此
					 在调度器启动之前发送到命令队列的所有命令都会留在
					 队列中。检查两次 xTimerStart() 调用都返回成功。 */
				if( ( xTimer1Started == pdPASS ) && ( xTimer2Started == pdPASS ) )
				{
						/* 启动调度器。 */
						vTaskStartScheduler();
				}
		}

		/* 按惯例，此行不应被执行。 */
		for( ;; );
}
```
***清单 6.5*** *创建并启动示例 6.1 的定时器*


定时器回调函数仅在每次调用时打印一条消息。单次定时器回调函数见清单 6.6，
自动重装载定时器回调函数见清单 6.7。


<a name="list6.5" title="清单 6.6 示例 6.1 中单次定时器的回调函数"></a>

```c
static void prvOneShotTimerCallback( TimerHandle_t xTimer )
{
		TickType_t xTimeNow;

		/* 获取当前 tick 计数。 */
		xTimeNow = xTaskGetTickCount();

		/* 输出字符串以显示回调函数执行的时间。 */
		vPrintStringAndNumber( "One-shot timer callback executing", xTimeNow );

		/* 文件作用域变量。 */
		ulCallCount++;
}
```
***清单 6.6*** *示例 6.1 中单次定时器的回调函数*


<a name="list6.7" title="清单 6.7 示例 6.1 中自动重装载定时器的回调函数"></a>

```c
static void prvAutoReloadTimerCallback( TimerHandle_t xTimer )
{
		TickType_t xTimeNow;

		/* 获取当前 tick 计数。 */
		xTimeNow = xTaskGetTickCount();

		/* 输出字符串以显示回调函数执行的时间。 */
		vPrintStringAndNumber( "Auto-reload timer callback executing", xTimeNow);

		ulCallCount++;
}
```
***清单 6.7*** *示例 6.1 中自动重装载定时器的回调函数*

执行该示例会产生图 6.7 所示输出。图 6.7 显示自动重装载定时器的回调函数以
500 tick 的固定周期执行（清单 6.5 中 `mainAUTO_RELOAD_TIMER_PERIOD` 设为 500），
单次定时器回调函数仅执行一次，即 tick 计数为 3333 时（清单 6.5 中
`mainONE_SHOT_TIMER_PERIOD` 设为 3333）。


<a name="fig6.7" title="图 6.7 执行示例 6.1 的输出"></a>

* * *
![](media/image44.jpg)
***图 6.7*** *执行示例 6.1 的输出*
* * *


## 6.6 定时器 ID

每个软件定时器都有一个 ID（标签值），应用编写者可将其用于任何目的。ID 存储在
`void *` 指针中，因此可以直接保存整数值、指向任意对象，或作为函数指针使用。

软件定时器创建时会为 ID 赋初值，之后可使用 `vTimerSetTimerID()` 更新 ID，
使用 `pvTimerGetTimerID()` 查询 ID。

与其他软件定时器 API 不同，`vTimerSetTimerID()` 与 `pvTimerGetTimerID()` 直接访问
软件定时器，不会向定时器命令队列发送命令。


### 6.6.1 vTimerSetTimerID() API 函数


<a name="list6.8" title="清单 6.8 vTimerSetTimerID() API 函数原型"></a>

```c
void vTimerSetTimerID( const TimerHandle_t xTimer, void *pvNewID );
```
***清单 6.8*** *vTimerSetTimerID() API 函数原型*


**vTimerSetTimerID() 参数**

- `xTimer`

	需要更新 ID 的软件定时器句柄。该句柄由 `xTimerCreate()` 创建时返回。

- `pvNewID`

	软件定时器 ID 将被设置为的值。


### 6.6.2 pvTimerGetTimerID() API 函数


<a name="list6.9" title="清单 6.9 pvTimerGetTimerID() API 函数原型"></a>

```c
void *pvTimerGetTimerID( const TimerHandle_t xTimer );
```
***清单 6.9*** *pvTimerGetTimerID() API 函数原型*


**pvTimerGetTimerID() 参数与返回值**

- `xTimer`

	要查询的定时器句柄。该句柄由 `xTimerCreate()` 创建时返回。

- 返回值

	被查询软件定时器的 ID。


<a name="example6.2" title="示例 6.2 使用回调函数参数与定时器 ID"></a>
---
***示例 6.2*** *使用回调函数参数与定时器 ID*

---

同一回调函数可分配给多个软件定时器。在这种情况下，回调函数参数用于判断
哪个软件定时器到期。

示例 6.1 使用两个回调函数：单次定时器一个，自动重装载定时器一个。示例 6.2
创建与示例 6.1 类似的功能，但两个定时器共享同一回调函数。

示例 6.2 的 `main()` 与示例 6.1 基本相同，唯一不同是定时器创建处，如清单 6.10
所示，两个定时器都使用 `prvTimerCallback()` 作为回调函数。


<a name="list6.10" title="清单 6.10 创建示例 6.2 使用的定时器"></a>

```c
/* 创建单次软件定时器，将句柄存入
	 xOneShotTimer。 */
xOneShotTimer = xTimerCreate( "OneShot",
															mainONE_SHOT_TIMER_PERIOD,
															pdFALSE,
											/* 定时器 ID 初始化为 NULL。 */
															NULL,
											/* 两个定时器都使用 prvTimerCallback()。 */
															prvTimerCallback );

/* 创建自动重装载软件定时器，将句柄存入
	 xAutoReloadTimer */
xAutoReloadTimer = xTimerCreate( "AutoReload",
																 mainAUTO_RELOAD_TIMER_PERIOD,
																 pdTRUE,
											 /* 定时器 ID 初始化为 NULL。 */
																 NULL,
											 /* 两个定时器都使用 prvTimerCallback()。 */
																 prvTimerCallback );
```
***清单 6.10*** *创建示例 6.2 使用的定时器*

当任一定时器到期时都会执行 `prvTimerCallback()`。该函数使用参数判断是单次定时器
到期还是自动重装载定时器到期。

`prvTimerCallback()` 还展示了如何将定时器 ID 用作定时器专用存储；每个定时器在
自身 ID 中保存其到期次数计数，自动重装载定时器在第 5 次执行时使用该计数停止自己。

`prvTimerCallback()` 的实现见清单 6.11。


<a name="list6.11" title="清单 6.11 示例 6.2 的定时器回调函数"></a>

```c
static void prvTimerCallback( TimerHandle_t xTimer )
{
		TickType_t xTimeNow;
		uint32_t ulExecutionCount;

		/* 该软件定时器到期的次数计数存放在定时器 ID 中。
			 先获取 ID 并递增，然后把它保存为新的 ID 值。
			 ID 是 void 指针，因此需转换为 uint32_t。 */
		ulExecutionCount = ( uint32_t ) pvTimerGetTimerID( xTimer );
		ulExecutionCount++;
		vTimerSetTimerID( xTimer, ( void * ) ulExecutionCount );

		/* 获取当前 tick 计数。 */
		xTimeNow = xTaskGetTickCount();

		/* 单次定时器的句柄在创建时存入 xOneShotTimer。
			 将传入本函数的句柄与 xOneShotTimer 比较，以确定
			 到期的是单次定时器还是自动重装载定时器，然后输出
			 字符串显示回调执行的时间。 */
		if( xTimer == xOneShotTimer )
		{
				vPrintStringAndNumber( "One-shot timer callback executing", xTimeNow );
		}
		else
		{
				/* xTimer 不等于 xOneShotTimer，因此到期的是
					 自动重装载定时器。 */
				vPrintStringAndNumber( "Auto-reload timer callback executing", xTimeNow);

				if( ulExecutionCount == 5 )
				{
						/* 自动重装载定时器执行 5 次后停止它。该回调函数在
							 RTOS 守护任务上下文中执行，因此不得调用可能使守护任务
							 进入 Blocked 状态的函数，所以阻塞时间设为 0。 */
						xTimerStop( xTimer, 0 );
				}
		}
}
```
***清单 6.11*** *示例 6.2 的定时器回调函数*


示例 6.2 的输出如图 6.8 所示，可以看到自动重装载定时器仅执行了 5 次。


<a name="fig6.8" title="图 6.8 执行示例 6.2 的输出"></a>

* * *
![](media/image45.jpg)
***图 6.8*** *执行示例 6.2 的输出*
* * *


## 6.7 修改定时器周期

每个官方 FreeRTOS port 都提供一个或多个示例工程。多数示例工程具备自检功能，
并用 LED 提供可视反馈：如果自检一直通过，则 LED 缓慢闪烁；若自检出现失败，
LED 则快速闪烁。

部分示例工程在任务中执行自检，并使用 `vTaskDelay()` 控制 LED 闪烁速度。另一些
示例工程在软件定时器回调函数中执行自检，并使用定时器周期控制 LED 闪烁速度。


### 6.7.1 xTimerChangePeriod() API 函数

软件定时器周期可通过 `xTimerChangePeriod()` 修改。

如果使用 `xTimerChangePeriod()` 修改正在运行的定时器周期，则定时器会使用新的周期
值重新计算到期时间。新的到期时间相对于调用 `xTimerChangePeriod()` 的时刻，而不是
相对于定时器最初启动的时刻。

如果使用 `xTimerChangePeriod()` 修改处于休眠状态（未运行）的定时器周期，则定时器
会计算到期时间并进入运行状态（开始运行）。

> *注意：切勿在中断服务例程中调用 `xTimerChangePeriod()`。应使用其中断安全版本
> `xTimerChangePeriodFromISR()`。*


<a name="list6.12" title="清单 6.12 xTimerChangePeriod() API 函数原型"></a>

```c
BaseType_t xTimerChangePeriod( TimerHandle_t xTimer,
															 TickType_t xNewPeriod,
															 TickType_t xTicksToWait );
```
***清单 6.12*** *xTimerChangePeriod() API 函数原型*


**xTimerChangePeriod() 参数与返回值**

- `xTimer`

	要更新周期的软件定时器句柄。该句柄由 `xTimerCreate()` 创建时返回。

- `xTimerPeriodInTicks`

	软件定时器的新周期，以 tick 指定。可使用 `pdMS_TO_TICKS()` 将毫秒转换为 tick。

- `xTicksToWait`

	`xTimerChangePeriod()` 使用定时器命令队列向守护任务发送“修改周期”命令。
	`xTicksToWait` 指定调用任务在队列已满时等待可用空间的最长时间（以 tick 为单位）。

	若 `xTicksToWait` 为 0 且队列已满，则 `xTimerChangePeriod()` 立即返回。

	可使用 `pdMS_TO_TICKS()` 将毫秒转换为 tick。

	若 FreeRTOSConfig.h 中 `INCLUDE_vTaskSuspend` 设为 1，将 `xTicksToWait` 设为
	`portMAX_DELAY` 会使调用任务无限期等待（不超时），直到命令队列有空间。

	若在调度器启动前调用 `xTimerChangePeriod()`，则忽略 `xTicksToWait`，行为等同于
	将其设为 0。

- 返回值

	可能的返回值有两个：

	- `pdPASS`

		仅当数据成功发送到定时器命令队列时返回 `pdPASS`。

		若指定了阻塞时间（`xTicksToWait` 非 0），调用任务可能进入 *Blocked* 状态等待
		队列空间，但在超时前成功写入队列。

	- `pdFAIL`

		若队列已满导致“修改周期”命令无法写入，则返回 `pdFAIL`。

		若指定了阻塞时间（`xTicksToWait` 非 0），调用任务会进入 *Blocked* 状态等待
		守护任务腾出空间，但在超时前未发生。

清单 6.13 展示了 FreeRTOS 示例中如何使用 `xTimerChangePeriod()` 在自检失败时加快
LED 闪烁速度。执行自检的软件定时器称为“检查定时器（check timer）”。


<a name="list6.13" title="清单 6.13 使用 xTimerChangePeriod()"></a>

```c
/* 检查定时器的周期为 3000 毫秒，使 LED 每 3 秒翻转一次。
	 如果自检功能检测到异常状态，则将检查定时器周期改为
	 200 毫秒，以获得更快的翻转频率。 */
const TickType_t xHealthyTimerPeriod = pdMS_TO_TICKS( 3000 );
const TickType_t xErrorTimerPeriod = pdMS_TO_TICKS( 200 );

/* 检查定时器使用的回调函数。 */
static void prvCheckTimerCallbackFunction( TimerHandle_t xTimer )
{
		static BaseType_t xErrorDetected = pdFALSE;

		if( xErrorDetected == pdFALSE )
		{
				/* 尚未检测到错误。再次运行自检函数。
					 该函数要求示例创建的每个任务报告自身状态，
					 并检查所有任务是否仍在运行（从而能正确报告状态）。 */
				if( CheckTasksAreRunningWithoutError() == pdFAIL )
				{
						/* 一个或多个任务报告了异常状态，可能发生错误。
							 缩短检查定时器周期以提高该回调函数的执行频率，
							 从而提高 LED 翻转频率。该回调函数在 RTOS 守护任务
							 上下文中执行，因此阻塞时间设为 0，确保守护任务
							 不会进入 Blocked 状态。 */
						xTimerChangePeriod(
								xTimer,            /* 要更新的定时器 */
								xErrorTimerPeriod, /* 定时器的新周期 */
								0 );               /* 发送该命令时不阻塞 */

						/* 锁存已检测到错误。 */
						xErrorDetected = pdTRUE;
				}
		}

		/* 翻转 LED。LED 翻转频率取决于该函数被调用的频率，
			 而调用频率由检查定时器的周期决定。如果
			 CheckTasksAreRunningWithoutError() 曾返回 pdFAIL，
			 定时器周期会从 3000ms 缩短到 200ms。 */
		ToggleLED();
}
```
***清单 6.13*** *使用 xTimerChangePeriod()*

## 6.8 复位软件定时器

复位软件定时器意味着重新启动定时器；定时器到期时间会重新计算，并以复位时刻为参考，
而非以最初启动时刻为参考。图 6.9 展示了一个周期为 6 的定时器：先启动，再被复位两次，
最终到期并执行回调函数。


<a name="fig6.9" title="图 6.9 启动并复位周期为 6 tick 的软件定时器"></a>

* * *
![](media/image46.png)
***图 6.9*** *启动并复位周期为 6 tick 的软件定时器*
* * *

参见图 6.9：

- 定时器 1 在 t1 启动，周期为 6，因此回调函数原本将在 t7 执行（启动后 6 个 tick）。

- 在到达 t7 之前复位定时器 1，即在其到期并执行回调前。t5 时复位，因此其回调执行
	时间重新计算为 t11（复位后 6 个 tick）。

- 在到达 t11 之前再次复位定时器 1，即在其到期并执行回调前。t9 时复位，因此其回调
	执行时间重新计算为 t15（最后一次复位后 6 个 tick）。

- 定时器 1 未再次复位，因此在 t15 到期并执行回调。


### 6.8.1 xTimerReset() API 函数

使用 `xTimerReset()` 复位定时器。

`xTimerReset()` 也可用于启动处于休眠状态的定时器。

> *注意：切勿在中断服务例程中调用 `xTimerReset()`。应使用其中断安全版本
> `xTimerResetFromISR()`。*


<a name="list6.14" title="清单 6.14 xTimerReset() API 函数原型"></a>

```c
BaseType_t xTimerReset( TimerHandle_t xTimer, TickType_t xTicksToWait );
```
***清单 6.14*** *xTimerReset() API 函数原型*


**xTimerReset() 参数与返回值**

- `xTimer`

	要复位或启动的软件定时器句柄。该句柄由 `xTimerCreate()` 创建时返回。

- `xTicksToWait`

	`xTimerReset()` 使用定时器命令队列向守护任务发送“复位”命令。`xTicksToWait` 指定
	调用任务在队列已满时等待可用空间的最长时间（以 tick 为单位）。

	若 `xTicksToWait` 为 0 且队列已满，则 `xTimerReset()` 立即返回。

	若 FreeRTOSConfig.h 中 `INCLUDE_vTaskSuspend` 设为 1，将 `xTicksToWait` 设为
	`portMAX_DELAY` 会使调用任务无限期等待（不超时），直到命令队列有空间。

- 返回值

	有两种可能返回值：

	- `pdPASS`

		仅当数据成功发送到定时器命令队列时返回 `pdPASS`。

		若指定了阻塞时间（`xTicksToWait` 非 0），调用任务可能进入 *Blocked* 状态等待
		队列空间，但在超时前成功写入队列。

		`pdFAIL`

		若队列已满导致“复位”命令无法写入，则返回 `pdFAIL`。

		若指定了阻塞时间（`xTicksToWait` 非 0），调用任务会进入 *Blocked* 状态等待
		守护任务腾出空间，但在超时前未发生。


<a name="example6.3" title="示例 6.3 复位软件定时器"></a>
---
***示例 6.3*** *复位软件定时器*

---

该示例模拟手机背光行为。背光：

- 按键时点亮。

- 若在一定时间内继续按键则保持点亮。

- 若在一定时间内没有按键则自动熄灭。

使用单次软件定时器实现该行为：

- 按键时点亮（模拟）背光，并在软件定时器回调函数中关闭背光。

- 每次按键都会复位软件定时器。

- 为防止背光关闭而需要按键的时间窗口等于软件定时器周期；若在定时器到期前没有
	按键复位，则回调函数执行并关闭背光。

`xSimulatedBacklightOn` 变量保存背光状态。设为 `pdTRUE` 表示背光开启，设为
`pdFALSE` 表示背光关闭。

软件定时器回调函数见清单 6.15。


<a name="list6.15" title="清单 6.15 示例 6.3 中单次定时器的回调函数"></a>

```c
static void prvBacklightTimerCallback( TimerHandle_t xTimer )
{
		TickType_t xTimeNow = xTaskGetTickCount();

		/* 背光定时器到期，关闭背光。 */
		xSimulatedBacklightOn = pdFALSE;

		/* 输出背光关闭的时间。 */
		vPrintStringAndNumber(
						"Timer expired, turning backlight OFF at time\t\t", xTimeNow );
}
```
***清单 6.15*** *示例 6.3 中单次定时器的回调函数*


示例 6.3 创建了一个用于轮询键盘的任务[^11]。任务见清单 6.16，但由于下一段说明的原因，
清单 6.16 并非最佳设计的代表。

[^11]: 向 Windows 控制台输出与从 Windows 控制台读取按键都会执行 Windows 系统调用。
这些系统调用（包括控制台、磁盘或 TCP/IP 栈）会影响 FreeRTOS Windows 移植的行为，
通常应避免使用。*

使用 FreeRTOS 可让应用事件驱动。事件驱动设计非常高效，因为只有发生事件才会使用
处理时间，不会浪费时间轮询未发生的事件。示例 6.3 无法事件驱动，是因为在 FreeRTOS
Windows 移植中不便处理键盘中断，因此只能使用效率较低的轮询方式。若清单 6.16
是中断服务例程，则应使用 `xTimerResetFromISR()` 代替 `xTimerReset()`。


<a name="list6.16" title="清单 6.16 示例 6.3 中用于复位定时器的任务"></a>

```c
static void vKeyHitTask( void *pvParameters )
{
		const TickType_t xShortDelay = pdMS_TO_TICKS( 50 );
		TickType_t xTimeNow;

		vPrintString( "Press a key to turn the backlight on.\r\n" );

		/* 理想情况下应用应为事件驱动，并使用中断处理按键。
			 在 FreeRTOS Windows 移植中使用键盘中断并不现实，
			 因此该任务用于轮询按键。 */
		for( ;; )
		{
				/* 是否有按键被按下？ */
				if( _kbhit() != 0 )
				{
						/* 按键已被按下，记录时间。 */
						xTimeNow = xTaskGetTickCount();

						if( xSimulatedBacklightOn == pdFALSE )
						{

								/* 背光此前关闭，因此打开并输出开启时间。 */
								xSimulatedBacklightOn = pdTRUE;
								vPrintStringAndNumber(
										"Key pressed, turning backlight ON at time\t\t",
										xTimeNow );
						}
						else
						{
								/* 背光已开启，因此输出提示：软件定时器将被复位，并输出复位时间。 */
								vPrintStringAndNumber(
										"Key pressed, resetting software timer at time\t\t",
										xTimeNow );
						}

						/* 复位软件定时器。若背光此前关闭，则该调用会启动定时器；
							 若背光此前开启，则该调用会重新启动定时器。真实应用可能
							 在中断中读取按键；如果该函数是中断服务例程，则必须用
							 xTimerResetFromISR() 代替 xTimerReset()。 */
						xTimerReset( xBacklightTimer, xShortDelay );

						/* 读取并丢弃按下的按键——该简单示例不需要它。 */
						( void ) _getch();
				}
		}
}
```
***清单 6.16*** *示例 6.3 中用于复位定时器的任务*

执行示例 6.3 的输出如图 6.10 所示。结合图 6.10：

- 第一次按键发生在 tick 计数为 812 时。此时背光点亮，单次定时器启动。

- 后续按键发生在 tick 计数为 1813、3114、4015 与 5016，这些按键都在定时器到期前
	复位定时器。

- 定时器在 tick 计数为 10016 时到期，此时背光关闭。


<a name="fig6.10" title="图 6.10 执行示例 6.3 的输出"></a>

* * *
![](media/image47.jpg)
***图 6.10*** *执行示例 6.3 的输出*
* * *

从图 6.10 可见，定时器周期为 5000 tick；背光在最后一次按键后恰好 5000 tick 关闭，
即定时器最后一次复位后 5000 tick 关闭。

