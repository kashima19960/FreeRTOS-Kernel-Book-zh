# 目录

## [1 前言](ch01-前言.md#1-前言)
  + [1.1 小型嵌入式系统中的多任务](ch01-前言.md#11-小型嵌入式系统中的多任务)
    + [1.1.1 关于 FreeRTOS 内核](ch01-前言.md#111-关于-freertos-内核)
    + [1.1.2 价值主张](ch01-前言.md#112-价值主张)
    + [1.1.3 关于术语的说明](ch01-前言.md#113-关于术语的说明)
    + [1.1.4 为什么要使用 RTOS？](ch01-前言.md#114-为什么要使用-rtos)
    + [1.1.5 FreeRTOS 内核特性](ch01-前言.md#115-freertos-内核特性)
    + [1.1.6 许可协议及 FreeRTOS、OpenRTOS 和 SafeRTOS 家族](ch01-前言.md#116-许可协议及-freertos-openrtos-和-safertos-家族)
  + [1.2 附带的源文件和工程](ch01-前言.md#12-附带的源文件和工程)
    + [1.2.1 获取本书配套示例](ch01-前言.md#121-获取本书配套示例)

## [2 FreeRTOS 内核分发包](ch02-FreeRTOS%20内核分发包.md#2-freertos-内核分发包)
  + [2.1 简介](ch02-FreeRTOS%20内核分发包.md#21-简介)
  + [2.2 理解 FreeRTOS 分发包](ch02-FreeRTOS%20内核分发包.md#22-理解-freertos-分发包)
    + [2.2.1 定义：FreeRTOS 移植](ch02-FreeRTOS%20内核分发包.md#221-定义-freertos-移植)
    + [2.2.2 构建 FreeRTOS](ch02-FreeRTOS%20内核分发包.md#222-构建-freertos)
    + [2.2.3 FreeRTOSConfig.h](ch02-FreeRTOS%20内核分发包.md#223-freertosconfigh)
    + [2.2.4 官方分发包](ch02-FreeRTOS%20内核分发包.md#224-官方分发包)
    + [2.2.5 所有移植通用的 FreeRTOS 源文件](ch02-FreeRTOS%20内核分发包.md#225-所有移植通用的-freertos-源文件)
    + [2.2.6 针对特定移植的 FreeRTOS 源文件](ch02-FreeRTOS%20内核分发包.md#226-针对特定移植的-freertos-源文件)
    + [2.2.7 头文件包含路径](ch02-FreeRTOS%20内核分发包.md#227-头文件包含路径)
    + [2.2.8 头文件](ch02-FreeRTOS%20内核分发包.md#228-头文件)
  + [2.3 演示应用](ch02-FreeRTOS%20内核分发包.md#23-演示应用)
  + [2.4 创建 FreeRTOS 工程](ch02-FreeRTOS%20内核分发包.md#24-创建-freertos-工程)
    + [2.4.1 适配提供的演示工程](ch02-FreeRTOS%20内核分发包.md#241-适配提供的演示工程)
    + [2.4.2 从零创建新工程](ch02-FreeRTOS%20内核分发包.md#242-从零创建新工程)
  + [2.5 数据类型和编码风格指南](ch02-FreeRTOS%20内核分发包.md#25-数据类型和编码风格指南)
    + [2.5.1 数据类型](ch02-FreeRTOS%20内核分发包.md#251-数据类型)
    + [2.5.2 变量命名](ch02-FreeRTOS%20内核分发包.md#252-变量命名)
    + [2.5.3 函数命名](ch02-FreeRTOS%20内核分发包.md#253-函数命名)
    + [2.5.4 格式化](ch02-FreeRTOS%20内核分发包.md#254-格式化)
    + [2.5.5 宏命名](ch02-FreeRTOS%20内核分发包.md#255-宏命名)
    + [2.5.6 关于类型强制转换的说明](ch02-FreeRTOS%20内核分发包.md#256-关于类型强制转换的说明)

## [3 堆内存管理](ch03-堆内存管理.md#3-堆内存管理)
  + [3.1 简介](ch03-堆内存管理.md#31-简介)
    + [3.1.1 前提条件](ch03-堆内存管理.md#311-前提条件)
    + [3.1.2 范围](ch03-堆内存管理.md#312-范围)
    + [3.1.3 在静态和动态内存分配之间切换](ch03-堆内存管理.md#313-在静态和动态内存分配之间切换)
    + [3.1.4 使用动态内存分配](ch03-堆内存管理.md#314-使用动态内存分配)
    + [3.1.5 动态内存分配的选项](ch03-堆内存管理.md#315-动态内存分配的选项)
  + [3.2 示例内存分配方案](ch03-堆内存管理.md#32-示例内存分配方案)
    + [3.2.1 Heap\_1](ch03-堆内存管理.md#321-heap_1)
    + [3.2.2 Heap\_2](ch03-堆内存管理.md#322-heap_2)
    + [3.2.3 Heap\_3](ch03-堆内存管理.md#323-heap_3)
    + [3.2.4 Heap\_4](ch03-堆内存管理.md#324-heap_4)
    + [3.2.5 Heap\_5](ch03-堆内存管理.md#325-heap_5)
    + [3.2.6 初始化 heap\_5：vPortDefineHeapRegions() API 函数](ch03-堆内存管理.md#326-初始化-heap_5-vportdefineheapregions-api-函数)
  + [3.3 堆相关的实用程序函数和宏](ch03-堆内存管理.md#33-堆相关的实用程序函数和宏)
    + [3.3.1 定义堆起始地址](ch03-堆内存管理.md#331-定义堆起始地址)
    + [3.3.2 xPortGetFreeHeapSize() API 函数](ch03-堆内存管理.md#332-xportgetfreeheapsize-api-函数)
    + [3.3.3 xPortGetMinimumEverFreeHeapSize() API 函数](ch03-堆内存管理.md#333-xportgetminimumeverfreeheapsize-api-函数)
    + [3.3.4 vPortGetHeapStats() API 函数](ch03-堆内存管理.md#334-vportgetheapstats-api-函数)
    + [3.3.5 收集每个任务的堆使用统计信息](ch03-堆内存管理.md#335-收集每个任务的堆使用统计信息)
    + [3.3.6 内存分配失败钩子函数](ch03-堆内存管理.md#336-内存分配失败钩子函数)
    + [3.3.7 将任务堆栈放置在快速内存中](ch03-堆内存管理.md#337-将任务堆栈放置在快速内存中)
  + [3.4 使用静态内存分配](ch03-堆内存管理.md#34-使用静态内存分配)
    + [3.4.1 启用静态内存分配](ch03-堆内存管理.md#341-启用静态内存分配)
    + [3.4.2 静态内部内核内存](ch03-堆内存管理.md#342-静态内部内核内存)
      + [3.4.2.1 vApplicationGetTimerTaskMemory](ch03-堆内存管理.md#3421-vapplicationgettimertaskmemory)
      + [3.4.2.2 vApplicationGetIdleTaskMemory](ch03-堆内存管理.md#3422-vapplicationgetidletaskmemory)

## [4 任务管理](ch04-任务管理.md#4-任务管理)
  + [4.1 简介](ch04-任务管理.md#41-简介)
    + [4.1.1 范围](ch04-任务管理.md#411-范围)
  + [4.2 任务函数](ch04-任务管理.md#42-任务函数)
  + [4.3 顶级任务状态](ch04-任务管理.md#43-顶级任务状态)
  + [4.4 任务创建](ch04-任务管理.md#44-任务创建)
    + [4.4.1 xTaskCreate() API 函数](ch04-任务管理.md#441-xtaskcreate-api-函数)
  + [4.5 任务优先级](ch04-任务管理.md#45-任务优先级)
    + [通用调度器](ch04-任务管理.md#通用调度器)
    + [架构优化调度器](ch04-任务管理.md#架构优化调度器)
  + [4.6 时间测量和滴答中断](ch04-任务管理.md#46-时间测量和滴答中断)
  + [4.7 扩展“未运行”状态](ch04-任务管理.md#47-扩展未运行状态)
    + [4.7.1 阻塞状态](ch04-任务管理.md#471-阻塞状态)
    + [4.7.2 挂起状态](ch04-任务管理.md#472-挂起状态)
    + [4.7.3 就绪状态](ch04-任务管理.md#473-就绪状态)
    + [4.7.4 完成状态转换图](ch04-任务管理.md#474-完成状态转换图)
    + [4.7.5 vTaskDelayUntil() API 函数](ch04-任务管理.md#475-vtaskdelayuntil-api-函数)
  + [4.8 空闲任务和空闲任务钩子](ch04-任务管理.md#48-空闲任务和空闲任务钩子)
    + [4.8.1 空闲任务钩子函数](ch04-任务管理.md#481-空闲任务钩子函数)
    + [4.8.2 空闲任务钩子函数的实现限制](ch04-任务管理.md#482-空闲任务钩子函数的实现限制)
  + [4.9 改变任务优先级](ch04-任务管理.md#49-改变任务优先级)
    + [4.9.1 vTaskPrioritySet() API 函数](ch04-任务管理.md#491-vtaskpriorityset-api-函数)
    + [4.9.2 uxTaskPriorityGet() API 函数](ch04-任务管理.md#492-uxtaskpriorityget-api-函数)
  + [4.10 删除任务](ch04-任务管理.md#410-删除任务)
    + [4.10.1 vTaskDelete() API 函数](ch04-任务管理.md#4101-vtaskdelete-api-函数)
  + [4.11 线程本地存储和可重入性](ch04-任务管理.md#411-线程本地存储和可重入性)
    + [4.11.1 C 运行时线程本地存储实现](ch04-任务管理.md#4111-c-运行时线程本地存储实现)
    + [4.11.2 自定义 C 运行时线程本地存储](ch04-任务管理.md#4112-自定义-c-运行时线程本地存储)
    + [4.11.3 应用程序线程本地存储](ch04-任务管理.md#4113-应用程序线程本地存储)
  + [4.12 调度算法](ch04-任务管理.md#412-调度算法)
    + [4.12.1 任务状态和事件回顾](ch04-任务管理.md#4121-任务状态和事件回顾)
    + [4.12.2 选择调度算法](ch04-任务管理.md#4122-选择调度算法)
    + [4.12.3 带时间片的优先级抢占式调度](ch04-任务管理.md#4123-带时间片的优先级抢占式调度)
    + [4.12.4 不带时间片的优先级抢占式调度](ch04-任务管理.md#4124-不带时间片的优先级抢占式调度)
    + [4.12.5 协作式调度](ch04-任务管理.md#4125-协作式调度)

## [5 队列管理](ch05-队列管理.md#5-队列管理)
  + [5.1 简介](ch05-队列管理.md#51-简介)
    + [5.1.1 范围](ch05-队列管理.md#511-范围)
  + [5.2 队列的特性](ch05-队列管理.md#52-队列的特性)
    + [5.2.1 数据存储](ch05-队列管理.md#521-数据存储)
    + [5.2.2 多任务访问](ch05-队列管理.md#522-多任务访问)
    + [5.2.3 阻塞在队列读取上](ch05-队列管理.md#523-阻塞在队列读取上)
    + [5.2.4 阻塞在队列写入上](ch05-队列管理.md#524-阻塞在队列写入上)
    + [5.2.5 阻塞在多个队列上](ch05-队列管理.md#525-阻塞在多个队列上)
    + [5.2.6 创建队列：静态分配和动态分配队列](ch05-队列管理.md#526-创建队列静态分配和动态分配队列)
  + [5.3 使用队列](ch05-队列管理.md#53-使用队列)
    + [5.3.1 xQueueCreate() API 函数](ch05-队列管理.md#531-xqueuecreate-api-函数)
    + [5.3.2 xQueueSendToBack() 和 xQueueSendToFront() API 函数](ch05-队列管理.md#532-xqueuesendtoback-和-xqueuesendtofront-api-函数)
    + [5.3.3 xQueueReceive() API 函数](ch05-队列管理.md#533-xqueuereceive-api-函数)
    + [5.3.4 uxQueueMessagesWaiting() API 函数](ch05-队列管理.md#534-uxqueuemessageswaiting-api-函数)
  + [5.4 从多个源接收数据](ch05-队列管理.md#54-从多个源接收数据)
  + [5.5 处理大数据或可变大小数据](ch05-队列管理.md#55-处理大数据或可变大小数据)
    + [5.5.1 排队指针](ch05-队列管理.md#551-排队指针)
    + [5.5.2 使用队列发送不同类型和长度的数据](ch05-队列管理.md#552-使用队列发送不同类型和长度的数据9)
  + [5.6 从多个队列接收](ch05-队列管理.md#56-从多个队列接收)
    + [5.6.1 队列集](ch05-队列管理.md#561-队列集)
    + [5.6.2 xQueueCreateSet() API 函数](ch05-队列管理.md#562-xqueuecreateset-api-函数)
    + [5.6.3 xQueueAddToSet() API 函数](ch05-队列管理.md#563-xqueueaddtoset-api-函数)
    + [5.6.4 xQueueSelectFromSet() API 函数](ch05-队列管理.md#564-xqueueselectfromset-api-函数)
    + [5.6.5 更现实的队列集用例](ch05-队列管理.md#565-更现实的队列集用例)
  + [5.7 使用队列创建邮箱](ch05-队列管理.md#57-使用队列创建邮箱)
    + [5.7.1 xQueueOverwrite() API 函数](ch05-队列管理.md#571-xqueueoverwrite-api-函数)
    + [5.7.2 xQueuePeek() API 函数](ch05-队列管理.md#572-xqueuepeek-api-函数)

## [6 软件定时器管理](ch06-软件定时器管理.md#6-软件定时器管理)
  + [6.1 章节简介和范围](ch06-软件定时器管理.md#61-章节简介和范围)
    + [6.1.1 范围](ch06-软件定时器管理.md#611-范围)
  + [6.2 软件定时器回调函数](ch06-软件定时器管理.md#62-软件定时器回调函数)
  + [6.3 软件定时器的属性和状态](ch06-软件定时器管理.md#63-软件定时器的属性和状态)
    + [6.3.1 软件定时器的周期](ch06-软件定时器管理.md#631-软件定时器的周期)
    + [6.3.2 单次和自动重载定时器](ch06-软件定时器管理.md#632-单次和自动重载定时器)
    + [6.3.3 软件定时器状态](ch06-软件定时器管理.md#633-软件定时器状态)
  + [6.4 软件定时器的上下文](ch06-软件定时器管理.md#64-软件定时器的上下文)
    + [6.4.1 RTOS 守护（定时器服务）任务](ch06-软件定时器管理.md#641-rtos-守护定时器服务任务)
    + [6.4.2 定时器命令队列](ch06-软件定时器管理.md#642-定时器命令队列)
    + [6.4.3 守护任务调度](ch06-软件定时器管理.md#643-守护任务调度)
  + [6.5 创建和启动软件定时器](ch06-软件定时器管理.md#65-创建和启动软件定时器)
    + [6.5.1 xTimerCreate() API 函数](ch06-软件定时器管理.md#651-xtimercreate-api-函数)
    + [6.5.2 xTimerStart() API 函数](ch06-软件定时器管理.md#652-xtimerstart-api-函数)
  + [6.6 定时器 ID](ch06-软件定时器管理.md#66-定时器-id)
    + [6.6.1 vTimerSetTimerID() API 函数](ch06-软件定时器管理.md#661-vtimersetimerid-api-函数)
    + [6.6.2 pvTimerGetTimerID() API 函数](ch06-软件定时器管理.md#662-pvtimergettimerid-api-函数)
  + [6.7 更改定时器的周期](ch06-软件定时器管理.md#67-更改定时器的周期)
    + [6.7.1 xTimerChangePeriod() API 函数](ch06-软件定时器管理.md#671-xtimerchangeperiod-api-函数)
  + [6.8 重置软件定时器](ch06-软件定时器管理.md#68-重置软件定时器)
    + [6.8.1 xTimerReset() API 函数](ch06-软件定时器管理.md#681-xtimerreset-api-函数)

## [7 中断管理](ch07-中断管理.md#7-中断管理)
  + [7.1 简介](ch07-中断管理.md#71-简介)
    + [7.1.1 事件](ch07-中断管理.md#711-事件)
    + [7.1.2 范围](ch07-中断管理.md#712-范围)
  + [7.2 在 ISR 中使用 FreeRTOS API](ch07-中断管理.md#72-在-isr-中使用-freertos-api)
    + [7.2.1 中断安全 API](ch07-中断管理.md#721-中断安全-api)
    + [7.2.2 使用单独的中断安全 API 的好处](ch07-中断管理.md#722-使用单独的中断安全-api-的好处)
    + [7.2.3 使用单独的中断安全 API 的缺点](ch07-中断管理.md#723-使用单独的中断安全-api-的缺点)
    + [7.2.4 xHigherPriorityTaskWoken 参数](ch07-中断管理.md#724-xhigherprioritytaskwoken-参数)
    + [7.2.5 portYIELD\_FROM\_ISR() 和 portEND\_SWITCHING\_ISR()宏](ch07-中断管理.md#725-portyield_from_isr-和-portend_switching_isr宏)
  + [7.3 延迟中断处理](ch07-中断管理.md#73-延迟中断处理)
  + [7.4 用于同步的二进制信号量](ch07-中断管理.md#74-用于同步的二进制信号量)
    + [7.4.1 xSemaphoreCreateBinary() API 函数](ch07-中断管理.md#741-xsemaphorecreatebinary-api-函数)
    + [7.4.2 xSemaphoreTake() API 函数](ch07-中断管理.md#742-xsemaphoretake-api-函数)
    + [7.4.3 xSemaphoreGiveFromISR() API 函数](ch07-中断管理.md#743-xsemaphoregivefromisr-api-函数)
    + [7.4.4 改进示例 7.1 中使用的任务的实现](ch07-中断管理.md#744-改进示例-71-中使用的任务的实现)
  + [7.5 计数信号量](ch07-中断管理.md#75-计数信号量)
    + [7.5.1 xSemaphoreCreateCounting() API 函数](ch07-中断管理.md#751-xsemaphorecreatecounting-api-函数)
  + [7.6 将工作推迟到 RTOS 守护任务](ch07-中断管理.md#76-将工作推迟到-rtos-守护任务)
    + [7.6.1 xTimerPendFunctionCallFromISR() API 函数](ch07-中断管理.md#761-xtimerpendfunctioncallfromisr-api-函数)
  + [7.7 在中断服务例程中使用队列](ch07-中断管理.md#77-在中断服务例程中使用队列)
    + [7.7.1 xQueueSendToFrontFromISR() 和 xQueueSendToBackFromISR() API 函数](ch07-中断管理.md#771-xqueuesendtofrontfromisr-和-xqueuesendtobackfromisr-api-函数)
    + [7.7.2 从 ISR 使用队列时的注意事项](ch07-中断管理.md#772-从-isr-使用队列时的注意事项)
  + [7.8 中断嵌套](ch07-中断管理.md#78-中断嵌套)
    + [7.8.1 针对 ARM Cortex-M 和 ARM GIC 用户的说明](ch07-中断管理.md#781-针对-arm-cortex-m22-和-arm-gic-用户的说明)

## [8 资源管理](ch08-资源管理.md#8-资源管理)
  + [8.1 章节简介和范围](ch08-资源管理.md#81-章节简介和范围)
    + [8.1.1 互斥](ch08-资源管理.md#811-互斥)
    + [8.1.2 范围](ch08-资源管理.md#812-范围)
  + [8.2 关键段和挂起调度程序](ch08-资源管理.md#82-关键段和挂起调度程序)
    + [8.2.1 基本关键段](ch08-资源管理.md#821-基本关键段)
    + [8.2.2 挂起（或锁定）调度程序](ch08-资源管理.md#822-挂起或锁定调度程序)
    + [8.2.3 vTaskSuspendAll() API 函数](ch08-资源管理.md#823-vtasksuspendall-api-函数)
    + [8.2.4 xTaskResumeAll() API 函数](ch08-资源管理.md#824-xtaskresumeall-api-函数)
  + [8.3 互斥量（和二进制信号量）](ch08-资源管理.md#83-互斥量和二进制信号量)
    + [8.3.1 xSemaphoreCreateMutex() API 函数](ch08-资源管理.md#831-xsemaphorecreatemutex-api-函数)
    + [8.3.2 优先级反转](ch08-资源管理.md#832-优先级反转)
    + [8.3.3 优先级继承](ch08-资源管理.md#833-优先级继承)
    + [8.3.4 死锁（或致命拥塞）](ch08-资源管理.md#834-死锁或致命拥塞)
    + [8.3.5 递归互斥量](ch08-资源管理.md#835-递归互斥量)
    + [8.3.6 互斥量和任务调度](ch08-资源管理.md#836-互斥量和任务调度)
  + [8.4 守门人任务](ch08-资源管理.md#84-守门人任务)
    + [8.4.1 重写 vPrintString() 以使用守门人任务](ch08-资源管理.md#841-重写-vprintstring-以使用守门人任务)

## [9 事件组](ch09-事件组.md#9-事件组)
  + [9.1 章节简介与范围](ch09-事件组.md#91-章节简介与范围)
    + [9.1.1 范围](ch09-事件组.md#911-范围)
  + [9.2 事件组的特性](ch09-事件组.md#92-事件组的特性)
    + [9.2.1 事件组、事件标志和事件位](ch09-事件组.md#921-事件组事件标志和事件位)
    + [9.2.2 有关 EventBits\_t 数据类型的更多信息](ch09-事件组.md#922-有关-eventbits_t-数据类型的更多信息)
    + [9.2.3 多任务访问](ch09-事件组.md#923-多任务访问)
    + [9.2.4 使用事件组的实际示例](ch09-事件组.md#924-使用事件组的实际示例)
  + [9.3 使用事件组进行事件管理](ch09-事件组.md#93-使用事件组进行事件管理)
    + [9.3.1 xEventGroupCreate() API 函数](ch09-事件组.md#931-xeventgroupcreate-api-函数)
    + [9.3.2 xEventGroupSetBits() API 函数](ch09-事件组.md#932-xeventgroupsetbits-api-函数)
    + [9.3.3 xEventGroupSetBitsFromISR() API 函数](ch09-事件组.md#933-xeventgroupsetbitsfromisr-api-函数)
    + [9.3.4 xEventGroupWaitBits() API 函数](ch09-事件组.md#934-xeventgroupwaitbits-api-函数)
    + [9.3.5 xEventGroupGetStaticBuffer() API 函数](ch09-事件组.md#935-xeventgroupgetstaticbuffer-api-函数)
  + [9.4 使用事件组进行任务同步](ch09-事件组.md#94-使用事件组进行任务同步)
    + [9.4.1 xEventGroupSync() API 函数](ch09-事件组.md#941-xeventgroupsync-api-函数)

## [10 任务通知](ch10-任务通知.md#10-任务通知)
  + [10.1 简介](ch10-任务通知.md#101-简介)
    + [10.1.1 通过中介对象通信](ch10-任务通知.md#1011-通过中介对象通信)
    + [10.1.2 任务通知——直接任务通信](ch10-任务通知.md#1012-任务通知直接任务通信)
    + [10.1.3 范围](ch10-任务通知.md#1013-范围)
  + [10.2 任务通知的优缺点](ch10-任务通知.md#102-任务通知的优缺点)
    + [10.2.1 任务通知的性能优势](ch10-任务通知.md#1021-任务通知的性能优势)
    + [10.2.2 RAM 占用优势](ch10-任务通知.md#1022-ram-占用优势)
    + [10.2.3 任务通知的局限性](ch10-任务通知.md#1023-任务通知的局限性)
  + [10.3 使用任务通知](ch10-任务通知.md#103-使用任务通知)
    + [10.3.1 任务通知 API 选项](ch10-任务通知.md#1031-任务通知-api-选项)
      + [10.3.1.1 完整的 API 函数列表](ch10-任务通知.md#10311-完整的-api-函数列表-sup27sup)
    + [10.3.2 xTaskNotifyGive() API 函数](ch10-任务通知.md#1032-xtasknotifygive-api-函数)
    + [10.3.3 vTaskNotifyGiveFromISR() API 函数](ch10-任务通知.md#1033-vtasknotifygivefromisr-api-函数)
    + [10.3.4 ulTaskNotifyTake() API 函数](ch10-任务通知.md#1034-ultasknotifytake-api-函数)
    + [10.3.5 xTaskNotify() 和 xTaskNotifyFromISR() API 函数](ch10-任务通知.md#1035-xtasknotify-和-xtasknotifyfromisr-api-函数)
    + [10.3.6 xTaskNotifyWait() API 函数](ch10-任务通知.md#1036-xtasknotifywait-api-函数)
    + [10.3.7 任务通知在外设驱动中的应用：UART 示例](ch10-任务通知.md#1037-任务通知在外设驱动中的应用uart-示例)
    + [10.3.8 任务通知在外设驱动中的应用：ADC 示例](ch10-任务通知.md#1038-任务通知在外设驱动中的应用adc-示例)
    + [10.3.9 任务通知在应用程序中的直接使用](ch10-任务通知.md#1039-任务通知在应用程序中的直接使用)

## [11 低功耗支持](ch11-低功耗支持.md#11-低功耗支持)
  + [11.1 节能简介](ch11-低功耗支持.md#111-节能简介)
  + [11.2 FreeRTOS 睡眠模式](ch11-低功耗支持.md#112-freertos-睡眠模式)
  + [11.3 启用内置无滴答空闲功能的方法](ch11-低功耗支持.md#113-启用内置无滴答空闲功能的方法)
    + [11.3.1 portSUPPRESS\_TICKS\_AND\_SLEEP() 宏](ch11-低功耗支持.md#1131-the-portsuppress_ticks_and_sleep-macro)
    + [11.3.2 vPortSuppressTicksAndSleep 函数](ch11-低功耗支持.md#1132-the-vportsuppressticksandsleep-function)
    + [11.3.3 eTaskConfirmSleepModeStatus 函数](ch11-低功耗支持.md#1133-the-etaskconfirmsleepmodestatus-function)
    + [11.3.4 configPRE\_SLEEP\_PROCESSING 配置](ch11-低功耗支持.md#1134-the-configpre_sleep_processing-configuration)
    + [11.3.5 configPOST\_SLEEP\_PROCESSING 配置](ch11-低功耗支持.md#1135-the-configpost_sleep_processing-configuration)
  + [11.4 Implementing portSUPPRESS\_TICKS\_AND\_SLEEP() Macro](ch11-低功耗支持.md#114-implementing-portsuppress_ticks_and_sleep-macro)
  + [11.5 Idle Task Hook Function](ch11-低功耗支持.md#115-idle-task-hook-function)

## [12 开发者支持](ch12-开发者支持.md#12-开发者支持)
  + [12.1 简介](ch12-开发者支持.md#121-简介)
  + [12.2 configASSERT()](ch12-开发者支持.md#122-configassert)
    + [12.2.1 示例 configASSERT() 定义](ch12-开发者支持.md#1221-示例-configassert-定义)
  + [12.3 Tracealyzer for FreeRTOS](ch12-开发者支持.md#123-tracealyzer-for-freertos)
  + [12.4 调试相关的钩子（回调）函数](ch12-开发者支持.md#124-调试相关的钩子回调函数)
    + [12.4.1 内存分配失败钩子](ch12-开发者支持.md#1241-内存分配失败钩子)
    + [12.4.2 堆栈溢出钩子](ch12-开发者支持.md#1242-堆栈溢出钩子)
  + [12.5 查看运行时和任务状态信息](ch12-开发者支持.md#125-查看运行时和任务状态信息)
    + [12.5.1 任务运行时统计信息](ch12-开发者支持.md#1251-任务运行时统计信息)
    + [12.5.2 运行时统计时钟](ch12-开发者支持.md#1252-运行时统计时钟)
    + [12.5.3 配置应用程序以收集运行时统计信息](ch12-开发者支持.md#1253-配置应用程序以收集运行时统计信息)
    + [12.5.4 uxTaskGetSystemState() API 函数](ch12-开发者支持.md#1254-uxtaskgetsystemstate-api-函数)
    + [12.5.5 vTaskListTasks() 帮助函数](ch12-开发者支持.md#1255-vtasklisttasks-帮助函数)
    + [12.5.6 vTaskGetRunTimeStatistics() 帮助函数](ch12-开发者支持.md#1256-vtaskgetruntimestatistics-帮助函数)
    + [12.5.7 生成和显示运行时统计信息的示例](ch12-开发者支持.md#1257-生成和显示运行时统计信息的示例)
  + [12.6 跟踪钩子宏](ch12-开发者支持.md#126-跟踪钩子宏)
    + [12.6.1 可用的跟踪钩子宏](ch12-开发者支持.md#1261-可用的跟踪钩子宏)
    + [12.6.2 定义跟踪钩子宏](ch12-开发者支持.md#1262-定义跟踪钩子宏)
    + [12.6.3 FreeRTOS 感知调试器插件](ch12-开发者支持.md#1263-freertos-感知调试器插件)

## [13 故障排查](ch13-故障排查.md#13-故障排查)
  + [13.1 章节简介与范围](ch13-故障排查.md#131-章节简介与范围)
  + [13.2 中断优先级](ch13-故障排查.md#132-中断优先级)
  + [13.3 堆栈溢出](ch13-故障排查.md#133-堆栈溢出)
    + [13.3.1 The uxTaskGetStackHighWaterMark() API Function](ch13-故障排查.md#1331-the-uxtaskgetstackhighwatermark-api-function)
    + [13.3.2 运行时堆栈检查 - 概述](ch13-故障排查.md#1332-运行时堆栈检查---概述)
    + [13.3.3 运行时堆栈检查 - 方法 1](ch13-故障排查.md#1333-运行时堆栈检查---方法-1)
    + [13.3.4 运行时堆栈检查 - 方法 2](ch13-故障排查.md#1334-运行时堆栈检查---方法-2)
    + [13.3.4 运行时堆栈检查 - 方法 3](ch13-故障排查.md#1334-运行时堆栈检查---方法-3)
  + [13.4 对 printf() 和 sprintf() 的使用](ch13-故障排查.md#134-对-printf-和-sprintf-的使用)
    + [13.4.1 Printf-stdarg.c](ch13-故障排查.md#1341-printf-stdargc)
  + [13.5 其他常见错误来源](ch13-故障排查.md#135-其他常见错误来源)
    + [13.5.1 症状：向演示添加简单任务导致演示崩溃](ch13-故障排查.md#1351-症状向演示添加简单任务导致演示崩溃)
    + [13.5.2 症状：在中断中使用 API 函数导致应用崩溃](ch13-故障排查.md#1352-症状在中断中使用-api-函数导致应用崩溃)
    + [13.5.3 症状：有时应用在中断服务例程中崩溃](ch13-故障排查.md#1353-症状有时应用在中断服务例程中崩溃)
    + [13.5.4 症状：调度器尝试启动第一个任务时崩溃](ch13-故障排查.md#1354-症状调度器尝试启动第一个任务时崩溃)
    + [13.5.5 症状：中断意外地保持禁用，或临界区未正确嵌套](ch13-故障排查.md#1355-症状中断意外地保持禁用或临界区未正确嵌套)
    + [13.5.6 症状：应用程序在调度程序启动之前崩溃](ch13-故障排查.md#1356-症状应用程序在调度程序启动之前崩溃)
    + [13.5.7 症状：在调度程序挂起或临界区内调用 API 函数导致应用崩溃](ch13-故障排查.md#1357-症状在调度程序挂起或临界区内调用-api-函数导致应用崩溃)
  + [13.6 其他调试步骤](ch13-故障排查.md#136-其他调试步骤)


## 示例:
+ [Example 4.1 Creating tasks](ch04-任务管理.md#example4.1)
+ [Example 4.2 Using the task parameter](ch04-任务管理.md#example4.2)
+ [Example 4.3 Experimenting with priorities](ch04-任务管理.md#example4.3)
+ [Example 4.4 Using the *Blocked* state to create a delay](ch04-任务管理.md#example4.4)
+ [Example 4.5 Converting the example tasks to use vTaskDelayUntil()](ch04-任务管理.md#example4.5)
+ [Example 4.6 Combining blocking and non-blocking tasks](ch04-任务管理.md#example4.6)
+ [Example 4.7 Defining an idle task hook function](ch04-任务管理.md#example4.7)
+ [Example 4.8 Deleting tasks](ch04-任务管理.md#example4.8)
+ [Example 5.1 Blocking when receiving from a queue](ch05-队列管理.md#example5.1)
+ [Example 5.2 Blocking when sending to a queue, and sending structures on a queue](ch05-队列管理.md#example5.2)
+ [Example 5.3 Using a Queue Set](ch05-队列管理.md#example5.3)
+ [Example 6.1 Creating one-shot and auto-reload timers](ch06-软件定时器管理.md#example6.1)
+ [Example 6.2 Using the callback function parameter and the software timer ID](ch06-软件定时器管理.md#example6.2)
+ [Example 6.3 Resetting a software timer](ch06-软件定时器管理.md#example6.3)
+ [Example 7.1 Using a binary semaphore to synchronize a task with an interrupt](ch07-中断管理.md#example7.1)
+ [Example 7.2 Using a counting semaphore to synchronize a task with an interrupt](ch07-中断管理.md#example7.2)
+ [Example 7.3 Centralized deferred interrupt processing](ch07-中断管理.md#example7.3)
+ [Example 7.4 Sending and receiving on a queue from within an interrupt](ch07-中断管理.md#example7.4)
+ [Example 8.1 Rewriting vPrintString() to use a semaphore](ch08-资源管理.md#example8.1)
+ [Example 8.2 The alternative implementation for print task](ch08-资源管理.md#example8.2)
+ [Example 9.1 Experimenting with event groups](ch09-事件组.md#example9.1)
+ [Example 9.2 Synchronizing tasks](ch09-事件组.md#example9.2)
+ [Example 10.1 Using a task notification in place of a semaphore, method 1](ch10-任务通知.md#example10.1)
+ [Example 10.2 Using a task notification in place of a semaphore, method 2](ch10-任务通知.md#example10.2)

## 插图:
+ [Figure 2.1 Top level directories within the FreeRTOS distribution](ch02-FreeRTOS%20内核分发包.md#fig2.1)
+ [Figure 2.2 Core FreeRTOS source files within the FreeRTOS directory tree](ch02-FreeRTOS%20内核分发包.md#fig2.2)
+ [Figure 2.3 Port specific source files within the FreeRTOS directory tree](ch02-FreeRTOS%20内核分发包.md#fig2.3)
+ [Figure 2.4 The demo directory hierarchy](ch02-FreeRTOS%20内核分发包.md#fig2.4)
+ [Figure 3.1 RAM being allocated from the heap\_1 array each time a task is created](ch03-堆内存管理.md#fig3.1)
+ [Figure 3.2 RAM being allocated and freed from the heap\_2 array as tasks are created and deleted](ch03-堆内存管理.md#fig3.2)
+ [Figure 3.3 RAM being allocated and freed from the heap\_4 array](ch03-堆内存管理.md#fig3.3)
+ [Figure 3.4 Memory Map](ch03-堆内存管理.md#fig3.4)
+ [Figure 4.1 Top level task states and transitions](ch04-任务管理.md#fig4.1)
+ [Figure 4.2 The output produced when executing Example 4.1](ch04-任务管理.md#fig4.2)
+ [Figure 4.3 The actual execution pattern of the two Example 4.1 tasks](ch04-任务管理.md#fig4.3)
+ [Figure 4.4 The execution sequence expanded to show the tick interrupt executing](ch04-任务管理.md#fig4.4)
+ [Figure 4.5 Running both tasks at different priorities](ch04-任务管理.md#fig4.5)
+ [Figure 4.6 The execution pattern when one task has a higher priority than the...](ch04-任务管理.md#fig4.6)
+ [Figure 4.7 Full task state machine](ch04-任务管理.md#fig4.7)
+ [Figure 4.8 The output produced when Example 4.4 is executed](ch04-任务管理.md#fig4.8)
+ [Figure 4.9 The execution sequence when the tasks use vTaskDelay() in place of the null loop](ch04-任务管理.md#fig4.9)
+ [Figure 4.10 Bold lines indicate the state transitions performed by the tasks...](ch04-任务管理.md#fig4.10)
+ [Figure 4.11 The output produced when Example 4.6 is executed](ch04-任务管理.md#fig4.11)
+ [Figure 4.12 The execution pattern of Example 4.6](ch04-任务管理.md#fig4.12)
+ [Figure 4.13 The output produced when Example 4.7 is executed](ch04-任务管理.md#fig4.13)
+ [Figure 4.14 The sequence of task execution when running Example 4.8](ch04-任务管理.md#fig4.14)
+ [Figure 4.15 The output produced when Example 4.8 is executed](ch04-任务管理.md#fig4.15)
+ [Figure 4.16 The output produced when Example 4.9 is executed](ch04-任务管理.md#fig4.16)
+ [Figure 4.17 The execution sequence for Example 4.9](ch04-任务管理.md#fig4.17)
+ [Figure 4.18 Execution pattern highlighting task prioritization and preemption...](ch04-任务管理.md#fig4.18)
+ [Figure 4.19 Execution pattern highlighting task prioritization and time slicing...](ch04-任务管理.md#fig4.19)
+ [Figure 4.20 The execution pattern for the same scenario as shown in Figure 4.19...](ch04-任务管理.md#fig4.20)
+ [Figure 4.21 Execution pattern that demonstrates how tasks of equal priority can...](ch04-任务管理.md#fig4.21)
+ [Figure 4.22 Execution pattern demonstrating the behavior of the cooperative scheduler](ch04-任务管理.md#fig4.22)
+ [Figure 5.1 An example sequence of writes to, and reads from a queue](ch05-队列管理.md#fig5.1)
+ [Figure 5.2 The output produced when Example 5.1 is executed](ch05-队列管理.md#fig5.2)
+ [Figure 5.3 The sequence of execution produced by Example 5.1](ch05-队列管理.md#fig5.3)
+ [Figure 5.4 An example scenario where structures are sent on a queue](ch05-队列管理.md#fig5.4)
+ [Figure 5.5 The output produced by Example 5.2](ch05-队列管理.md#fig5.5)
+ [Figure 5.6 The sequence of execution produced by Example 5.2](ch05-队列管理.md#fig5.6)
+ [Figure 5.7 The output produced when Example 5.3 is executed](ch05-队列管理.md#fig5.7)
+ [Figure 6.1 The difference in behavior between one-shot and auto-reload software timers](ch06-软件定时器管理.md#fig6.1)
+ [Figure 6.2 Auto-reload software timer states and transitions](ch06-软件定时器管理.md#fig6.2)
+ [Figure 6.3 One-shot software timer states and transitions](ch06-软件定时器管理.md#fig6.3)
+ [Figure 6.4 The timer command queue being used by a software timer API function to communicate with the RTOS daemon task](ch06-软件定时器管理.md#fig6.4)
+ [Figure 6.5 The execution pattern when the priority of a task calling xTimerStart() is above the priority of the daemon task](ch06-软件定时器管理.md#fig6.5)
+ [Figure 6.6 The execution pattern when the priority of a task calling xTimerStart() is below the priority of the daemon task](ch06-软件定时器管理.md#fig6.6)
+ [Figure 6.7 The output produced when Example 6.1 is executed](ch06-软件定时器管理.md#fig6.7)
+ [Figure 6.8 The output produced when Example 6.2 is executed](ch06-软件定时器管理.md#fig6.8)
+ [Figure 6.9 Starting and resetting a software timer that has a period of 6 ticks](ch06-软件定时器管理.md#fig6.9)
+ [Figure 6.10 The output produced when Example 6.3 is executed](ch06-软件定时器管理.md#fig6.10)
+ [Figure 7.1 Completing interrupt processing in a high priority task](ch07-中断管理.md#fig7.1)
+ [Figure 7.2 Using a binary semaphore to implement deferred interrupt processing](ch07-中断管理.md#fig7.2)
+ [Figure 7.3 Using a binary semaphore to synchronize a task with an interrupt](ch07-中断管理.md#fig7.3)
+ [Figure 7.4 The output produced when Example 7.1 is executed](ch07-中断管理.md#fig7.4)
+ [Figure 7.5 The sequence of execution when Example 7.1 is executed](ch07-中断管理.md#fig7.5)
+ [Figure 7.6 The scenario when one interrupt occurs before the task has finished processing the first event](ch07-中断管理.md#fig7.6)
+ [Figure 7.7 The scenario when two interrupts occur before the task has finished processing the first event](ch07-中断管理.md#fig7.7)
+ [Figure 7.8 Using a counting semaphore to ](ch07-中断管理.md#fig7.8)
+ [Figure 7.9 The output produced when Example 7.2 is executed](ch07-中断管理.md#fig7.9)
+ [Figure 7.10 The output produced when Example 7.3 is executed](ch07-中断管理.md#fig7.10)
+ [Figure 7.11 The sequence of execution when Example 7.3 is executed](ch07-中断管理.md#fig7.11)
+ [Figure 7.12 The output produced when Example 7.4 is executed](ch07-中断管理.md#fig7.12)
+ [Figure 7.13 The sequence of execution produced by Example 7.4](ch07-中断管理.md#fig7.13)
+ [Figure 7.14 Constants affecting interrupt nesting behavior](ch07-中断管理.md#fig7.14)
+ [Figure 7.15 How a priority of binary 101 is stored by a Cortex-M microcontroller that implements four priority bits](ch07-中断管理.md#fig7.15)
+ [Figure 8.1 Mutual exclusion implemented using a mutex](ch08-资源管理.md#fig8.1)
+ [Figure 8.2 The output produced when Example 8.1 is executed](ch08-资源管理.md#fig8.2)
+ [Figure 8.3 A possible sequence of execution for Example 8.1](ch08-资源管理.md#fig8.3)
+ [Figure 8.4 A worst case priority inversion scenario](ch08-资源管理.md#fig8.4)
+ [Figure 8.5 Priority inheritance minimizing the effect of priority inversion](ch08-资源管理.md#fig8.5)
+ [Figure 8.6 A possible sequence of execution when tasks that have the same priority use the same mutex](ch08-资源管理.md#fig8.6)
+ [Figure 8.7 A sequence of execution that could occur if two instances of the task shown by Listing 8.15 are created at the same priority](ch08-资源管理.md#fig8.7)
+ [Figure 8.8 The output produced when Example 8.2 is executed](ch08-资源管理.md#fig8.8)
+ [Figure 9.1 Event flag to bit number mapping in a variable of type EventBits\_t](ch09-事件组.md#fig9.1)
+ [Figure 9.2 An event group in which only bits 1, 4 and 7 are set, and all the other event flags are clear, making the event group](ch09-事件组.md#fig9.2)
+ [Figure 9.3 The output produced when Example 9.1 is executed with xWaitForAllBits set to pdFALSE](ch09-事件组.md#fig9.3)
+ [Figure 9.4 The output produced when Example 9.1 is executed with xWaitForAllBits set to pdTRUE](ch09-事件组.md#fig9.4)
+ [Figure 9.5 The output produced when Example 9.2 is executed](ch09-事件组.md#fig9.5)
+ [Figure 10.1 A communication object being used to send an event from one task to another](ch10-任务通知.md#fig10.1)
+ [Figure 10.2 A task notification used to send an event directly from one task to another](ch10-任务通知.md#fig10.2)
+ [Figure 10.3 The output produced when Example 7.1 is executed](ch10-任务通知.md#fig10.3)
+ [Figure 10.4 The sequence of execution when Example 10.1 is executed](ch10-任务通知.md#fig10.4)
+ [Figure 10.5 The output produced when Example 10.2 is executed](ch10-任务通知.md#fig10.5)
+ [Figure 10.6 The communication paths from the application tasks to the cloud server, and back again](ch10-任务通知.md#fig10.6)
+ [Figure 12.1 FreeRTOS+Trace includes more than 20 interconnected views](ch12-开发者支持.md#fig12.1)
+ [Figure 12.2 FreeRTOS+Trace main trace view - one of more than 20 interconnected trace views](ch12-开发者支持.md#fig12.2)
+ [Figure 12.3 FreeRTOS+Trace CPU load view - one of more than 20 interconnected trace views](ch12-开发者支持.md#fig12.3)
+ [Figure 12.4 FreeRTOS+Trace response time view - one of more than 20 interconnected trace views](ch12-开发者支持.md#fig12.4)
+ [Figure 12.5 FreeRTOS+Trace user event plot view - one of more than 20 interconnected trace views](ch12-开发者支持.md#fig12.5)
+ [Figure 12.6 FreeRTOS+Trace kernel object history view - one of more than 20 interconnected trace views](ch12-开发者支持.md#fig12.6)
+ [Figure 12.7 Example output generated by vTaskListTasks()](ch12-开发者支持.md#fig12.7)
+ [Figure 12.8 Example output generated by vTaskGetRunTimeStatistics()](ch12-开发者支持.md#fig12.8)

## 代码清单:
+ [Listing 2.1 The template for a new main() function](ch02-FreeRTOS%20内核分发包.md#list2.1)
+ [Listing 3.1 The vPortDefineHeapRegions() API function prototype](ch03-堆内存管理.md#list3.1)
+ [Listing 3.2 The HeapRegion\_t structure](ch03-堆内存管理.md#list3.2)
+ [Listing 3.3 An array of HeapRegion\_t structures that together describe the 3 regions of RAM in their entirety](ch03-堆内存管理.md#list3.3)
+ [Listing 3.4 An array of HeapRegion\_t structures that describe all of RAM2, all of RAM3, but only part of RAM1](ch03-堆内存管理.md#list3.4)
+ [Listing 3.5 Using GCC syntax to declare the array that will be used by heap\_4, and place the array in a memory section named .my\_heap](ch03-堆内存管理.md#list3.5)
+ [Listing 3.6 Using IAR syntax to declare the array that will be used by heap\_4, and place the array at the absolute address 0x20000000](ch03-堆内存管理.md#list3.6)
+ [Listing 3.7 The xPortGetFreeHeapSize() API function prototype](ch03-堆内存管理.md#list3.7)
+ [Listing 3.8 The xPortGetMinimumEverFreeHeapSize() API function prototype](ch03-堆内存管理.md#list3.8)
+ [Listing 3.9 The vPortGetHeapStatus() API function prototype](ch03-堆内存管理.md#list3.9)
+ [Listing 3.10 The HeapStatus\_t() structure](ch03-堆内存管理.md#list3.10)
+ [Listing 3.11 Collecting Per-task Heap Usage Statistics](ch03-堆内存管理.md#list3.11)
+ [Listing 3.12 The malloc failed hook function name and prototype](ch03-堆内存管理.md#list3.12)
+ [Listing 3.13 Mapping the pvPortMallocStack() and vPortFreeStack() macros to an application defined memory allcator](ch03-堆内存管理.md#list3.13)
+ [Listing 3.14 Typical implementation of vApplicationGetTimerTaskMemory](ch03-堆内存管理.md#list3.14)
+ [Listing 3.15 Typical implementation of vApplicationGetIdleTaskMemory](ch03-堆内存管理.md#list3.15)
+ [Listing 4.1 The task function prototype](ch04-任务管理.md#list4.1)
+ [Listing 4.2 The structure of a typical task function](ch04-任务管理.md#list4.2)
+ [Listing 4.3 The xTaskCreate() API function prototype](ch04-任务管理.md#list4.3)
+ [Listing 4.4 Implementation of the first task used in Example 4.1](ch04-任务管理.md#list4.4)
+ [Listing 4.5 Implementation of the second task used in Example 4.1](ch04-任务管理.md#list4.5)
+ [Listing 4.6 Starting the Example 4.1 tasks](ch04-任务管理.md#list4.6)
+ [Listing 4.7 Creating a task from within another task after the scheduler has started](ch04-任务管理.md#list4.7)
+ [Listing 4.8 The single task function used to create two tasks in Example 4.2](ch04-任务管理.md#list4.8)
+ [Listing 4.9 The main() function for Example 2](ch04-任务管理.md#list4.9)
+ [Listing 4.10 Using the pdMS\_TO\_TICKS() macro to convert 200 milliseconds...](ch04-任务管理.md#list4.10)
+ [Listing 4.11. Creating two tasks at different priorities](ch04-任务管理.md#list4.11)
+ [Listing 4.12 The vTaskDelay() API function prototype](ch04-任务管理.md#list4.12)
+ [Listing 4.13 The source code for the example task after replacing the null loop delay with a call...](ch04-任务管理.md#list4.13)
+ [Listing 4.14 vTaskDelayUntil() API function prototype](ch04-任务管理.md#list4.14)
+ [Listing 4.15 The implementation of the example task using vTaskDelayUntil()](ch04-任务管理.md#list4.15)
+ [Listing 4.16 The continuous processing task used in Example 4.6](ch04-任务管理.md#list4.16)
+ [Listing 4.17 The periodic task used in Example 4.6](ch04-任务管理.md#list4.17)
+ [Listing 4.18 The idle task hook function name and prototype](ch04-任务管理.md#list4.18)
+ [Listing 4.19 A very simple Idle hook function](ch04-任务管理.md#list4.19)
+ [Listing 4.20 The source code for the example task now prints out the ulIdleCycleCount value](ch04-任务管理.md#list4.20)
+ [Listing 4.21 The vTaskPrioritySet() API function prototype](ch04-任务管理.md#list4.21)
+ [Listing 4.22 The uxTaskPriorityGet() API function prototype](ch04-任务管理.md#list4.22)
+ [Listing 4.23 The implementation of Task 1 in Example 4.8](ch04-任务管理.md#list4.23)
+ [Listing 4.24 The implementation of Task 2 in Example 4.8](ch04-任务管理.md#list4.24)
+ [Listing 4.25 The implementation of main() for Example 4.8](ch04-任务管理.md#list4.25)
+ [Listing 4.26 The vTaskDelete() API function prototype](ch04-任务管理.md#list4.26)
+ [Listing 4.27 The implementation of main() for Example 4.9](ch04-任务管理.md#list4.27)
+ [Listing 4.28 The implementation of Task 1 for Example 4.9](ch04-任务管理.md#list4.28)
+ [Listing 4.29 The implementation of Task 2 for Example 4.9](ch04-任务管理.md#list4.29)
+ [Listing 4.30 Function prototypes of the Thread Local Storage Pointer API functions](ch04-任务管理.md#list4.30)
+ [Listing 5.1 The xQueueCreate() API function prototype](ch05-队列管理.md#list5.1)
+ [Listing 5.2 The xQueueSendToFront() API function prototype](ch05-队列管理.md#list5.2)
+ [Listing 5.3 The xQueueSendToBack() API function prototype](ch05-队列管理.md#list5.3)
+ [Listing 5.4 The xQueueReceive() API function prototype](ch05-队列管理.md#list5.4)
+ [Listing 5.5 The uxQueueMessagesWaiting() API function prototype](ch05-队列管理.md#list5.5)
+ [Listing 5.6 Implementation of the sending task used in Example 5.1](ch05-队列管理.md#list5.6)
+ [Listing 5.7  Implementation of the receiver task for Example 5.1](ch05-队列管理.md#list5.7)
+ [Listing 5.8 The implementation of main() in Example 5.1](ch05-队列管理.md#list5.8)
+ [Listing 5.9 The definition of the structure that is to be passed on a queue, plus the declaration of two variables for use by the example](ch05-队列管理.md#list5.9)
+ [Listing 5.10 The implementation of the sending task for Example 5.2](ch05-队列管理.md#list5.10)
+ [Listing 5.11 The definition of the receiving task for Example 5.2](ch05-队列管理.md#list5.11)
+ [Listing 5.12 The implementation of main() for Example 5.2](ch05-队列管理.md#list5.12)
+ [Listing 5.13 Creating a queue that holds pointers](ch05-队列管理.md#list5.13)
+ [Listing 5.14 Using a queue to send a pointer to a buffer](ch05-队列管理.md#list5.14)
+ [Listing 5.15 Using a queue to receive a pointer to a buffer](ch05-队列管理.md#list5.15)
+ [Listing 5.16 The structure used to send events to the TCP/IP stack task in FreeRTOS+TCP](ch05-队列管理.md#list5.16)
+ [Listing 5.17 Pseudo code showing how an IPStackEvent\_t structure is used to send data received from the network to the TCP/IP task](ch05-队列管理.md#list5.17)
+ [Listing 5.18 Pseudo code showing how an IPStackEvent\_t structure is used to send the handle of a socket that is accepting a connection to the TCP/IP task](ch05-队列管理.md#list5.18)
+ [Listing 5.19 Pseudo code showing how an IPStackEvent\_t structure is used to send a network down event to the TCP/IP task](ch05-队列管理.md#list5.19)
+ [Listing 5.20 Pseudo code showing how an IPStackEvent\_t structure is received and processed](ch05-队列管理.md#list5.20)
+ [Listing 5.21 The xQueueCreateSet() API function prototype](ch05-队列管理.md#list5.21)
+ [Listing 5.22 The xQueueAddToSet() API function prototype](ch05-队列管理.md#list5.22)
+ [Listing 5.23 The xQueueSelectFromSet() API function prototype](ch05-队列管理.md#list5.23)
+ [Listing 5.24  Implementation of main() for Example 5.3](ch05-队列管理.md#list5.24)
+ [Listing 5.25 The sending tasks used in Example 5.3](ch05-队列管理.md#list5.25)
+ [Listing 5.26 The receive task used in Example 5.3](ch05-队列管理.md#list5.26)
+ [Listing 5.27 Using a queue set that contains queues and semaphores](ch05-队列管理.md#list5.27)
+ [Listing 5.28 A queue being created for use as a mailbox](ch05-队列管理.md#list5.28)
+ [Listing 5.29 The xQueueOverwrite() API function prototype](ch05-队列管理.md#list5.29)
+ [Listing 5.30 Using the xQueueOverwrite() API function](ch05-队列管理.md#list5.30)
+ [Listing 5.31 The xQueuePeek() API function prototype](ch05-队列管理.md#list5.31)
+ [Listing 5.32 Using the xQueuePeek() API function](ch05-队列管理.md#list5.32)
+ [Listing 6.1 The software timer callback function prototype](ch06-软件定时器管理.md#list)
+ [Listing 6.2 The xTimerDelete() API function prototype](ch06-软件定时器管理.md#list6.2)
+ [Listing 6.3 The xTimerCreate() API function prototype](ch06-软件定时器管理.md#list6.3)
+ [Listing 6.4 The xTimerStart() API function prototype](ch06-软件定时器管理.md#list6.4)
+ [Listing 6.5 Creating and starting the timers used in Example 6.1](ch06-软件定时器管理.md#list6.5)
+ [Listing 6.6 The callback function used by the one-shot timer in Example 6.1](ch06-软件定时器管理.md#list6.5)
+ [Listing 6.7 The callback function used by the auto-reload timer in Example 6.1](ch06-软件定时器管理.md#list6.7)
+ [Listing 6.8 The vTimerSetTimerID() API function prototype](ch06-软件定时器管理.md#list6.8)
+ [Listing 6.9 The pvTimerGetTimerID() API function prototype](ch06-软件定时器管理.md#list6.9)
+ [Listing 6.10 Creating the timers used in Example 6.2](ch06-软件定时器管理.md#list6.10)
+ [Listing 6.11 The timer callback function used in Example 6.2](ch06-软件定时器管理.md#list6.11)
+ [Listing 6.12 The xTimerChangePeriod() API function prototype](ch06-软件定时器管理.md#list6.12)
+ [Listing 6.13 Using xTimerChangePeriod()](ch06-软件定时器管理.md#list6.13)
+ [Listing 6.14 The xTimerReset() API function prototype](ch06-软件定时器管理.md#list6.14)
+ [Listing 6.15 The callback function for the one-shot timer used in Example 6.3](ch06-软件定时器管理.md#list6.15)
+ [Listing 6.16 The task used to reset the software timer in Example 6.3](ch06-软件定时器管理.md#list6.16)
+ [Listing 7.1 The portEND\_SWITCHING\_ISR() macros](ch07-中断管理.md#list7.1)
+ [Listing 7.2 The portYIELD\_FROM\_ISR() macros](ch07-中断管理.md#list7.2)
+ [Listing 7.3 The xSemaphoreCreateBinary() API function prototype](ch07-中断管理.md#list7.3)
+ [Listing 7.4 The xSemaphoreTake() API function prototype](ch07-中断管理.md#list7.4)
+ [Listing 7.5 The xSemaphoreGiveFromISR() API function prototype](ch07-中断管理.md#list)
+ [Listing 7.6 Implementation of the task that periodically generates a software interrupt in Example 7.1](ch07-中断管理.md#list7.6)
+ [Listing 7.7 The implementation of the task to which the interrupt processing is deferred (the task that...](ch07-中断管理.md#list7.7.)
+ [Listing 7.8 The ISR for the software interrupt used in Example 7.1](ch07-中断管理.md#list7.8)
+ [Listing 7.9 The implementation of main() for Example 7.1](ch07-中断管理.md#list7.9)
+ [Listing 7.10 The recommended structure of a deferred interrupt processing task, using a UART receive...](ch07-中断管理.md#list7.10)
+ [Listing 7.11 The xSemaphoreCreateCounting() API function prototype](ch07-中断管理.md#list7.11)
+ [Listing 7.12 The call to xSemaphoreCreateCounting() used to create the counting semaphore in Example 7.2](ch07-中断管理.md#list7.12)
+ [Listing 7.13 The implementation of the interrupt service routine used by Example 7.2](ch07-中断管理.md#list7.13)
+ [Listing 7.14 The xTimerPendFunctionCallFromISR() API function prototype](ch07-中断管理.md#list7.14)
+ [Listing 7.15 The prototype to which a function passed in the xFunctionToPend parameter of xTimerPendFunctionCallFromISR()...](ch07-中断管理.md#list7.15)
+ [Listing 7.16 The software interrupt handler used in Example 7.3](ch07-中断管理.md#list7.16)
+ [Listing 7.17 The function that performs the processing necessitated by the interrupt in Example 7.3](ch07-中断管理.md#list7.17)
+ [Listing 7.18 The implementation of main() for Example 7.3](ch07-中断管理.md#list7.18)
+ [Listing 7.19 The xQueueSendToFrontFromISR() API function prototype](ch07-中断管理.md#list7.19)
+ [Listing 7.20 The xQueueSendToBackFromISR() API function prototype](ch07-中断管理.md#list7.20)
+ [Listing 7.21 The implementation of the task that writes to the queue in Example 7.4](ch07-中断管理.md#list7.21)
+ [Listing 7.22 The implementation of the interrupt service routine used by Example 7.4](ch07-中断管理.md#list7.22)
+ [Listing 7.23 The task that prints out the strings received from the interrupt service routine in Example 7.4](ch07-中断管理.md#list7.23)
+ [Listing 7.24 The main() function for Example 7.4](ch07-中断管理.md#list7.24)
+ [Listing 8.1 An example read, modify, write sequence](ch08-资源管理.md#list8.1)
+ [Listing 8.2 An example of a reentrant function](ch08-资源管理.md#list8.2)
+ [Listing 8.3 An example of a function that is not reentrant](ch08-资源管理.md#list8.3)
+ [Listing 8.4 Using a critical section to guard access to a register](ch08-资源管理.md#list8.4)
+ [Listing 8.5 A possible implementation of vPrintString()](ch08-资源管理.md#list8.5)
+ [Listing 8.6 Using a critical section in an interrupt service routine](ch08-资源管理.md#list8.6)
+ [Listing 8.7 The vTaskSuspendAll() API function prototype](ch08-资源管理.md#list8.7)
+ [Listing 8.8 The xTaskResumeAll() API function prototype](ch08-资源管理.md#list8.8)
+ [Listing 8.9 The implementation of vPrintString()](ch08-资源管理.md#list8.9)
+ [Listing 8.10 The xSemaphoreCreateMutex() API function prototype](ch08-资源管理.md#list8.10)
+ [Listing 8.11 The implementation of prvNewPrintString()](ch08-资源管理.md#list8.11)
+ [Listing 8.12 The implementation of prvPrintTask() for Example 8.1](ch08-资源管理.md#list8.12)
+ [Listing 8.13 The implementation of main() for Example 8.1](ch08-资源管理.md#list8.13)
+ [Listing 8.14 Creating and using a recursive mutex](ch08-资源管理.md#list8.14)
+ [Listing 8.15 A task that uses a mutex in a tight loop](ch08-资源管理.md#list8.15)
+ [Listing 8.16 Ensuring tasks that use a mutex in a loop receive a more equal amount of processing time...](ch08-资源管理.md#list8.16)
+ [Listing 8.17 The name and prototype for a tick hook function](ch08-资源管理.md#list8.17)
+ [Listing 8.18 The gatekeeper task](ch08-资源管理.md#list8.18)
+ [Listing 8.19 The print task implementation for Example 8.2](ch08-资源管理.md#list8.19)
+ [Listing 8.20 The tick hook implementation](ch08-资源管理.md#list8.20)
+ [Listing 8.21 The implementation of main() for Example 8.2](ch08-资源管理.md#list8.21)
+ [Listing 9.1 The xEventGroupCreate() API function prototype](ch09-事件组.md#list9.1)
+ [Listing 9.2. The xEventGroupSetBits() API function prototype](ch09-事件组.md#list9.2)
+ [Listing 9.3 The xEventGroupSetBitsFromISR() API function prototype](ch09-事件组.md#list9.3)
+ [Listing 9.4 The xEventGroupWaitBits() API function prototype](ch09-事件组.md#list9.4)
+ [Listing 9.5 The xEventGroupGetStaticBuffer() API function prototype](ch09-事件组.md#list9.5)
+ [Listing 9.6 Event bit definitions used in Example 9.1](ch09-事件组.md#list9.6)
+ [Listing 9.7 The task that sets two bits in the event group in Example 9.1](ch09-事件组.md#list9.7)
+ [Listing 9.8 The ISR that sets bit 2 in the event group in Example 9.1](ch09-事件组.md#list9.8)
+ [Listing 9.9 The task that blocks to wait for event bits to become set in Example 9.1](ch09-事件组.md#list9.9)
+ [Listing 9.10 Creating the event group and tasks in Example 9.1](ch09-事件组.md#list9.10)
+ [Listing 9.11 Pseudo code for two tasks that synchronize with each other to ensure a shared TCP socket...](ch09-事件组.md#list9.11)
+ [Listing 9.12 The xEventGroupSync() API function prototype](ch09-事件组.md#list9.12)
+ [Listing 9.13 The implementation of the task used in Example 9.2](ch09-事件组.md#list9.13)
+ [Listing 9.14 The main() function used in Example 9.2](ch09-事件组.md#list9.14)
+ [Listing 10.1 The xTaskNotifyGive() API function prototype](ch10-任务通知.md#list10.1)
+ [Listing 10.2 The vTaskNotifyGiveFromISR() API function prototype](ch10-任务通知.md#list10.2)
+ [Listing 10.3 The ulTaskNotifyTake() API function prototype](ch10-任务通知.md#list10.3)
+ [Listing 10.4 The implementation of the task to which the interrupt processing is deferred (the task that...](ch10-任务通知.md#list10.4)
+ [Listing 10.5 The implementation of the interrupt service routine used in Example 10.1](ch10-任务通知.md#list10.5)
+ [Listing 10.6 The implementation of the task to which the interrupt processing is deferred (the task...](ch10-任务通知.md#list10.6)
+ [Listing 10.7 The implementation of the interrupt service routine used in Example 10.2](ch10-任务通知.md#list10.7)
+ [Listing 10.8 Prototypes for the xTaskNotify() and xTaskNotifyFromISR() API functions](ch10-任务通知.md#list10.8)
+ [Listing 10.9 The xTaskNotifyWait() API function prototype](ch10-任务通知.md#list10.9)
+ [Listing 10.10 Pseudo code demonstrating how a binary semaphore can be used in a driver library transmit...](ch10-任务通知.md#list10.10)
+ [Listing 10.11 Pseudo code demonstrating how a task notification can be used in a driver library transmit...](ch10-任务通知.md#list10.11)
+ [Listing 10.12 Pseudo code demonstrating how a task notification can be used in a driver library receive...](ch10-任务通知.md#list10.12)
+ [Listing 10.13 Pseudo code demonstrating how a task notification can be used to pass a value to a task](ch10-任务通知.md#list10.13)
+ [Listing 10.14 The structure and data type sent on a queue to the server task](ch10-任务通知.md#list10.14)
+ [Listing 10.15 The Implementation of the Cloud Read API Function](ch10-任务通知.md#list10.15)
+ [Listing 10.16 The Server Task Processing a Read Request](ch10-任务通知.md#list10.16)
+ [Listing 10.17 The Implementation of the Cloud Write API Function](ch10-任务通知.md#list10.17)
+ [Listing 10.18 The Server Task Processing a Send Request](ch10-任务通知.md#list10.18)
+ [Listing 11.1 The prototype for the portSUPPRESS\_TICKS\_AND\_SLEEP macro](ch11-低功耗支持.md#list11.1)
+ [Listing 11.2 The vPortSuppressTicksAndSleep API function prototype](ch11-低功耗支持.md#list11.2)
+ [Listing 11.3 The eTaskConfirmSleepModeStatus API function prototype](ch11-低功耗支持.md#list11.3)
+ [Listing 11.4 The prototype for the configPRE\_SLEEP\_PROCESSING macro](ch11-低功耗支持.md#list11.4)
+ [Listing 11.5 The prototype for the configPOST\_SLEEP\_PROCESSING macro](ch11-低功耗支持.md#list11.5)
+ [Listing 11.6 An example of a user defined implementation of portSUPPRESS\_TICKS\_AND\_SLEEP()](ch11-低功耗支持.md#list11.6)
+ [Listing 11.7 The vApplicationIdleHook API function prototype](ch11-低功耗支持.md#list11.7)
+ [Listing 12.1 Using the standard C assert() macro to check pxMyPointer is not NULL](ch12-开发者支持.md#list12.1)
+ [Listing 12.2 A simple configASSERT() definition useful when executing under the control of a debugger](ch12-开发者支持.md#list12.2)
+ [Listing 12.3 A configASSERT() definition that records the source code line that failed an assertion](ch12-开发者支持.md#list12.3)
+ [Listing 12.4 The uxTaskGetSystemState() API function prototype](ch12-开发者支持.md#list12.4)
+ [Listing 12.5 The TaskStatus\_t structure](ch12-开发者支持.md#list12.5)
+ [Listing 12.6 The vTaskListTasks() API function prototype](ch12-开发者支持.md#list12.6)
+ [Listing 12.7 The vTaskList() API function prototype](ch12-开发者支持.md#list12.7)
+ [Listing 12.8 The vTaskGetRunTimeStatistics() API function prototype](ch12-开发者支持.md#list12.8)
+ [Listing 12.9 The vTaskGetRunTimeStats() API function prototype](ch12-开发者支持.md#list12.9)
+ [Listing 12.10 16-bit timer overflow interrupt handler used to count timer overflows](ch12-开发者支持.md#list12.10)
+ [Listing 12.11 Macros added to FreeRTOSConfig.h to enable the collection of run-time statistics](ch12-开发者支持.md#list12.11)
+ [Listing 12.12 The task that prints out the collected run-time statistics](ch12-开发者支持.md#list12.12)
+ [Listing 13.1 The uxTaskGetStackHighWaterMark() API function prototype](ch13-故障排查.md#list13.1)
+ [Listing 13.2 The uxTaskGetStackHighWaterMark2() API function prototype](ch13-故障排查.md#list13.2)
+ [Listing 13.3 The stack overflow hook function prototype](ch13-故障排查.md#list13.3)

## 表格:
+ [Table 1 FreeRTOS source files to include in the project](ch02-FreeRTOS%20内核分发包.md#tbl1)
+ [Table 2 TickType\_t data type and the configTICK\_TYPE\_WIDTH\_IN\_BITS configuration](ch02-FreeRTOS%20内核分发包.md#tbl2)
+ [Table 3 Macro prefixes](ch02-FreeRTOS%20内核分发包.md#tbl3)
+ [Table 4 Common macro definitions](ch02-FreeRTOS%20内核分发包.md#tbl4)
+ [Table 5 The FreeRTOSConfig.h settings to configure the kernel scheduling algorithms](ch04-任务管理.md#tbl5)
+ [Table 6 The Effect of the uxBitsToWaitFor and xWaitForAllBits Parameters](ch09-事件组.md#tbl6)