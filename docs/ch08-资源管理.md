# 8 资源管理

## 8.1 章节介绍与范围

在多任务系统中，若某任务开始访问资源，但在完成访问前被切出 *Running* 状态，
就可能引发错误。如果任务将资源置于不一致状态，那么任何其他任务或中断访问同一资源时
可能导致数据损坏或类似问题。

以下是一些示例：

* 访问外设

  假设两个任务尝试向 LCD 写数据：

  1. 任务 A 执行并开始写字符串 “Hello world”。

  2. 任务 A 刚输出 “Hello w” 就被任务 B 抢占。

  3. 任务 B 在进入 *Blocked* 状态前向 LCD 写入 “Abort, Retry, Fail?”。

  4. 任务 A 从被抢占处继续执行，输出剩余字符串 “orld”。

  LCD 将显示被破坏的字符串 “Hello wAbort, Retry, Fail?orld”。

* 读-改-写操作

  清单 8.1 展示一行 C 代码及其典型的汇编翻译。可见 PORTA 的值先从内存读入寄存器，
  在寄存器中修改，然后写回内存。这称为读-改-写操作。


	<a name="list8.1" title="Listing 8.1 An example read, modify, write sequence"></a>

	```c
	/* 正在编译的 C 代码。 */
	PORTA |= 0x01;

	/* C 代码编译后生成的汇编代码。 */
	LOAD  R1,[#PORTA] ; 将 PORTA 的值读入 R1
	MOVE  R2,#0x01    ; 将常量 1 装入 R2
	OR    R1,R2       ; 将 R1（PORTA）与 R2（常量 1）做按位或
	STORE R1,[#PORTA] ; 将新值写回 PORTA
	```
	***清单 8.1*** *读-改-写序列示例*
 
	这是一个“非原子”操作，因为完成它需要多条指令且可能被中断。考虑如下场景，
	两个任务尝试更新名为 PORTA 的内存映射寄存器：

	1. 任务 A 读取 PORTA 值到寄存器——读操作。

	2. 任务 A 在完成改写前被任务 B 抢占。

	3. 任务 B 更新 PORTA，然后进入 *Blocked* 状态。

	4. 任务 A 从被抢占处继续执行。它修改寄存器中已有的 PORTA 值副本并写回 PORTA。

	在该场景中，任务 A 将过期的 PORTA 值写回。任务 B 在任务 A 读取 PORTA 之后、
	写回之前修改了 PORTA。任务 A 写回时覆盖了任务 B 的修改，导致 PORTA 值被破坏。

	本例使用外设寄存器，但同样原理也适用于变量的读-改-写操作。

- 对变量的非原子访问

  更新结构体中的多个成员，或更新大于体系结构自然字长的变量（例如在 16 位机上更新
  32 位变量），都是非原子操作。若被中断，可能导致数据丢失或损坏。

- 函数可重入性

  若函数可被多个任务调用，或可被任务与中断同时调用且安全，则称其“可重入”。
  可重入函数被称为“线程安全”，因为可在多个执行线程中访问而不会破坏数据或逻辑。

  每个任务维护自身的栈与处理器（硬件）寄存器值。如果函数只访问栈上或寄存器中的数据，
  则该函数可重入且线程安全。清单 8.2 为可重入函数示例；清单 8.3 为不可重入函数示例。
  
  若应用使用 newlib C 库，必须在 FreeRTOSConfig.h 中将 `configUSE_NEWLIB_REENTRANT`
  设为 1，以确保 newlib 所需的线程本地存储（TLS）正确分配。

  若应用使用 picolibc C 库，必须在 FreeRTOSConfig.h 中将 `configUSE_PICOLIBC_TLS`
  设为 1，以确保 picolibc 所需的线程本地存储（TLS）正确分配。

  若应用使用其他 C 库且需要线程本地存储（TLS），必须在 FreeRTOSConfig.h 中将
  `configUSE_C_RUNTIME_TLS_SUPPORT` 设为 1，并实现以下宏：
  - `configTLS_BLOCK_TYPE` - 每个任务的 TLS 块类型。
  - `configINIT_TLS_BLOCK` - 初始化每任务 TLS 块。
  - `configSET_TLS_BLOCK` - 更新当前 TLS 块。该宏在上下文切换时调用，确保使用正确
	 TLS 块。
  - `configDEINIT_TLS_BLOCK` - 释放 TLS 块。


  <a name="list8.2" title="Listing 8.2 An example of a reentrant function"></a>

  ```c
  /* 有一个参数传入该函数。它要么通过栈传递，要么通过处理器寄存器传递。
	  这两种方式都安全，因为每个调用该函数的任务或中断都维护自己的栈和寄存器值，
	  因此每个调用该函数的任务或中断都有各自的 lVar1 副本。 */
  long lAddOneHundred( long lVar1 )
  {
		/* 该函数作用域变量也会分配在栈或寄存器中，具体取决于
			 编译器与优化级别。每个调用该函数的任务或中断都有各自的
			 lVar2 副本。 */
		long lVar2;

		lVar2 = lVar1 + 100;
		return lVar2;
  }
  ```
  ***清单 8.2*** *可重入函数示例*


  <a name="list8.3" title="Listing 8.3 An example of a function that is not reentrant"></a>

  ```c
  /* 此处 lVar1 为全局变量，因此所有调用 lNonsenseFunction 的任务
	  都会访问同一份变量副本。 */
  long lVar1;

  long lNonsenseFunction( void )
  {
		/* lState 为 static，不会分配在栈上。每个调用该函数的任务
			 都会访问同一份变量副本。 */
		static long lState = 0;
		long lReturn;

		switch( lState )
		{
			 case 0 : lReturn = lVar1 + 10;
						 lState = 1;
						 break;

			 case 1 : lReturn = lVar1 + 20;
						 lState = 0;
						 break;
		}
  }
  ```
  ***清单 8.3*** *不可重入函数示例*


### 8.1.1 互斥

为确保数据一致性，共享资源（在任务之间共享，或在任务与中断之间共享）必须通过
“互斥”技术进行管理。目标是：一旦任务开始访问一个不可重入、非线程安全的共享资源，
就能独占该资源直到其恢复到一致状态。

FreeRTOS 提供多种功能实现互斥，但最优方法（在可能时，尽管通常不易做到）是通过
应用设计避免共享资源，让每个资源只由一个任务访问。


### 8.1.2 范围

本章涵盖：

- 何时以及为何需要资源管理与控制。
- 什么是临界区。
- 互斥的含义。
- 挂起调度器意味着什么。
- 如何使用互斥量。
- 如何创建与使用看门人任务。
- 什么是优先级反转，以及优先级继承如何减轻（但无法消除）其影响。


## 8.2 临界区与挂起调度器

### 8.2.1 基本临界区

基本临界区是由宏 `taskENTER_CRITICAL()` 与 `taskEXIT_CRITICAL()` 包围的代码区域。
临界区也称为临界区域。

`taskENTER_CRITICAL()` 与 `taskEXIT_CRITICAL()` 不带参数，也不返回值[^23]。
其用法见清单 8.4。

[^23]: 类函数宏与真实函数不同，严格来说不“返回值”。为便于理解，
本书在将宏视作函数更易理解时，也使用“返回值”一词描述。


<a name="list8.4" title="Listing 8.4 Using a critical section to guard access to a register"></a>

```c
/* 通过放入临界区确保对 PORTA 寄存器的访问不会被中断。进入临界区。 */
taskENTER_CRITICAL();

/* 在调用 taskENTER_CRITICAL() 与 taskEXIT_CRITICAL() 之间不会切换到其他任务。
	 在允许中断嵌套的 FreeRTOS 移植中，中断仍可执行，但仅限逻辑优先级
	 高于 configMAX_SYSCALL_INTERRUPT_PRIORITY 常量所设定值的中断——
	 且这些中断不允许调用 FreeRTOS API 函数。 */
PORTA |= 0x01;

/* 访问 PORTA 完成，因此可以安全退出临界区。 */
taskEXIT_CRITICAL();
```
***清单 8.4*** *使用临界区保护寄存器访问*


本书配套示例项目使用 `vPrintString()` 向标准输出（使用 FreeRTOS Windows 移植时即
终端窗口）输出字符串。`vPrintString()` 被多个任务调用，因此理论上其实现可用
临界区保护标准输出，如清单 8.5。


<a name="list8.5" title="Listing 8.5 A possible implementation of vPrintString()"></a>

```c
void vPrintString( const char *pcString )
{
	 /* 将字符串写入 stdout，使用临界区作为一种粗略的互斥方法。 */
	 taskENTER_CRITICAL();
	 {
		  printf( "%s", pcString );
		  fflush( stdout );
	 }
	 taskEXIT_CRITICAL();
}
```
***清单 8.5*** *vPrintString() 的一种可能实现*


以这种方式实现的临界区是一种非常粗糙的互斥方法。它通过禁用中断实现，
或在某些移植上禁用到 `configMAX_SYSCALL_INTERRUPT_PRIORITY` 为止的中断。
抢占式上下文切换只能在中断中发生，因此只要中断保持禁用，调用
`taskENTER_CRITICAL()` 的任务就保证一直处于 *Running* 状态，直到退出临界区。

基本临界区必须非常短，否则会影响中断响应时间。每次 `taskENTER_CRITICAL()` 必须
与 `taskEXIT_CRITICAL()` 紧密配对。因此，不应像清单 8.5 那样用临界区保护
标准输出（stdout，或计算机写出输出数据的流），因为写终端可能是相对耗时的操作。
本章示例将探索替代方案。

临界区可以嵌套使用，因为内核会记录嵌套深度。只有当嵌套深度回到 0 时，临界区才会
真正退出，即每次 `taskENTER_CRITICAL()` 都必须对应一次 `taskEXIT_CRITICAL()`。

在运行 FreeRTOS 的处理器上，任务唯一合法的修改中断使能状态方式就是调用
`taskENTER_CRITICAL()` 与 `taskEXIT_CRITICAL()`。以其他方式改变中断使能状态会
破坏宏的嵌套计数。

`taskENTER_CRITICAL()` 与 `taskEXIT_CRITICAL()` 名称不含 “FromISR”，因此不得在 ISR
中调用。`taskENTER_CRITICAL_FROM_ISR()` 是 `taskENTER_CRITICAL()` 的中断安全版本，
`taskEXIT_CRITICAL_FROM_ISR()` 是 `taskEXIT_CRITICAL()` 的中断安全版本。
中断安全版本仅在允许中断嵌套的移植中提供——在不允许嵌套的移植中没有意义。

`taskENTER_CRITICAL_FROM_ISR()` 会返回一个值，必须传给对应的
`taskEXIT_CRITICAL_FROM_ISR()`。清单 8.6 演示了该用法。


<a name="list8.6" title="Listing 8.6 Using a critical section in an interrupt service routine"></a>

```c
void vAnInterruptServiceRoutine( void )
{
	 /* 声明一个变量，用于保存 taskENTER_CRITICAL_FROM_ISR() 的返回值。 */
	 UBaseType_t uxSavedInterruptStatus;

	 /* ISR 的这部分可以被任意更高优先级中断打断。 */

	 /* 使用 taskENTER_CRITICAL_FROM_ISR() 保护 ISR 的某段区域。
		 保存其返回值，以便传给匹配的 taskEXIT_CRITICAL_FROM_ISR()。 */
	 uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();

	 /* ISR 的这部分位于 taskENTER_CRITICAL_FROM_ISR() 与
		 taskEXIT_CRITICAL_FROM_ISR() 之间，因此只能被逻辑优先级
		 高于 configMAX_SYSCALL_INTERRUPT_PRIORITY 常量所设定值的
		 中断打断。 */

	 /* 通过调用 taskEXIT_CRITICAL_FROM_ISR() 退出临界区，
		 并传入与之匹配的 taskENTER_CRITICAL_FROM_ISR() 的返回值。 */
	 taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus );

	 /* ISR 的这部分可以被任意更高优先级中断打断。 */
}
```
***清单 8.6*** *在 ISR 中使用临界区*


若进入与退出临界区所耗的处理时间多于被保护代码本身，则非常浪费。
基本临界区进入与退出都非常快，且确定性强，因此适合保护极短代码段。


### 8.2.2 挂起（或锁定）调度器

临界区也可通过挂起调度器来实现。挂起调度器有时也称为“锁定”调度器。

基本临界区会同时防止其他任务与中断访问代码区域，而通过挂起调度器实现的临界区
仅防止其他任务访问，因为中断仍然使能。

若代码区域过长，不适合简单禁用中断，则可通过挂起调度器来实现临界区。然而，
当调度器挂起时，中断活动会使恢复（“解除挂起”）调度器成为相对耗时的操作，
因此需权衡使用哪种方法。


### 8.2.3 vTaskSuspendAll() API 函数


<a name="list8.7" title="Listing 8.7 The vTaskSuspendAll() API function prototype"></a>

```c
void vTaskSuspendAll( void );
```
***清单 8.7*** *vTaskSuspendAll() API 函数原型*


调用 `vTaskSuspendAll()` 挂起调度器。挂起调度器会阻止上下文切换发生，但保持中断
使能。若中断在调度器挂起期间请求上下文切换，该请求会被挂起，直到调度器恢复后才
执行。

调度器挂起期间不得调用 FreeRTOS API 函数。


### 8.2.4 xTaskResumeAll() API 函数


<a name="list8.8" title="Listing 8.8 The xTaskResumeAll() API function prototype"></a>

```c
BaseType_t xTaskResumeAll( void );
```
***清单 8.8*** *xTaskResumeAll() API 函数原型*


调用 `xTaskResumeAll()` 恢复（解除挂起）调度器。

**xTaskResumeAll() 返回值**

- 返回值

  在调度器挂起期间请求的上下文切换会被挂起，并在恢复调度器时执行。
  若在 `xTaskResumeAll()` 返回之前执行了挂起的上下文切换，则返回 `pdTRUE`，
  否则返回 `pdFALSE`。

`vTaskSuspendAll()` 与 `xTaskResumeAll()` 可嵌套使用，内核会记录嵌套深度。
只有当嵌套深度回到 0 时调度器才会恢复——即每次 `vTaskSuspendAll()` 必须对应一次
`xTaskResumeAll()`。

清单 8.9 展示 `vPrintString()` 的真实实现，它通过挂起调度器来保护对终端输出的访问。


<a name="list8.9" title="Listing 8.9 The implementation of vPrintString()"></a>

```c
void vPrintString( const char *pcString )
{
	 /* 将字符串写入 stdout，通过挂起调度器实现互斥。 */
	 vTaskSuspendScheduler();
	 {
		  printf( "%s", pcString );
		  fflush( stdout );
	 }
	 xTaskResumeScheduler();
}
```
***清单 8.9*** *vPrintString() 的实现*


## 8.3 互斥量（及二值信号量）

互斥量（Mutex）是一种特殊的二值信号量，用于控制多个任务共享资源的访问。
MUTEX 一词源自 “MUTual EXclusion”。必须在 FreeRTOSConfig.h 中将 `configUSE_MUTEXES`
设为 1 才可使用互斥量。

在互斥场景中，可将互斥量视为与共享资源关联的令牌。任务要合法访问资源，必须先
成功“获取”令牌（成为持有者）。持有者完成资源使用后必须“归还”令牌。只有令牌归还后，
其他任务才能成功获取并安全访问同一资源。任务不允许在不持有令牌时访问共享资源。
该机制见图 8.1。

尽管互斥量与二值信号量有许多共同特性，但图 8.1（互斥量用于互斥）与图 7.6
（二值信号量用于同步）是完全不同的场景。主要区别在于获取信号量后的处理方式：

- 用于互斥的信号量必须始终归还。
- 用于同步的信号量通常被消耗而不归还。


<a name="fig8.1" title="Figure 8.1 Mutual exclusion implemented using a mutex"></a>

* * *
![](media/image63.png)   
***图 8.1*** *使用互斥量实现互斥*
* * *

该机制完全依赖应用编写者的约束。任务随时可以访问资源，但每个任务都“约定”
只有在成为互斥量持有者后才访问。


### 8.3.1 xSemaphoreCreateMutex() API 函数

FreeRTOS 还提供 `xSemaphoreCreateMutexStatic()`，用于在编译期静态分配创建互斥量
所需内存：互斥量也是一种信号量，各类信号量句柄存放在 `SemaphoreHandle_t` 类型变量中。

互斥量在使用前必须先创建。创建互斥量使用 `xSemaphoreCreateMutex()` API 函数。


<a name="list8.10" title="Listing 8.10 The xSemaphoreCreateMutex() API function prototype"></a>

```c
SemaphoreHandle_t xSemaphoreCreateMutex( void );
```
***清单 8.10*** *xSemaphoreCreateMutex() API 函数原型*


**xSemaphoreCreateMutex() 返回值**

- 返回值

  若返回 NULL，则表示堆内存不足，无法为互斥量分配数据结构。第 3 章提供
  更多堆内存管理信息。

  若返回非 NULL，则表示互斥量创建成功，返回值应保存为该互斥量句柄。


<a name="example8.1" title="Example 8.1 Rewriting vPrintString() to use a semaphore"></a>
---
***示例 8.1*** *使用信号量重写 vPrintString()*

---

该示例创建 `vPrintString()` 的新版本 `prvNewPrintString()`，并由多个任务调用。
`prvNewPrintString()` 在功能上等同 `vPrintString()`，但使用互斥量控制对标准输出
的访问，而不是锁定调度器。其实现见清单 8.11。


<a name="list8.11" title="Listing 8.11 The implementation of prvNewPrintString()"></a>

```c
static void prvNewPrintString( const char *pcString )
{
	 /* 互斥量在调度器启动前创建，因此该任务执行时已存在。

		 尝试获取互斥量，若暂不可用则无限期阻塞等待。
		 xSemaphoreTake() 仅在成功获取互斥量时返回，因此无需检查
		 返回值。若使用其他延迟时间，则代码必须在访问共享资源
		 （此处为标准输出）前检查 xSemaphoreTake() 是否返回 pdTRUE。
		 如本书前文所述，不建议在生产代码中使用无限期超时。 */
	 xSemaphoreTake( xMutex, portMAX_DELAY );
	 {
		  /* 下面这一行仅在成功获取互斥量后执行。此时可自由访问标准输出，
			  因为任意时刻只有一个任务持有该互斥量。 */
		  printf( "%s", pcString );
		  fflush( stdout );

		  /* 互斥量必须归还！ */
	 }
	 xSemaphoreGive( xMutex );
}
```
***清单 8.11*** *prvNewPrintString() 的实现*


`prvNewPrintString()` 由 `prvPrintTask()` 的两个任务实例反复调用。每次调用之间
使用随机延时。任务参数用于传入每个任务的唯一字符串。`prvPrintTask()` 实现见
清单 8.12。


<a name="list8.12" title="Listing 8.12 The implementation of prvPrintTask() for Example 8.1"></a>

```c
static void prvPrintTask( void *pvParameters )
{
	 char *pcStringToPrint;
	 const TickType_t xMaxBlockTimeTicks = 0x20;

	 /* 创建该任务的两个实例。任务要打印的字符串通过任务参数传入，
		 参数被转换为所需类型。 */
	 pcStringToPrint = ( char * ) pvParameters;

	 for( ;; )
	 {
		  /* 使用新定义的函数打印字符串。 */
		  prvNewPrintString( pcStringToPrint );

		  /* 等待一个伪随机时间。注意 rand() 不一定可重入，但在本例中无关紧要，
			  因为代码并不关心返回值。在更严格的应用中，应使用可重入的 rand()
			  版本，或用临界区保护对 rand() 的调用。 */
		  vTaskDelay( ( rand() % xMaxBlockTimeTicks ) );
	 }
}
```
***清单 8.12*** *示例 8.1 的 prvPrintTask() 实现*


如常，`main()` 仅创建互斥量、创建任务，然后启动调度器。实现见清单 8.13。

两个 `prvPrintTask()` 实例以不同优先级创建，因此低优先级任务会偶尔被高优先级任务
抢占。使用互斥量确保每次只有一个任务访问终端，即便发生抢占，显示的字符串也会正确
且不会被破坏。通过降低任务 *Blocked* 状态的最长时间（由 `xMaxBlockTimeTicks` 指定）
可提高抢占频率。

使用 FreeRTOS Windows 移植运行示例 8.1 的注意事项：

- 调用 `printf()` 会产生 Windows 系统调用。Windows 系统调用不受 FreeRTOS 控制，
  可能引入不稳定性。

- 由于 Windows 系统调用执行方式，即便不使用互斥量，也很少出现字符串破坏。


<a name="list8.13" title="Listing 8.13 The implementation of main() for Example 8.1"></a>

```c
int main( void )
{
	 /* 使用信号量前必须显式创建。本例创建互斥量类型的信号量。 */
	 xMutex = xSemaphoreCreateMutex();

	 /* 在创建任务前检查信号量是否创建成功。 */
	 if( xMutex != NULL )
	 {
		  /* 创建两个向 stdout 写入的任务实例。任务要写入的字符串通过
			  任务参数传入。任务以不同优先级创建，因此会发生一定的抢占。 */
		  xTaskCreate( prvPrintTask, "Print1", 1000,
							"Task 1 ***************************************\r\n",
							1, NULL );

		  xTaskCreate( prvPrintTask, "Print2", 1000,
							"Task 2 ---------------------------------------\r\n", 
							2, NULL );

		  /* 启动调度器，使已创建的任务开始执行。 */
		  vTaskStartScheduler();
	 }

	 /* 如果一切正常，调度器将运行任务，main() 不会到达这里。
		 若 main() 到达此处，很可能是堆内存不足以创建空闲任务。
		 第 3 章提供了更多堆内存管理信息。 */
	 for( ;; );
}
```
***清单 8.13*** *示例 8.1 的 main() 实现*


示例 8.1 的输出如图 8.2 所示。图 8.3 描述了一种可能的执行序列。

<a name="fig8.2" title="Figure 8.2 The output produced when Example 8.1 is executed"></a>

* * *
![](media/image64.jpg)   
***图 8.2*** *示例 8.1 的输出*
* * *

图 8.2 显示，正如预期，终端显示的字符串未发生破坏。随机顺序来自任务使用的随机延时。


<a name="fig8.3" title="Figure 8.3 A possible sequence of execution for Example 8.1"></a>

* * *
![](media/image65.png)   
***图 8.3*** *示例 8.1 的一种可能执行序列*
* * *


### 8.3.2 优先级反转

图 8.3 展示了使用互斥量实现互斥的潜在陷阱之一。执行序列表明高优先级任务 2 需等待
低优先级任务 1 释放互斥量。高优先级任务被低优先级任务延迟称为“优先级反转”。
若在高优先级任务等待信号量时，出现一个中等优先级任务开始执行，则该不良行为会被
进一步放大——高优先级任务等待低优先级任务，而低优先级任务却甚至无法执行。
这通常称为“无界优先级反转”，因为中等优先级任务可无限期阻塞低、高优先级任务。
该最坏场景如图 8.4。


<a name="fig8.4" title="Figure 8.4 A worst case priority inversion scenario"></a>

* * *
![](media/image66.png)   
***图 8.4*** *最坏情况下的优先级反转场景*
* * *

优先级反转可能是严重问题，但在小型嵌入式系统中往往可在系统设计阶段通过考虑
资源访问方式来避免。


### 8.3.3 优先级继承

FreeRTOS 互斥量与二值信号量非常相似——区别在于互斥量包含基本的“优先级继承”机制，
而二值信号量没有。优先级继承用于减轻优先级反转的负面影响。它不能“修复”优先级反转，
只是将其影响限定在有界时间内。不过，优先级继承会使系统时序分析更复杂，也不应依赖
它来保证系统正确性。

优先级继承通过临时提高互斥量持有者的优先级到等待该互斥量的最高优先级任务，
使持有互斥量的低优先级任务“继承”高优先级任务的优先级。该机制如图 8.5 所示。
当互斥量归还后，持有者优先级会自动恢复到原值。


<a name="fig8.5" title="Figure 8.5 Priority inheritance minimizing the effect of priority inversion"></a>

* * *
![](media/image67.png)   
***图 8.5*** *优先级继承减轻优先级反转影响*
* * *

如前所述，优先级继承会影响使用互斥量的任务优先级。因此互斥量不得在 ISR 中使用。

FreeRTOS 实现了基本优先级继承机制，设计时兼顾空间与执行周期优化。完整的优先级
继承机制需要更多数据与处理器周期来随时确定继承优先级，尤其在任务同时持有多个
互斥量时。

优先级继承机制的具体行为需注意：
* 如果任务在未释放已持有互斥量的情况下再获取互斥量，其继承优先级可进一步提高。
* 只要任务还持有任意互斥量，就会保持其最高继承优先级，与释放互斥量的顺序无关。
* 若任务持有多个互斥量，即使等待这些互斥量的任务完成等待（超时），任务仍会保持
  最高继承优先级。


### 8.3.4 死锁（或致命拥抱）

使用互斥量实现互斥的另一个陷阱是“死锁”（有时称为“致命拥抱”）。

当两个任务都在等待对方持有的资源而无法继续时就发生死锁。考虑以下场景：
任务 A 与任务 B 执行动作时都需要同时获取互斥量 X *与* 互斥量 Y：

1. 任务 A 执行并成功获取互斥量 X。

2. 任务 A 被任务 B 抢占。

3. 任务 B 成功获取互斥量 Y，并尝试获取互斥量 X——但互斥量 X 被任务 A 持有，
	任务 B 选择进入 *Blocked* 状态等待 X 被释放。

4. 任务 A 继续执行，尝试获取互斥量 Y——但 Y 被任务 B 持有，任务 A 选择进入
	*Blocked* 状态等待 Y 被释放。

在该场景结束时，任务 A 等待任务 B 持有的互斥量，任务 B 等待任务 A 持有的互斥量。
发生死锁，因为两个任务都无法继续。

与优先级反转类似，避免死锁的最佳方式是在设计阶段就考虑其可能性，并设计系统
确保死锁不发生。尤其是，如本书前面所述，任务无限期（无超时）等待互斥量通常是
不良实践。应使用稍长于预期最长等待时间的超时——若在该时间内无法获得互斥量，
则可能是设计错误（例如死锁）的症状。

在实践中，死锁在小型嵌入式系统中通常不是大问题，因为系统设计者能够理解完整应用，
并识别、消除可能发生死锁的区域。


### 8.3.5 递归互斥量

任务也可能与自己死锁。这会发生在任务在未归还互斥量前就多次获取同一互斥量。
考虑以下场景：

1. 任务成功获取互斥量。

2. 任务在持有互斥量时调用库函数。

3. 库函数实现尝试获取同一互斥量，并进入 *Blocked* 状态等待该互斥量可用。

在该场景末尾，任务在等待互斥量归还，但自己就是持有者，发生死锁。

可通过使用递归互斥量替代普通互斥量来避免该类死锁。递归互斥量允许同一任务多次
“获取”，且只有在每次“获取”对应的“释放”调用都执行后，互斥量才会真正归还。

普通互斥量与递归互斥量的创建和使用方式类似：

- 普通互斥量使用 `xSemaphoreCreateMutex()` 创建；递归互斥量使用
  `xSemaphoreCreateRecursiveMutex()` 创建。两者原型相同。

- 普通互斥量用 `xSemaphoreTake()` 获取；递归互斥量用 `xSemaphoreTakeRecursive()`
  获取。两者原型相同。

- 普通互斥量用 `xSemaphoreGive()` 释放；递归互斥量用 `xSemaphoreGiveRecursive()`
  释放。两者原型相同。

清单 8.14 展示如何创建并使用递归互斥量。


<a name="list8.14" title="Listing 8.14 Creating and using a recursive mutex"></a>

```c
/* 递归互斥量是 SemaphoreHandle_t 类型的变量。 */
SemaphoreHandle_t xRecursiveMutex;

/* 创建并使用递归互斥量的任务实现。 */
void vTaskFunction( void *pvParameters )
{
	 const TickType_t xMaxBlock20ms = pdMS_TO_TICKS( 20 );

	 /* 使用递归互斥量前必须显式创建。 */
	 xRecursiveMutex = xSemaphoreCreateRecursiveMutex();

	 /* 检查信号量是否创建成功。configASSERT() 见第 11.2 节。 */
	 configASSERT( xRecursiveMutex );

	 /* 与多数任务一样，该任务以无限循环实现。 */
	 for( ;; )
	 {
		  /* ... */

		  /* 获取递归互斥量。 */
		  if( xSemaphoreTakeRecursive( xRecursiveMutex, xMaxBlock20ms ) == pdPASS )
		  {
				/* 递归互斥量获取成功。任务现在可以访问互斥量保护的资源。
					 此时递归调用计数（即嵌套调用 xSemaphoreTakeRecursive()
					 的次数）为 1，因为递归互斥量只被获取了一次。 */

				/* 当任务已持有递归互斥量时，再次获取它。在实际应用中，
					 这通常只会发生在该任务调用的子函数中，因为没有必要
					 反复获取同一互斥量。调用任务已是持有者，因此第二次
					 调用 xSemaphoreTakeRecursive() 只是将递归调用计数增加到 2。 */
				xSemaphoreTakeRecursive( xRecursiveMutex, xMaxBlock20ms );

				/* ... */

				/* 任务完成对资源的访问后归还互斥量。此时递归调用计数为 2，
					 因此第一次调用 xSemaphoreGiveRecursive() 不会真正归还互斥量，
					 只是将递归调用计数减回 1。 */
				xSemaphoreGiveRecursive( xRecursiveMutex );

				/* 下一次调用 xSemaphoreGiveRecursive() 将递归调用计数减至 0，
					 此时递归互斥量才真正归还。 */
				xSemaphoreGiveRecursive( xRecursiveMutex );

				/* 现在每一次 xSemaphoreTakeRecursive() 都有对应的
					 xSemaphoreGiveRecursive() 执行完毕，任务不再是互斥量持有者。 */
		  }
	 }
}
```
***清单 8.14*** *创建并使用递归互斥量*


### 8.3.6 互斥量与任务调度

若不同优先级的两个任务使用同一互斥量，FreeRTOS 调度策略明确执行顺序：
最高优先级且可运行的任务会进入 *Running* 状态。例如高优先级任务因等待
低优先级任务持有的互斥量而阻塞时，一旦低优先级任务归还互斥量，高优先级任务
会立即抢占并成为互斥量持有者。该场景已在图 8.5 中展示。

然而，当任务具有相同优先级时，人们常对执行顺序做出错误假设。若任务 1 和任务 2
优先级相同，任务 1 因等待任务 2 持有的互斥量而阻塞，那么任务 2 “释放”互斥量时，
任务 1 不会抢占任务 2。相反，任务 2 保持 *Running* 状态，任务 1 只从 *Blocked*
转到 *Ready*。该场景如图 8.6 所示，竖线表示 tick 中断发生的时刻。


<a name="fig8.6" title="Figure 8.6 A possible sequence of execution when tasks that have the same priority use the same mutex"></a>

* * *
![](media/image68.png)   
***图 8.6*** *相同优先级任务使用同一互斥量时的一种可能执行序列*
* * *

在图 8.6 所示场景中，FreeRTOS 调度器不会在互斥量可用时立即让任务 1 进入 *Running*
状态，原因是：

- 任务 1 与任务 2 优先级相同，因此除非任务 2 进入 *Blocked* 状态，否则不会切换到
  任务 1，直到下一次 tick 中断（假设 FreeRTOSConfig.h 中 `configUSE_TIME_SLICING`
  设为 1）。

- 若任务在紧循环中使用互斥量，且每次“释放”互斥量都发生上下文切换，那么任务
  仅能短时间处于 *Running* 状态。若两个或更多任务在紧循环中使用同一互斥量，
  则会因频繁切换而浪费处理时间。

若多个任务在紧循环中使用同一互斥量且优先级相同，必须注意保证任务获得大致相等
的处理时间。任务可能无法获得相等处理时间的原因如图 8.7 所示：若以相同优先级
创建清单 8.15 所示任务的两个实例，可能出现图 8.7 的执行序列。


<a name="list8.15" title="Listing 8.15 A task that uses a mutex in a tight loop"></a>

```c
/* 在紧循环中使用互斥量的任务实现。该任务在本地缓冲区生成字符串，
	 然后将字符串写入显示设备。对显示的访问由互斥量保护。 */

void vATask( void *pvParameter )
{
	 extern SemaphoreHandle_t xMutex;
	 char cTextBuffer[ 128 ];

	 for( ;; )
	 {
		  /* 生成字符串——这是一个快速操作。 */
		  vGenerateTextInALocalBuffer( cTextBuffer );

		  /* 获取用于保护显示访问的互斥量。 */
		  xSemaphoreTake( xMutex, portMAX_DELAY );

		  /* 将生成的文本写入显示设备——这是一个慢操作。 */
		  vCopyTextToFrameBuffer( cTextBuffer );

		  /* 文本已写入显示设备，因此归还互斥量。 */
		  xSemaphoreGive( xMutex );
	 }
}
```
***清单 8.15*** *在紧循环中使用互斥量的任务*


清单 8.15 的注释说明：生成字符串是快速操作，更新显示是慢操作。因此任务在更新
显示期间持有互斥量，占据其大部分运行时间。

在图 8.7 中，竖线表示 tick 中断发生的时刻。


<a name="fig8.7" title="Figure 8.7 A sequence of execution that could occur if two instances of the task shown by Listing 8.15 are created at the same priority"></a>

* * *
![](media/image69.png)   
***图 8.7*** *若以相同优先级创建清单 8.15 中任务的两个实例时可能出现的执行序列*
* * *

图 8.7 的步骤 7 显示任务 1 重新进入 *Blocked* 状态——这是在 `xSemaphoreTake()`
API 函数内部发生的。

图 8.7 表明：任务 1 直到时间片开始时刻恰好落在任务 2 不持有互斥量的短暂时间段，
才可能获取该互斥量。

可在 `xSemaphoreGive()` 后添加 `taskYIELD()` 来避免图 8.7 的场景。清单 8.16
展示了该方法：若任务持有互斥量期间 tick 计数发生变化，则调用 `taskYIELD()`。


<a name="list8.16" title="Listing 8.16 Ensuring tasks that use a mutex in a loop receive a more equal amount of processing time..."></a>

```c
void vFunction( void *pvParameter )
{
	 extern SemaphoreHandle_t xMutex;
	 char cTextBuffer[ 128 ];
	 TickType_t xTimeAtWhichMutexWasTaken;

	 for( ;; )
	 {
		  /* 生成字符串——这是一个快速操作。 */
		  vGenerateTextInALocalBuffer( cTextBuffer );

		  /* 获取用于保护显示访问的互斥量。 */
		  xSemaphoreTake( xMutex, portMAX_DELAY );

		  /* 记录获取互斥量的时刻。 */
		  xTimeAtWhichMutexWasTaken = xTaskGetTickCount();

		  /* 将生成的文本写入显示设备——这是一个慢操作。 */
		  vCopyTextToFrameBuffer( cTextBuffer );

		  /* 文本已写入显示设备，因此归还互斥量。 */
		  xSemaphoreGive( xMutex );

		  /* 如果每次循环都调用 taskYIELD()，该任务只会在 Running 状态停留很短时间，
			  频繁切换任务将浪费处理时间。因此，仅当持有互斥量期间 tick 计数发生变化时
			  才调用 taskYIELD()。 */
		  if( xTaskGetTickCount() != xTimeAtWhichMutexWasTaken )
		  {
				taskYIELD();
		  }
	 }
}
```
***清单 8.16*** *确保在循环中使用互斥量的任务获得更均衡处理时间，并避免过于频繁切换*


## 8.4 看门人任务

看门人任务提供了实现互斥的干净方法，且不涉及优先级反转或死锁风险。

看门人任务是对资源具有唯一所有权的任务。只有看门人任务可直接访问该资源；
其他任务如需访问资源，必须通过看门人任务间接完成。


### 8.4.1 使用看门人任务重写 vPrintString()

示例 8.2 提供了 `vPrintString()` 的另一种实现。这次使用看门人任务管理标准输出。
当任务需要向标准输出写消息时，不直接调用打印函数，而是将消息发送给看门人。

看门人任务使用 FreeRTOS 队列对标准输出进行串行化访问。由于只有它能直接访问
标准输出，因此其内部实现无需考虑互斥问题。

看门人任务大部分时间处于 *Blocked* 状态，等待队列消息。消息到达时，看门人任务
将其写到标准输出，然后返回 *Blocked* 状态等待下一消息。看门人任务实现见清单 8.18。

中断可向队列发送数据，因此 ISR 也可安全使用看门人任务输出消息。本例使用 tick 钩子
函数每 200 tick 输出一次消息。

Tick 钩子（或 tick 回调）是在每次 tick 中断期间由内核调用的函数。要使用 tick 钩子：

1. 在 FreeRTOSConfig.h 中将 `configUSE_TICK_HOOK` 设为 1。

2. 按清单 8.17 所示的函数名与原型提供钩子函数实现。


<a name="list8.17" title="Listing 8.17 The name and prototype for a tick hook function"></a>

```c
void vApplicationTickHook( void );
```
***清单 8.17*** *tick 钩子函数名称与原型*


tick 钩子函数在 tick 中断上下文中执行，因此必须非常短，使用适量栈空间，且不得
调用名称不以 “FromISR()” 结尾的 FreeRTOS API 函数。

调度器总会在 tick 钩子函数后立即执行，因此从 tick 钩子调用的中断安全 API
无需使用 `pxHigherPriorityTaskWoken` 参数，该参数可设为 NULL。


<a name="list8.18" title="Listing 8.18 The gatekeeper task"></a>

```c
static void prvStdioGatekeeperTask( void *pvParameters )
{
	 char *pcMessageToPrint;

	 /* 这是唯一允许写标准输出的任务。其他任务若要输出字符串，不直接访问标准输出，
		 而是将字符串发送给该任务。由于只有此任务访问标准输出，因此实现中无需考虑
		 互斥或串行化问题。 */
	 for( ;; )
	 {
		  /* 等待消息到达。指定无限期阻塞，因此无需检查返回值——
			  该函数仅在成功接收到消息时返回。 */
		  xQueueReceive( xPrintQueue, &pcMessageToPrint, portMAX_DELAY );

		  /* 输出接收到的字符串。 */
		  printf( "%s", pcMessageToPrint );
		  fflush( stdout );

		  /* 回到循环等待下一条消息。 */
	 }
}
```
***清单 8.18*** *看门人任务*


<a name="example8.2" title="Example 8.2 The alternative implementation for print task"></a>
---
***示例 8.2*** *打印任务的另一种实现*

---

写队列的任务实现见清单 8.19。与之前一样，创建两个任务实例，任务写入队列的字符串
通过任务参数传入。

<a name="list8.19" title="The print task implementation for Example 8.2"></a>


```c
static void prvPrintTask( void *pvParameters )
{
	 int iIndexToString;
	 const TickType_t xMaxBlockTimeTicks = 0x20;

	 /* 创建该任务的两个实例。任务参数用于传入字符串数组索引，
		 并转换为所需类型。 */
	 iIndexToString = ( int ) pvParameters;

	 for( ;; )
	 {
		  /* 打印字符串，但不是直接打印，而是通过队列将字符串指针发送给看门人任务。
			  队列在调度器启动前创建，因此该任务首次执行时已存在。
			  不指定阻塞时间，因为队列应始终有空间。 */
		  xQueueSendToBack( xPrintQueue, &( pcStringsToPrint[ iIndexToString ]), 0 );

		  /* 等待一个伪随机时间。注意 rand() 不一定可重入，但在本例中无关紧要，
			  因为代码并不关心返回值。在更严格的应用中，应使用可重入的 rand()
			  版本，或用临界区保护对 rand() 的调用。 */
		  vTaskDelay( ( rand() % xMaxBlockTimeTicks ) );
	 }
}
```

***清单 8.19*** *示例 8.2 的打印任务实现*


tick 钩子函数统计自身调用次数，当计数达到 200 时向看门人任务发送消息。为演示目的，
tick 钩子向队列头部写入，而任务向队列尾部写入。钩子实现见清单 8.20。


<a name="list8.20" title="Listing 8.20 The tick hook implementation"></a>

```c
void vApplicationTickHook( void )
{
	 static int iCount = 0;

	 /* 每 200 个 tick 输出一条消息。消息不是直接写出，而是发送给看门人任务。 */
	 iCount++;

	 if( iCount >= 200 )
	 {
		  /* 由于 xQueueSendToFrontFromISR() 在 tick 钩子中调用，
			  无需使用 xHigherPriorityTaskWoken 参数（第三个参数），因此设为 NULL。 */
		  xQueueSendToFrontFromISR( xPrintQueue, 
											 &( pcStringsToPrint[ 2 ] ), 
											 NULL );

		  /* 复位计数，以便在 200 个 tick 后再次输出字符串。 */
		  iCount = 0;
	 }
}
```
***清单 8.20*** *tick 钩子实现*


如常，`main()` 创建示例所需队列与任务，然后启动调度器。`main()` 实现见清单 8.21。

```c
/* 定义任务和中断通过看门人输出的字符串。 */
static char *pcStringsToPrint[] =
{
	 "Task 1 ****************************************************\r\n",
	 "Task 2 ----------------------------------------------------\r\n",
	 "Message printed from the tick hook interrupt ##############\r\n"
};

/*-----------------------------------------------------------*/

/* 声明 QueueHandle_t 类型变量。该队列用于将打印任务与 tick 中断的消息
	发送给看门人任务。 */
QueueHandle_t xPrintQueue;

/*-----------------------------------------------------------*/

int main( void )
{
	 /* 使用队列前必须显式创建。该队列最多可容纳 5 个字符指针。 */
	 xPrintQueue = xQueueCreate( 5, sizeof( char * ) );

	 /* 检查队列是否创建成功。 */
	 if( xPrintQueue != NULL )
	 {
		  /* 创建两个向看门人发送消息的任务实例。任务使用的字符串索引通过
			  任务参数（xTaskCreate() 的第 4 个参数）传入。
			  任务以不同优先级创建，因此高优先级任务会偶尔抢占低优先级任务。 */
		  xTaskCreate( prvPrintTask, "Print1", 1000, ( void * ) 0, 1, NULL );
		  xTaskCreate( prvPrintTask, "Print2", 1000, ( void * ) 1, 2, NULL );

		  /* 创建看门人任务。它是唯一允许直接访问标准输出的任务。 */
		  xTaskCreate( prvStdioGatekeeperTask, "Gatekeeper", 1000, NULL, 0, NULL );

		  /* 启动调度器，使已创建的任务开始执行。 */
		  vTaskStartScheduler();
	 }

	 /* 如果一切正常，调度器将运行任务，main() 不会到达这里。
		 若 main() 到达此处，很可能是堆内存不足以创建空闲任务。
		 第 3 章提供了更多堆内存管理信息。 */
	 for( ;; );
}
```
<a name="list8.21" title="Listing 8.21 The implementation of main() for Example 8.2"></a>

***清单 8.21*** *示例 8.2 的 main() 实现*


示例 8.2 的输出如图 8.8 所示。可见任务输出的字符串与中断输出的字符串都正确无误，
没有任何破坏。


<a name="fig8.8" title="Figure 8.8 The output produced when Example 8.2 is executed"></a>

* * *
![](media/image70.jpg)   
***图 8.8*** *示例 8.2 的输出*
* * *

看门人任务的优先级低于打印任务，因此发送到看门人的消息会留在队列中，直到两个
打印任务都进入 *Blocked* 状态。在某些情况下，可将看门人任务设置为更高优先级，
以便消息立即处理——但代价是看门人访问受保护资源期间会延迟低优先级任务。
