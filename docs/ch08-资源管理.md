# 8 资源管理

## 8.1 章节介绍与范围

在多任务系统中，若某任务开始访问资源，但在完成访问前被切出 *Running* 状态，
就可能引发错误。如果任务将资源置于不一致状态，那么任何其他任务或中断访问同一资源时
可能导致数据损坏或类似问题。

以下是一些示例：

* 访问外设

  假设两个任务尝试向 LCD 写数据：

  1. 任务 A 执行并开始写字符串 “Hello world”。

  2. 任务 A 刚输出 “Hello w” 就被任务 B 抢占。

  3. 任务 B 在进入 *Blocked* 状态前向 LCD 写入 “Abort, Retry, Fail?”。

  4. 任务 A 从被抢占处继续执行，输出剩余字符串 “orld”。

  LCD 将显示被破坏的字符串 “Hello wAbort, Retry, Fail?orld”。

* 读-改-写操作

  清单 8.1 展示一行 C 代码及其典型的汇编翻译。可见 PORTA 的值先从内存读入寄存器，
  在寄存器中修改，然后写回内存。这称为读-改-写操作。


	<a name="list8.1" title="Listing 8.1 An example read, modify, write sequence"></a>

	```c
	/* The C code being compiled. */
	PORTA |= 0x01;

	/* The assembly code produced when the C code is compiled. */
	LOAD  R1,[#PORTA] ; Read a value from PORTA into R1
	MOVE  R2,#0x01    ; Move the absolute constant 1 into R2
	OR    R1,R2       ; Bitwise OR R1 (PORTA) with R2 (constant 1)
	STORE R1,[#PORTA] ; Store the new value back to PORTA
	```
	***清单 8.1*** *读-改-写序列示例*
 
	这是一个“非原子”操作，因为完成它需要多条指令且可能被中断。考虑如下场景，
	两个任务尝试更新名为 PORTA 的内存映射寄存器：

	1. 任务 A 读取 PORTA 值到寄存器——读操作。

	2. 任务 A 在完成改写前被任务 B 抢占。

	3. 任务 B 更新 PORTA，然后进入 *Blocked* 状态。

	4. 任务 A 从被抢占处继续执行。它修改寄存器中已有的 PORTA 值副本并写回 PORTA。

	在该场景中，任务 A 将过期的 PORTA 值写回。任务 B 在任务 A 读取 PORTA 之后、
	写回之前修改了 PORTA。任务 A 写回时覆盖了任务 B 的修改，导致 PORTA 值被破坏。

	本例使用外设寄存器，但同样原理也适用于变量的读-改-写操作。

- 对变量的非原子访问

  更新结构体中的多个成员，或更新大于体系结构自然字长的变量（例如在 16 位机上更新
  32 位变量），都是非原子操作。若被中断，可能导致数据丢失或损坏。

- 函数可重入性

  若函数可被多个任务调用，或可被任务与中断同时调用且安全，则称其“可重入”。
  可重入函数被称为“线程安全”，因为可在多个执行线程中访问而不会破坏数据或逻辑。

  每个任务维护自身的栈与处理器（硬件）寄存器值。如果函数只访问栈上或寄存器中的数据，
  则该函数可重入且线程安全。清单 8.2 为可重入函数示例；清单 8.3 为不可重入函数示例。
  
  若应用使用 newlib C 库，必须在 FreeRTOSConfig.h 中将 `configUSE_NEWLIB_REENTRANT`
  设为 1，以确保 newlib 所需的线程本地存储（TLS）正确分配。

  若应用使用 picolibc C 库，必须在 FreeRTOSConfig.h 中将 `configUSE_PICOLIBC_TLS`
  设为 1，以确保 picolibc 所需的线程本地存储（TLS）正确分配。

  若应用使用其他 C 库且需要线程本地存储（TLS），必须在 FreeRTOSConfig.h 中将
  `configUSE_C_RUNTIME_TLS_SUPPORT` 设为 1，并实现以下宏：
  - `configTLS_BLOCK_TYPE` - 每个任务的 TLS 块类型。
  - `configINIT_TLS_BLOCK` - 初始化每任务 TLS 块。
  - `configSET_TLS_BLOCK` - 更新当前 TLS 块。该宏在上下文切换时调用，确保使用正确
	 TLS 块。
  - `configDEINIT_TLS_BLOCK` - 释放 TLS 块。


  <a name="list8.2" title="Listing 8.2 An example of a reentrant function"></a>

  ```c
  /* A parameter is passed into the function. This will either be passed on the 
	  stack, or in a processor register. Either way is safe as each task or 
	  interrupt that calls the function maintains its own stack and its own set 
	  of register values, so each task or interrupt that calls the function will 
	  have its own copy of lVar1. */
  long lAddOneHundred( long lVar1 )
  {
		/* This function scope variable will also be allocated to the stack or a 
			register, depending on the compiler and optimization level. Each task
			or interrupt that calls this function will have its own copy of lVar2. */
		long lVar2;

		lVar2 = lVar1 + 100;
		return lVar2;
  }
  ```
  ***清单 8.2*** *可重入函数示例*


  <a name="list8.3" title="Listing 8.3 An example of a function that is not reentrant"></a>

  ```c
  /* In this case lVar1 is a global variable, so every task that calls
	  lNonsenseFunction will access the same single copy of the variable. */
  long lVar1;

  long lNonsenseFunction( void )
  {
		/* lState is static, so is not allocated on the stack. Each task that
			calls this function will access the same single copy of the variable. */
		static long lState = 0;
		long lReturn;

		switch( lState )
		{
			 case 0 : lReturn = lVar1 + 10;
						 lState = 1;
						 break;

			 case 1 : lReturn = lVar1 + 20;
						 lState = 0;
						 break;
		}
  }
  ```
  ***清单 8.3*** *不可重入函数示例*


### 8.1.1 互斥

为确保数据一致性，共享资源（在任务之间共享，或在任务与中断之间共享）必须通过
“互斥”技术进行管理。目标是：一旦任务开始访问一个不可重入、非线程安全的共享资源，
就能独占该资源直到其恢复到一致状态。

FreeRTOS 提供多种功能实现互斥，但最优方法（在可能时，尽管通常不易做到）是通过
应用设计避免共享资源，让每个资源只由一个任务访问。


### 8.1.2 范围

本章涵盖：

- 何时以及为何需要资源管理与控制。
- 什么是临界区。
- 互斥的含义。
- 挂起调度器意味着什么。
- 如何使用互斥量。
- 如何创建与使用看门人任务。
- 什么是优先级反转，以及优先级继承如何减轻（但无法消除）其影响。


## 8.2 临界区与挂起调度器

### 8.2.1 基本临界区

基本临界区是由宏 `taskENTER_CRITICAL()` 与 `taskEXIT_CRITICAL()` 包围的代码区域。
临界区也称为临界区域。

`taskENTER_CRITICAL()` 与 `taskEXIT_CRITICAL()` 不带参数，也不返回值[^23]。
其用法见清单 8.4。

[^23]: 类函数宏与真实函数不同，严格来说不“返回值”。为便于理解，
本书在将宏视作函数更易理解时，也使用“返回值”一词描述。


<a name="list8.4" title="Listing 8.4 Using a critical section to guard access to a register"></a>

```c
/* Ensure access to the PORTA register cannot be interrupted by placing
	it within a critical section. Enter the critical section. */
taskENTER_CRITICAL();

/* A switch to another task cannot occur between the call to
	taskENTER_CRITICAL() and the call to taskEXIT_CRITICAL(). Interrupts may
	still execute on FreeRTOS ports that allow interrupt nesting, but only
	interrupts whose logical priority is above the value assigned to the
	configMAX_SYSCALL_INTERRUPT_PRIORITY constant – and those interrupts are
	not permitted to call FreeRTOS API functions. */
PORTA |= 0x01;

/* Access to PORTA has finished, so it is safe to exit the critical section. */
taskEXIT_CRITICAL();
```
***清单 8.4*** *使用临界区保护寄存器访问*


本书配套示例项目使用 `vPrintString()` 向标准输出（使用 FreeRTOS Windows 移植时即
终端窗口）输出字符串。`vPrintString()` 被多个任务调用，因此理论上其实现可用
临界区保护标准输出，如清单 8.5。


<a name="list8.5" title="Listing 8.5 A possible implementation of vPrintString()"></a>

```c
void vPrintString( const char *pcString )
{
	 /* Write the string to stdout, using a critical section as a crude method of
		 mutual exclusion. */
	 taskENTER_CRITICAL();
	 {
		  printf( "%s", pcString );
		  fflush( stdout );
	 }
	 taskEXIT_CRITICAL();
}
```
***清单 8.5*** *vPrintString() 的一种可能实现*


以这种方式实现的临界区是一种非常粗糙的互斥方法。它通过禁用中断实现，
或在某些移植上禁用到 `configMAX_SYSCALL_INTERRUPT_PRIORITY` 为止的中断。
抢占式上下文切换只能在中断中发生，因此只要中断保持禁用，调用
`taskENTER_CRITICAL()` 的任务就保证一直处于 *Running* 状态，直到退出临界区。

基本临界区必须非常短，否则会影响中断响应时间。每次 `taskENTER_CRITICAL()` 必须
与 `taskEXIT_CRITICAL()` 紧密配对。因此，不应像清单 8.5 那样用临界区保护
标准输出（stdout，或计算机写出输出数据的流），因为写终端可能是相对耗时的操作。
本章示例将探索替代方案。

临界区可以嵌套使用，因为内核会记录嵌套深度。只有当嵌套深度回到 0 时，临界区才会
真正退出，即每次 `taskENTER_CRITICAL()` 都必须对应一次 `taskEXIT_CRITICAL()`。

在运行 FreeRTOS 的处理器上，任务唯一合法的修改中断使能状态方式就是调用
`taskENTER_CRITICAL()` 与 `taskEXIT_CRITICAL()`。以其他方式改变中断使能状态会
破坏宏的嵌套计数。

`taskENTER_CRITICAL()` 与 `taskEXIT_CRITICAL()` 名称不含 “FromISR”，因此不得在 ISR
中调用。`taskENTER_CRITICAL_FROM_ISR()` 是 `taskENTER_CRITICAL()` 的中断安全版本，
`taskEXIT_CRITICAL_FROM_ISR()` 是 `taskEXIT_CRITICAL()` 的中断安全版本。
中断安全版本仅在允许中断嵌套的移植中提供——在不允许嵌套的移植中没有意义。

`taskENTER_CRITICAL_FROM_ISR()` 会返回一个值，必须传给对应的
`taskEXIT_CRITICAL_FROM_ISR()`。清单 8.6 演示了该用法。


<a name="list8.6" title="Listing 8.6 Using a critical section in an interrupt service routine"></a>

```c
void vAnInterruptServiceRoutine( void )
{
	 /* Declare a variable in which the return value from 
		 taskENTER_CRITICAL_FROM_ISR() will be saved. */
	 UBaseType_t uxSavedInterruptStatus;

	 /* This part of the ISR can be interrupted by any higher priority 
		 interrupt. */

	 /* Use taskENTER_CRITICAL_FROM_ISR() to protect a region of this ISR.
		 Save the value returned from taskENTER_CRITICAL_FROM_ISR() so it can 
		 be passed into the matching call to taskEXIT_CRITICAL_FROM_ISR(). */
	 uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();

	 /* This part of the ISR is between the call to 
		 taskENTER_CRITICAL_FROM_ISR() and taskEXIT_CRITICAL_FROM_ISR(), so can 
		 only be interrupted by interrupts that have a priority above that set 
		 by the configMAX_SYSCALL_INTERRUPT_PRIORITY constant. */

	 /* Exit the critical section again by calling taskEXIT_CRITICAL_FROM_ISR(),
		 passing in the value returned by the matching call to 
		 taskENTER_CRITICAL_FROM_ISR(). */
	 taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus );

	 /* This part of the ISR can be interrupted by any higher priority 
		 interrupt. */
}
```
***清单 8.6*** *在 ISR 中使用临界区*


若进入与退出临界区所耗的处理时间多于被保护代码本身，则非常浪费。
基本临界区进入与退出都非常快，且确定性强，因此适合保护极短代码段。


### 8.2.2 挂起（或锁定）调度器

临界区也可通过挂起调度器来实现。挂起调度器有时也称为“锁定”调度器。

基本临界区会同时防止其他任务与中断访问代码区域，而通过挂起调度器实现的临界区
仅防止其他任务访问，因为中断仍然使能。

若代码区域过长，不适合简单禁用中断，则可通过挂起调度器来实现临界区。然而，
当调度器挂起时，中断活动会使恢复（“解除挂起”）调度器成为相对耗时的操作，
因此需权衡使用哪种方法。


### 8.2.3 vTaskSuspendAll() API 函数


<a name="list8.7" title="Listing 8.7 The vTaskSuspendAll() API function prototype"></a>

```c
void vTaskSuspendAll( void );
```
***清单 8.7*** *vTaskSuspendAll() API 函数原型*


调用 `vTaskSuspendAll()` 挂起调度器。挂起调度器会阻止上下文切换发生，但保持中断
使能。若中断在调度器挂起期间请求上下文切换，该请求会被挂起，直到调度器恢复后才
执行。

调度器挂起期间不得调用 FreeRTOS API 函数。


### 8.2.4 xTaskResumeAll() API 函数


<a name="list8.8" title="Listing 8.8 The xTaskResumeAll() API function prototype"></a>

```c
BaseType_t xTaskResumeAll( void );
```
***清单 8.8*** *xTaskResumeAll() API 函数原型*


调用 `xTaskResumeAll()` 恢复（解除挂起）调度器。

**xTaskResumeAll() 返回值**

- 返回值

  在调度器挂起期间请求的上下文切换会被挂起，并在恢复调度器时执行。
  若在 `xTaskResumeAll()` 返回之前执行了挂起的上下文切换，则返回 `pdTRUE`，
  否则返回 `pdFALSE`。

`vTaskSuspendAll()` 与 `xTaskResumeAll()` 可嵌套使用，内核会记录嵌套深度。
只有当嵌套深度回到 0 时调度器才会恢复——即每次 `vTaskSuspendAll()` 必须对应一次
`xTaskResumeAll()`。

清单 8.9 展示 `vPrintString()` 的真实实现，它通过挂起调度器来保护对终端输出的访问。


<a name="list8.9" title="Listing 8.9 The implementation of vPrintString()"></a>

```c
void vPrintString( const char *pcString )
{
	 /* Write the string to stdout, suspending the scheduler as a method of 
		 mutual exclusion. */
	 vTaskSuspendScheduler();
	 {
		  printf( "%s", pcString );
		  fflush( stdout );
	 }
	 xTaskResumeScheduler();
}
```
***清单 8.9*** *vPrintString() 的实现*


## 8.3 互斥量（及二值信号量）

互斥量（Mutex）是一种特殊的二值信号量，用于控制多个任务共享资源的访问。
MUTEX 一词源自 “MUTual EXclusion”。必须在 FreeRTOSConfig.h 中将 `configUSE_MUTEXES`
设为 1 才可使用互斥量。

在互斥场景中，可将互斥量视为与共享资源关联的令牌。任务要合法访问资源，必须先
成功“获取”令牌（成为持有者）。持有者完成资源使用后必须“归还”令牌。只有令牌归还后，
其他任务才能成功获取并安全访问同一资源。任务不允许在不持有令牌时访问共享资源。
该机制见图 8.1。

尽管互斥量与二值信号量有许多共同特性，但图 8.1（互斥量用于互斥）与图 7.6
（二值信号量用于同步）是完全不同的场景。主要区别在于获取信号量后的处理方式：

- 用于互斥的信号量必须始终归还。
- 用于同步的信号量通常被消耗而不归还。


<a name="fig8.1" title="Figure 8.1 Mutual exclusion implemented using a mutex"></a>

* * *
![](media/image63.png)   
***图 8.1*** *使用互斥量实现互斥*
* * *

该机制完全依赖应用编写者的约束。任务随时可以访问资源，但每个任务都“约定”
只有在成为互斥量持有者后才访问。


### 8.3.1 xSemaphoreCreateMutex() API 函数

FreeRTOS 还提供 `xSemaphoreCreateMutexStatic()`，用于在编译期静态分配创建互斥量
所需内存：互斥量也是一种信号量，各类信号量句柄存放在 `SemaphoreHandle_t` 类型变量中。

互斥量在使用前必须先创建。创建互斥量使用 `xSemaphoreCreateMutex()` API 函数。


<a name="list8.10" title="Listing 8.10 The xSemaphoreCreateMutex() API function prototype"></a>

```c
SemaphoreHandle_t xSemaphoreCreateMutex( void );
```
***清单 8.10*** *xSemaphoreCreateMutex() API 函数原型*


**xSemaphoreCreateMutex() 返回值**

- 返回值

  若返回 NULL，则表示堆内存不足，无法为互斥量分配数据结构。第 3 章提供
  更多堆内存管理信息。

  若返回非 NULL，则表示互斥量创建成功，返回值应保存为该互斥量句柄。


<a name="example8.1" title="Example 8.1 Rewriting vPrintString() to use a semaphore"></a>
---
***示例 8.1*** *使用信号量重写 vPrintString()*

---

该示例创建 `vPrintString()` 的新版本 `prvNewPrintString()`，并由多个任务调用。
`prvNewPrintString()` 在功能上等同 `vPrintString()`，但使用互斥量控制对标准输出
的访问，而不是锁定调度器。其实现见清单 8.11。


<a name="list8.11" title="Listing 8.11 The implementation of prvNewPrintString()"></a>

```c
static void prvNewPrintString( const char *pcString )
{
	 /* The mutex is created before the scheduler is started, so already exists
		 by the time this task executes.

		 Attempt to take the mutex, blocking indefinitely to wait for the mutex
		 if it is not available straight away. The call to xSemaphoreTake() will
		 only return when the mutex has been successfully obtained, so there is 
		 no need to check the function return value. If any other delay period 
		 was used then the code must check that xSemaphoreTake() returns pdTRUE 
		 before accessing the shared resource (which in this case is standard 
		 out). As noted earlier in this book, indefinite time outs are not 
		 recommended for production code. */
	 xSemaphoreTake( xMutex, portMAX_DELAY );
	 {
		  /* The following line will only execute once the mutex has been 
			  successfully obtained. Standard out can be accessed freely now as 
			  only one task can have the mutex at any one time. */
		  printf( "%s", pcString );
		  fflush( stdout );

		  /* The mutex MUST be given back! */
	 }
	 xSemaphoreGive( xMutex );
}
```
***清单 8.11*** *prvNewPrintString() 的实现*


`prvNewPrintString()` 由 `prvPrintTask()` 的两个任务实例反复调用。每次调用之间
使用随机延时。任务参数用于传入每个任务的唯一字符串。`prvPrintTask()` 实现见
清单 8.12。


<a name="list8.12" title="Listing 8.12 The implementation of prvPrintTask() for Example 8.1"></a>

```c
static void prvPrintTask( void *pvParameters )
{
	 char *pcStringToPrint;
	 const TickType_t xMaxBlockTimeTicks = 0x20;

	 /* Two instances of this task are created. The string printed by the task 
		 is passed into the task using the task's parameter. The parameter is 
		 cast to the required type. */
	 pcStringToPrint = ( char * ) pvParameters;

	 for( ;; )
	 {
		  /* Print out the string using the newly defined function. */
		  prvNewPrintString( pcStringToPrint );

		  /* Wait a pseudo random time. Note that rand() is not necessarily
			  reentrant, but in this case it does not really matter as the code 
			  does not care what value is returned. In a more secure application 
			  a version of rand() that is known to be reentrant should be used - 
			  or calls to rand() should be protected using a critical section. */
		  vTaskDelay( ( rand() % xMaxBlockTimeTicks ) );
	 }
}
```
***清单 8.12*** *示例 8.1 的 prvPrintTask() 实现*


如常，`main()` 仅创建互斥量、创建任务，然后启动调度器。实现见清单 8.13。

两个 `prvPrintTask()` 实例以不同优先级创建，因此低优先级任务会偶尔被高优先级任务
抢占。使用互斥量确保每次只有一个任务访问终端，即便发生抢占，显示的字符串也会正确
且不会被破坏。通过降低任务 *Blocked* 状态的最长时间（由 `xMaxBlockTimeTicks` 指定）
可提高抢占频率。

使用 FreeRTOS Windows 移植运行示例 8.1 的注意事项：

- 调用 `printf()` 会产生 Windows 系统调用。Windows 系统调用不受 FreeRTOS 控制，
  可能引入不稳定性。

- 由于 Windows 系统调用执行方式，即便不使用互斥量，也很少出现字符串破坏。


<a name="list8.13" title="Listing 8.13 The implementation of main() for Example 8.1"></a>

```c
int main( void )
{
	 /* Before a semaphore is used it must be explicitly created. In this
		 example a mutex type semaphore is created. */
	 xMutex = xSemaphoreCreateMutex();

	 /* Check the semaphore was created successfully before creating the
		 tasks. */
	 if( xMutex != NULL )
	 {
		  /* Create two instances of the tasks that write to stdout. The string
			  they write is passed in to the task as the task's parameter. The 
			  tasks are created at different priorities so some pre-emption will 
			  occur. */
		  xTaskCreate( prvPrintTask, "Print1", 1000,
							"Task 1 ***************************************\r\n",
							1, NULL );

		  xTaskCreate( prvPrintTask, "Print2", 1000,
							"Task 2 ---------------------------------------\r\n", 
							2, NULL );

		  /* Start the scheduler so the created tasks start executing. */
		  vTaskStartScheduler();
	 }

	 /* If all is well then main() will never reach here as the scheduler will
		 now be running the tasks. If main() does reach here then it is likely 
		 that there was insufficient heap memory available for the idle task to 
		 be created.  Chapter 3 provides more information on heap memory 
		 management. */
	 for( ;; );
}
```
***清单 8.13*** *示例 8.1 的 main() 实现*


示例 8.1 的输出如图 8.2 所示。图 8.3 描述了一种可能的执行序列。

<a name="fig8.2" title="Figure 8.2 The output produced when Example 8.1 is executed"></a>

* * *
![](media/image64.jpg)   
***图 8.2*** *示例 8.1 的输出*
* * *

图 8.2 显示，正如预期，终端显示的字符串未发生破坏。随机顺序来自任务使用的随机延时。


<a name="fig8.3" title="Figure 8.3 A possible sequence of execution for Example 8.1"></a>

* * *
![](media/image65.png)   
***图 8.3*** *示例 8.1 的一种可能执行序列*
* * *


### 8.3.2 优先级反转

图 8.3 展示了使用互斥量实现互斥的潜在陷阱之一。执行序列表明高优先级任务 2 需等待
低优先级任务 1 释放互斥量。高优先级任务被低优先级任务延迟称为“优先级反转”。
若在高优先级任务等待信号量时，出现一个中等优先级任务开始执行，则该不良行为会被
进一步放大——高优先级任务等待低优先级任务，而低优先级任务却甚至无法执行。
这通常称为“无界优先级反转”，因为中等优先级任务可无限期阻塞低、高优先级任务。
该最坏场景如图 8.4。


<a name="fig8.4" title="Figure 8.4 A worst case priority inversion scenario"></a>

* * *
![](media/image66.png)   
***图 8.4*** *最坏情况下的优先级反转场景*
* * *

优先级反转可能是严重问题，但在小型嵌入式系统中往往可在系统设计阶段通过考虑
资源访问方式来避免。


### 8.3.3 优先级继承

FreeRTOS 互斥量与二值信号量非常相似——区别在于互斥量包含基本的“优先级继承”机制，
而二值信号量没有。优先级继承用于减轻优先级反转的负面影响。它不能“修复”优先级反转，
只是将其影响限定在有界时间内。不过，优先级继承会使系统时序分析更复杂，也不应依赖
它来保证系统正确性。

优先级继承通过临时提高互斥量持有者的优先级到等待该互斥量的最高优先级任务，
使持有互斥量的低优先级任务“继承”高优先级任务的优先级。该机制如图 8.5 所示。
当互斥量归还后，持有者优先级会自动恢复到原值。


<a name="fig8.5" title="Figure 8.5 Priority inheritance minimizing the effect of priority inversion"></a>

* * *
![](media/image67.png)   
***图 8.5*** *优先级继承减轻优先级反转影响*
* * *

如前所述，优先级继承会影响使用互斥量的任务优先级。因此互斥量不得在 ISR 中使用。

FreeRTOS 实现了基本优先级继承机制，设计时兼顾空间与执行周期优化。完整的优先级
继承机制需要更多数据与处理器周期来随时确定继承优先级，尤其在任务同时持有多个
互斥量时。

优先级继承机制的具体行为需注意：
* 如果任务在未释放已持有互斥量的情况下再获取互斥量，其继承优先级可进一步提高。
* 只要任务还持有任意互斥量，就会保持其最高继承优先级，与释放互斥量的顺序无关。
* 若任务持有多个互斥量，即使等待这些互斥量的任务完成等待（超时），任务仍会保持
  最高继承优先级。


### 8.3.4 死锁（或致命拥抱）

使用互斥量实现互斥的另一个陷阱是“死锁”（有时称为“致命拥抱”）。

当两个任务都在等待对方持有的资源而无法继续时就发生死锁。考虑以下场景：
任务 A 与任务 B 执行动作时都需要同时获取互斥量 X *与* 互斥量 Y：

1. 任务 A 执行并成功获取互斥量 X。

2. 任务 A 被任务 B 抢占。

3. 任务 B 成功获取互斥量 Y，并尝试获取互斥量 X——但互斥量 X 被任务 A 持有，
	任务 B 选择进入 *Blocked* 状态等待 X 被释放。

4. 任务 A 继续执行，尝试获取互斥量 Y——但 Y 被任务 B 持有，任务 A 选择进入
	*Blocked* 状态等待 Y 被释放。

在该场景结束时，任务 A 等待任务 B 持有的互斥量，任务 B 等待任务 A 持有的互斥量。
发生死锁，因为两个任务都无法继续。

与优先级反转类似，避免死锁的最佳方式是在设计阶段就考虑其可能性，并设计系统
确保死锁不发生。尤其是，如本书前面所述，任务无限期（无超时）等待互斥量通常是
不良实践。应使用稍长于预期最长等待时间的超时——若在该时间内无法获得互斥量，
则可能是设计错误（例如死锁）的症状。

在实践中，死锁在小型嵌入式系统中通常不是大问题，因为系统设计者能够理解完整应用，
并识别、消除可能发生死锁的区域。


### 8.3.5 递归互斥量

任务也可能与自己死锁。这会发生在任务在未归还互斥量前就多次获取同一互斥量。
考虑以下场景：

1. 任务成功获取互斥量。

2. 任务在持有互斥量时调用库函数。

3. 库函数实现尝试获取同一互斥量，并进入 *Blocked* 状态等待该互斥量可用。

在该场景末尾，任务在等待互斥量归还，但自己就是持有者，发生死锁。

可通过使用递归互斥量替代普通互斥量来避免该类死锁。递归互斥量允许同一任务多次
“获取”，且只有在每次“获取”对应的“释放”调用都执行后，互斥量才会真正归还。

普通互斥量与递归互斥量的创建和使用方式类似：

- 普通互斥量使用 `xSemaphoreCreateMutex()` 创建；递归互斥量使用
  `xSemaphoreCreateRecursiveMutex()` 创建。两者原型相同。

- 普通互斥量用 `xSemaphoreTake()` 获取；递归互斥量用 `xSemaphoreTakeRecursive()`
  获取。两者原型相同。

- 普通互斥量用 `xSemaphoreGive()` 释放；递归互斥量用 `xSemaphoreGiveRecursive()`
  释放。两者原型相同。

清单 8.14 展示如何创建并使用递归互斥量。


<a name="list8.14" title="Listing 8.14 Creating and using a recursive mutex"></a>

```c
/* Recursive mutexes are variables of type SemaphoreHandle_t. */
SemaphoreHandle_t xRecursiveMutex;

/* The implementation of a task that creates and uses a recursive mutex. */
void vTaskFunction( void *pvParameters )
{
	 const TickType_t xMaxBlock20ms = pdMS_TO_TICKS( 20 );

	 /* Before a recursive mutex is used it must be explicitly created. */
	 xRecursiveMutex = xSemaphoreCreateRecursiveMutex();

	 /* Check the semaphore was created successfully. configASSERT() is 
		 described in section 11.2. */
	 configASSERT( xRecursiveMutex );

	 /* As per most tasks, this task is implemented as an infinite loop. */
	 for( ;; )
	 {
		  /* ... */

		  /* Take the recursive mutex. */
		  if( xSemaphoreTakeRecursive( xRecursiveMutex, xMaxBlock20ms ) == pdPASS )
		  {
				/* The recursive mutex was successfully obtained. The task can now
					access the resource the mutex is protecting. At this point the 
					recursive call count (which is the number of nested calls to 
					xSemaphoreTakeRecursive()) is 1, as the recursive mutex has 
					only been taken once. */

				/* While it already holds the recursive mutex, the task takes the 
					mutex again. In a real application, this is only likely to occur
					inside a sub-function called by this task, as there is no 
					practical reason to knowingly take the same mutex more than 
					once. The calling task is already the mutex holder, so the 
					second call to xSemaphoreTakeRecursive() does nothing more than
					increment the recursive call count to 2. */
				xSemaphoreTakeRecursive( xRecursiveMutex, xMaxBlock20ms );

				/* ... */

				/* The task returns the mutex after it has finished accessing the
					resource the mutex is protecting. At this point the recursive 
					call count is 2, so the first call to xSemaphoreGiveRecursive()
					does not return the mutex. Instead, it simply decrements the 
					recursive call count back to 1. */
				xSemaphoreGiveRecursive( xRecursiveMutex );

				/* The next call to xSemaphoreGiveRecursive() decrements the 
					recursive call count to 0, so this time the recursive mutex is 
					returned. */
				xSemaphoreGiveRecursive( xRecursiveMutex );

				/* Now one call to xSemaphoreGiveRecursive() has been executed for
					every proceeding call to xSemaphoreTakeRecursive(), so the task
					is no longer the mutex holder. */
		  }
	 }
}
```
***清单 8.14*** *创建并使用递归互斥量*


### 8.3.6 互斥量与任务调度

若不同优先级的两个任务使用同一互斥量，FreeRTOS 调度策略明确执行顺序：
最高优先级且可运行的任务会进入 *Running* 状态。例如高优先级任务因等待
低优先级任务持有的互斥量而阻塞时，一旦低优先级任务归还互斥量，高优先级任务
会立即抢占并成为互斥量持有者。该场景已在图 8.5 中展示。

然而，当任务具有相同优先级时，人们常对执行顺序做出错误假设。若任务 1 和任务 2
优先级相同，任务 1 因等待任务 2 持有的互斥量而阻塞，那么任务 2 “释放”互斥量时，
任务 1 不会抢占任务 2。相反，任务 2 保持 *Running* 状态，任务 1 只从 *Blocked*
转到 *Ready*。该场景如图 8.6 所示，竖线表示 tick 中断发生的时刻。


<a name="fig8.6" title="Figure 8.6 A possible sequence of execution when tasks that have the same priority use the same mutex"></a>

* * *
![](media/image68.png)   
***图 8.6*** *相同优先级任务使用同一互斥量时的一种可能执行序列*
* * *

在图 8.6 所示场景中，FreeRTOS 调度器不会在互斥量可用时立即让任务 1 进入 *Running*
状态，原因是：

- 任务 1 与任务 2 优先级相同，因此除非任务 2 进入 *Blocked* 状态，否则不会切换到
  任务 1，直到下一次 tick 中断（假设 FreeRTOSConfig.h 中 `configUSE_TIME_SLICING`
  设为 1）。

- 若任务在紧循环中使用互斥量，且每次“释放”互斥量都发生上下文切换，那么任务
  仅能短时间处于 *Running* 状态。若两个或更多任务在紧循环中使用同一互斥量，
  则会因频繁切换而浪费处理时间。

若多个任务在紧循环中使用同一互斥量且优先级相同，必须注意保证任务获得大致相等
的处理时间。任务可能无法获得相等处理时间的原因如图 8.7 所示：若以相同优先级
创建清单 8.15 所示任务的两个实例，可能出现图 8.7 的执行序列。


<a name="list8.15" title="Listing 8.15 A task that uses a mutex in a tight loop"></a>

```c
/* The implementation of a task that uses a mutex in a tight loop. The task 
	creates a text string in a local buffer, then writes the string to a display.
	Access to the display is protected by a mutex. */

void vATask( void *pvParameter )
{
	 extern SemaphoreHandle_t xMutex;
	 char cTextBuffer[ 128 ];

	 for( ;; )
	 {
		  /* Generate the text string – this is a fast operation. */
		  vGenerateTextInALocalBuffer( cTextBuffer );

		  /* Obtain the mutex that is protecting access to the display. */
		  xSemaphoreTake( xMutex, portMAX_DELAY );

		  /* Write the generated text to the display–this is a slow operation. */
		  vCopyTextToFrameBuffer( cTextBuffer );

		  /* The text has been written to the display, so return the mutex. */
		  xSemaphoreGive( xMutex );
	 }
}
```
***清单 8.15*** *在紧循环中使用互斥量的任务*


清单 8.15 的注释说明：生成字符串是快速操作，更新显示是慢操作。因此任务在更新
显示期间持有互斥量，占据其大部分运行时间。

在图 8.7 中，竖线表示 tick 中断发生的时刻。


<a name="fig8.7" title="Figure 8.7 A sequence of execution that could occur if two instances of the task shown by Listing 8.15 are created at the same priority"></a>

* * *
![](media/image69.png)   
***图 8.7*** *若以相同优先级创建清单 8.15 中任务的两个实例时可能出现的执行序列*
* * *

图 8.7 的步骤 7 显示任务 1 重新进入 *Blocked* 状态——这是在 `xSemaphoreTake()`
API 函数内部发生的。

图 8.7 表明：任务 1 直到时间片开始时刻恰好落在任务 2 不持有互斥量的短暂时间段，
才可能获取该互斥量。

可在 `xSemaphoreGive()` 后添加 `taskYIELD()` 来避免图 8.7 的场景。清单 8.16
展示了该方法：若任务持有互斥量期间 tick 计数发生变化，则调用 `taskYIELD()`。


<a name="list8.16" title="Listing 8.16 Ensuring tasks that use a mutex in a loop receive a more equal amount of processing time..."></a>

```c
void vFunction( void *pvParameter )
{
	 extern SemaphoreHandle_t xMutex;
	 char cTextBuffer[ 128 ];
	 TickType_t xTimeAtWhichMutexWasTaken;

	 for( ;; )
	 {
		  /* Generate the text string – this is a fast operation. */
		  vGenerateTextInALocalBuffer( cTextBuffer );

		  /* Obtain the mutex that is protecting access to the display. */
		  xSemaphoreTake( xMutex, portMAX_DELAY );

		  /* Record the time at which the mutex was taken. */
		  xTimeAtWhichMutexWasTaken = xTaskGetTickCount();

		  /* Write the generated text to the display–this is a slow operation. */
		  vCopyTextToFrameBuffer( cTextBuffer );

		  /* The text has been written to the display, so return the mutex. */
		  xSemaphoreGive( xMutex );

		  /* If taskYIELD() was called on each iteration then this task would
			  only ever remain in the Running state for a short period of time, 
			  and processing time would be wasted by rapidly switching between 
			  tasks. Therefore, only call taskYIELD() if the tick count changed 
			  while the mutex was held. */
		  if( xTaskGetTickCount() != xTimeAtWhichMutexWasTaken )
		  {
				taskYIELD();
		  }
	 }
}
```
***清单 8.16*** *确保在循环中使用互斥量的任务获得更均衡处理时间，并避免过于频繁切换*


## 8.4 看门人任务

看门人任务提供了实现互斥的干净方法，且不涉及优先级反转或死锁风险。

看门人任务是对资源具有唯一所有权的任务。只有看门人任务可直接访问该资源；
其他任务如需访问资源，必须通过看门人任务间接完成。


### 8.4.1 使用看门人任务重写 vPrintString()

示例 8.2 提供了 `vPrintString()` 的另一种实现。这次使用看门人任务管理标准输出。
当任务需要向标准输出写消息时，不直接调用打印函数，而是将消息发送给看门人。

看门人任务使用 FreeRTOS 队列对标准输出进行串行化访问。由于只有它能直接访问
标准输出，因此其内部实现无需考虑互斥问题。

看门人任务大部分时间处于 *Blocked* 状态，等待队列消息。消息到达时，看门人任务
将其写到标准输出，然后返回 *Blocked* 状态等待下一消息。看门人任务实现见清单 8.18。

中断可向队列发送数据，因此 ISR 也可安全使用看门人任务输出消息。本例使用 tick 钩子
函数每 200 tick 输出一次消息。

Tick 钩子（或 tick 回调）是在每次 tick 中断期间由内核调用的函数。要使用 tick 钩子：

1. 在 FreeRTOSConfig.h 中将 `configUSE_TICK_HOOK` 设为 1。

2. 按清单 8.17 所示的函数名与原型提供钩子函数实现。


<a name="list8.17" title="Listing 8.17 The name and prototype for a tick hook function"></a>

```c
void vApplicationTickHook( void );
```
***清单 8.17*** *tick 钩子函数名称与原型*


tick 钩子函数在 tick 中断上下文中执行，因此必须非常短，使用适量栈空间，且不得
调用名称不以 “FromISR()” 结尾的 FreeRTOS API 函数。

调度器总会在 tick 钩子函数后立即执行，因此从 tick 钩子调用的中断安全 API
无需使用 `pxHigherPriorityTaskWoken` 参数，该参数可设为 NULL。


<a name="list8.18" title="Listing 8.18 The gatekeeper task"></a>

```c
static void prvStdioGatekeeperTask( void *pvParameters )
{
	 char *pcMessageToPrint;

	 /* This is the only task that is allowed to write to standard out. Any
		 other task wanting to write a string to the output does not access 
		 standard out directly, but instead sends the string to this task. As 
		 only this task accesses standard out there are no mutual exclusion or 
		 serialization issues to consider within the implementation of the task 
		 itself. */
	 for( ;; )
	 {
		  /* Wait for a message to arrive. An indefinite block time is specified
			  so there is no need to check the return value – the function will 
			  only return when a message has been successfully received. */
		  xQueueReceive( xPrintQueue, &pcMessageToPrint, portMAX_DELAY );

		  /* Output the received string. */
		  printf( "%s", pcMessageToPrint );
		  fflush( stdout );

		  /* Loop back to wait for the next message. */
	 }
}
```
***清单 8.18*** *看门人任务*


<a name="example8.2" title="Example 8.2 The alternative implementation for print task"></a>
---
***示例 8.2*** *打印任务的另一种实现*

---

写队列的任务实现见清单 8.19。与之前一样，创建两个任务实例，任务写入队列的字符串
通过任务参数传入。

<a name="list8.19" title="The print task implementation for Example 8.2"></a>


```c
static void prvPrintTask( void *pvParameters )
{
	 int iIndexToString;
	 const TickType_t xMaxBlockTimeTicks = 0x20;

	 /* Two instances of this task are created. The task parameter is used to 
		 pass an index into an array of strings into the task. Cast this to the
		 required type. */
	 iIndexToString = ( int ) pvParameters;

	 for( ;; )
	 {
		  /* Print out the string, not directly, but instead by passing a pointer
			  to the string to the gatekeeper task via a queue. The queue is 
			  created before the scheduler is started so will already exist by the
			  time this task executes for the first time. A block time is not 
			  specified because there should always be space in the queue. */
		  xQueueSendToBack( xPrintQueue, &( pcStringsToPrint[ iIndexToString ]), 0 );

		  /* Wait a pseudo random time. Note that rand() is not necessarily
			  reentrant, but in this case it does not really matter as the code 
			  does not care what value is returned. In a more secure application 
			  a version of rand() that is known to be reentrant should be used - 
			  or calls to rand() should be protected using a critical section. */
		  vTaskDelay( ( rand() % xMaxBlockTimeTicks ) );
	 }
}
```

***清单 8.19*** *示例 8.2 的打印任务实现*


tick 钩子函数统计自身调用次数，当计数达到 200 时向看门人任务发送消息。为演示目的，
tick 钩子向队列头部写入，而任务向队列尾部写入。钩子实现见清单 8.20。


<a name="list8.20" title="Listing 8.20 The tick hook implementation"></a>

```c
void vApplicationTickHook( void )
{
	 static int iCount = 0;

	 /* Print out a message every 200 ticks. The message is not written out
		 directly, but sent to the gatekeeper task. */
	 iCount++;

	 if( iCount >= 200 )
	 {
		  /* As xQueueSendToFrontFromISR() is being called from the tick hook, it
			  is not necessary to use the xHigherPriorityTaskWoken parameter (the 
			  third parameter), and the parameter is set to NULL. */
		  xQueueSendToFrontFromISR( xPrintQueue, 
											 &( pcStringsToPrint[ 2 ] ), 
											 NULL );

		  /* Reset the count ready to print out the string again in 200 ticks
			  time. */
		  iCount = 0;
	 }
}
```
***清单 8.20*** *tick 钩子实现*


如常，`main()` 创建示例所需队列与任务，然后启动调度器。`main()` 实现见清单 8.21。

```c
/* Define the strings that the tasks and interrupt will print out via the
	gatekeeper. */
static char *pcStringsToPrint[] =
{
	 "Task 1 ****************************************************\r\n",
	 "Task 2 ----------------------------------------------------\r\n",
	 "Message printed from the tick hook interrupt ##############\r\n"
};

/*-----------------------------------------------------------*/

/* Declare a variable of type QueueHandle_t. The queue is used to send messages
	from the print tasks and the tick interrupt to the gatekeeper task. */
QueueHandle_t xPrintQueue;

/*-----------------------------------------------------------*/

int main( void )
{
	 /* Before a queue is used it must be explicitly created. The queue is 
		 created to hold a maximum of 5 character pointers. */
	 xPrintQueue = xQueueCreate( 5, sizeof( char * ) );

	 /* Check the queue was created successfully. */
	 if( xPrintQueue != NULL )
	 {
		  /* Create two instances of the tasks that send messages to the 
			  gatekeeper. The index to the string the task uses is passed to the 
			  task via the task parameter (the 4th parameter to xTaskCreate()). 
			  The tasks are created at different priorities so the higher priority
			  task will occasionally preempt the lower priority task. */
		  xTaskCreate( prvPrintTask, "Print1", 1000, ( void * ) 0, 1, NULL );
		  xTaskCreate( prvPrintTask, "Print2", 1000, ( void * ) 1, 2, NULL );

		  /* Create the gatekeeper task. This is the only task that is permitted
			  to directly access standard out. */
		  xTaskCreate( prvStdioGatekeeperTask, "Gatekeeper", 1000, NULL, 0, NULL );

		  /* Start the scheduler so the created tasks start executing. */
		  vTaskStartScheduler();
	 }

	 /* If all is well then main() will never reach here as the scheduler will 
		 now be running the tasks. If main() does reach here then it is likely 
		 that there was insufficient heap memory available for the idle task to 
		 be created. Chapter 3 provides more information on heap memory 
		 management. */
	 for( ;; );
}
```
<a name="list8.21" title="Listing 8.21 The implementation of main() for Example 8.2"></a>

***清单 8.21*** *示例 8.2 的 main() 实现*


示例 8.2 的输出如图 8.8 所示。可见任务输出的字符串与中断输出的字符串都正确无误，
没有任何破坏。


<a name="fig8.8" title="Figure 8.8 The output produced when Example 8.2 is executed"></a>

* * *
![](media/image70.jpg)   
***图 8.8*** *示例 8.2 的输出*
* * *

看门人任务的优先级低于打印任务，因此发送到看门人的消息会留在队列中，直到两个
打印任务都进入 *Blocked* 状态。在某些情况下，可将看门人任务设置为更高优先级，
以便消息立即处理——但代价是看门人访问受保护资源期间会延迟低优先级任务。
