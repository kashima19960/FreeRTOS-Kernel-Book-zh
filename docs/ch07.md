# 7 中断管理

## 7.1 简介

### 7.1.1 事件

嵌入式实时系统必须对来自环境的事件采取行动。例如，到达以太网外设的一个数据包（事件）可能需要将其传递到 TCP/IP 协议栈进行处理（动作）。复杂的系统需要处理来自多个源的事件，这些事件具有不同的处理开销和响应时间要求。在每种情况下，都需要判断最佳的事件处理实现策略：

- 如何检测事件？通常使用中断，但也可以轮询输入。

- 使用中断时，在中断服务程序（ISR）中应执行多少处理，在外部应执行多少？通常希望将每个 ISR 保持尽可能短。

- 如何将事件传递到主代码（非 ISR），以及如何构建此代码以最好地适应潜在的异步事件？

FreeRTOS 不对应用设计者施加任何特定的事件处理策略，但提供了允许实现所选策略的功能。

需要区分任务的优先级和中断的优先级：

- 任务是与运行 FreeRTOS 的硬件无关的软件特性。任务的优先级由应用程序编写者在软件中分配，调度器决定哪个任务将进入运行状态。

- 尽管中断服务程序是用软件编写的，但它是一个硬件特性，因为硬件控制哪个中断服务程序将运行以及何时运行。任务只能在没有 ISR 运行时运行，因此最低优先级的中断会中断最高优先级的任务，而任务无法抢占 ISR。

所有 FreeRTOS 运行的体系结构都能够处理来自硬件的中断，但与中断入口和中断优先级分配相关的细节在不同的体系结构之间有所不同。


### 7.1.2 范围

本章涵盖：

- 哪些 FreeRTOS API 函数可以在中断服务程序中使用。
- 将中断处理推迟到任务的方法。
- 如何创建和使用二进制信号量和计数信号量。
- 二进制信号量和计数信号量之间的区别。
- 如何使用队列在中断服务程序中传递数据。
- 某些 FreeRTOS 移植中可用的中断嵌套模型。


## 7.2 在 ISR 中使用 FreeRTOS API

### 7.2.1 中断安全 API

通常需要在中断服务程序（ISR）中使用 FreeRTOS API 函数提供的功能，但许多 FreeRTOS API 函数执行的操作在 ISR 内部是无效的。其中最显著的就是将调用 API 函数的任务置于阻塞状态——如果 API 函数是从 ISR 调用的，那么它就不是从任务中调用的，因此没有调用任务可以被置于阻塞状态。FreeRTOS 通过提供某些 API 函数的两个版本来解决此问题；一个版本用于任务，另一个版本用于 ISR。用于 ISR 的函数在名称后附加了“FromISR”。

> *注意：绝不要从 ISR 中调用名称中没有“FromISR”的 FreeRTOS API 函数。*


### 7.2.2 使用单独的中断安全 API 的好处

为中断提供单独的 API 可以使任务代码更高效，ISR 代码更高效，并且中断入口更简单。要了解原因，请考虑替代解决方案，即为任务和 ISR 提供每个 API 函数的单个版本。如果同一个 API 函数可以从任务和 ISR 调用，那么：

- API 函数需要额外的逻辑来确定它们是从任务还是 ISR 调用的。额外的逻辑会在函数中引入新的路径，使函数变得更长、更复杂，也更难测试。

- 当从任务调用该函数时，某些 API 函数参数将是过时的，而当从 ISR 调用该函数时，其他参数将是过时的。

- 每个 FreeRTOS 移植都需要提供一种机制来确定执行上下文（任务或 ISR）。

- 在执行上下文（任务或 ISR）不易确定的体系结构上，将需要额外的、浪费的、使用起来更复杂的非标准中断入口代码，以允许通过软件提供执行上下文。


### 7.2.3 使用单独的中断安全 API 的缺点

拥有两个版本的某些 API 函数使任务和 ISR 都更高效，但引入了一个新问题；有时需要调用一个不属于 FreeRTOS API 的函数，但该函数又需要从任务和 ISR 中调用。

这通常只在集成第三方代码时才会出现问题，因为这是软件设计超出应用程序编写者控制的唯一情况。如果确实出现此问题，则可以使用以下技术之一来克服此问题：

- 将中断处理推迟到任务[^12]，以便 API 函数仅在任务上下文中调用。

- 如果使用支持中断嵌套的 FreeRTOS 移植，则使用以“FromISR”结尾的 API 函数版本，因为该版本可以从任务和 ISR 中调用。（反之则不然，未以“FromISR”结尾的 API 函数不得从 ISR 中调用。）

- 第三方代码通常包含一个 RTOS 抽象层，可以实现该层以测试函数被调用的上下文（任务或中断），然后调用适合该上下文的 API 函数。


[^12]: 延迟中断处理将在本书的下一部分中介绍。


### 7.2.4 xHigherPriorityTaskWoken 参数

本节介绍 `xHigherPriorityTaskWoken` 参数的概念。如果您还不完全理解本节内容，请不要担心，后面的章节将提供实际示例。

如果中断执行了上下文切换，则在中断退出时运行的任务可能与中断进入时运行的任务不同——中断将打断一个任务，但返回时却返回给另一个任务。

某些 FreeRTOS API 函数可以将任务从阻塞状态移动到就绪状态。之前已经看到过这样的函数，例如 `xQueueSendToBack()`，如果有任务在等待数据变为可用而处于阻塞状态，则该函数将解除该任务的阻塞。

如果 FreeRTOS API 函数解除阻塞的任务的优先级高于运行状态任务的优先级，则根据 FreeRTOS 调度策略，应发生对更高优先级任务的切换。调用 API 函数的上下文决定了实际发生切换的时机：

- 如果 API 函数是从任务中调用的：

  如果 FreeRTOSConfig.h 中将 `configUSE_PREEMPTION` 设置为 1，则在 API 函数内部会自动发生对更高优先级任务的切换，换句话说，就是在 API 函数退出之前。之前在图 6.6 中已经看到过这种情况，即对定时器命令队列的写入导致在写入命令队列的函数退出之前切换到 RTOS 守护任务。

- 如果 API 函数是从中断中调用的：

  在中断内部不会自动发生对更高优先级任务的切换。相反，设置一个变量以通知应用程序编写者应该执行上下文切换。中断安全 API 函数（以“FromISR”结尾的函数）具有一个指针参数 `pxHigherPriorityTaskWoken`，用于此目的。

  如果应该执行上下文切换，则中断安全 API 函数会将 `*pxHigherPriorityTaskWoken` 设置为 `pdTRUE`。为了能够检测到这种情况，第一次使用时，`pxHigherPriorityTaskWoken` 指向的变量必须初始化为 `pdFALSE`。

  如果应用程序编写者选择不请求 ISR 中的上下文切换，则更高优先级任务将保持在就绪状态，直到下次调度程序运行，最坏的情况是在下一个滴答中断期间。

  FreeRTOS API 函数只能将 `*pxHighPriorityTaskWoken` 设置为 `pdTRUE`。如果 ISR 调用多个 FreeRTOS API 函数，则可以在每个 API 函数调用中传递相同的 `pxHigherPriorityTaskWoken` 参数变量，并且该变量只需在第一次使用时初始化为 `pdFALSE`。

中断安全 API 函数内部不自动发生上下文切换有几个原因：

- 避免不必要的上下文切换

  在任务执行任何处理之前，中断可能会执行多次。例如，考虑一个任务通过中断驱动的 UART 接收字符串并处理的场景；每当接收到一个字符时，UART ISR 切换到任务都是浪费的，因为任务只有在接收到完整字符串后才会进行处理。

- 控制执行顺序

  中断可能会不定期发生，并且在不可预测的时间。经验丰富的 FreeRTOS 用户可能希望在其应用程序的特定点临时避免不可预测地切换到其他任务，尽管这也可以通过 FreeRTOS 调度程序锁定机制来实现。

- 可移植性

  这是可以在所有 FreeRTOS 移植中使用的最简单机制。

- 效率

  针对较小处理器体系结构的移植仅允许在 ISR 的最后进行请求上下文切换，取消该限制将需要额外的、更复杂的代码。它还允许在同一 ISR 内多次调用 FreeRTOS API 函数，而不会在同一 ISR 内生成多次请求上下文切换。

- 在 RTOS 滴答中断中执行

  如本书后面将看到的，可以在 RTOS 滴答中断中添加应用程序代码。尝试在滴答中断内部进行上下文切换的结果取决于所使用的 FreeRTOS 移植。充其量，它将导致对调度程序的不必要调用。

`pxHigherPriorityTaskWoken` 参数的使用是可选的。如果不需要，则将 `pxHigherPriorityTaskWoken` 设置为 NULL。


### 7.2.5 portYIELD\_FROM\_ISR() 和 portEND\_SWITCHING\_ISR()宏

本节介绍用于请求 ISR 中的上下文切换的宏。请不要担心，如果您还不完全理解本节内容，后面的章节将提供实际示例。

`taskYIELD()` 是一个可以在任务中调用的宏，用于请求上下文切换。`portYIELD_FROM_ISR()` 和 `portEND_SWITCHING_ISR()` 是 `taskYIELD()` 的中断安全版本。`portYIELD_FROM_ISR()` 和 `portEND_SWITCHING_ISR()` 的用法相同，执行相同的操作[^13]。某些 FreeRTOS 移植仅提供这两个宏中的一个。较新的 FreeRTOS 移植提供了这两个宏。本书中的示例使用 `portYIELD_FROM_ISR()`。

[^13]: 从历史上看，`portEND_SWITCHING_ISR()` 是需要中断处理程序使用汇编代码包装的 FreeRTOS 移植中使用的名称，而 `portYIELD_FROM_ISR()` 是在允许用 C 语言编写整个中断处理程序的 FreeRTOS 移植中使用的名称。


<a name="list7.1" title="Listing 7.1 The portEND\_SWITCHING\_ISR() macros"></a>

```c
portEND_SWITCHING_ISR( xHigherPriorityTaskWoken );
```
***Listing 7.1*** *The portEND_SWITCHING\_ISR() macros*


<a name="list7.2" title="Listing 7.2 The portYIELD\_FROM\_ISR() macros"></a>

```c
portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
```
***Listing 7.2*** *The portYIELD\_FROM\_ISR() macros*


从中断安全 API 函数传出的 `xHigherPriorityTaskWoken` 参数可以直接用作对 `portYIELD_FROM_ISR()` 的调用中的参数。

如果 `portYIELD_FROM_ISR()` 的 `xHigherPriorityTaskWoken` 参数为 `pdFALSE`（零），则不请求上下文切换，宏没有效果。如果 `portYIELD_FROM_ISR()` 的 `xHigherPriorityTaskWoken` 参数不为 `pdFALSE`，则请求上下文切换，运行状态的任务可能会发生变化。中断将始终返回到运行状态的任务，即使在中断执行期间运行状态的任务发生了变化。

大多数 FreeRTOS 移植允许在 ISR 内的任何位置调用 `portYIELD_FROM_ISR()`。少数 FreeRTOS 移植（主要是针对较小体系结构的移植）仅允许在 ISR 的最后调用 `portYIELD_FROM_ISR()`。


## 7.3 延迟中断处理

通常认为，尽可能缩短 ISR 是最佳实践。这样做的原因包括：

- 即使任务被分配了很高的优先级，它们也只能在硬件没有正在服务的中断时运行。

- ISR 会干扰（增加“抖动”）任务的开始时间和执行时间。

- 根据 FreeRTOS 运行的体系结构，可能无法在 ISR 执行时接受任何新中断，或者至少无法接受一部分新中断。

- 应用程序编写者需要考虑并发访问变量、外设和内存缓冲区的后果，并加以防范，以防任务和 ISR 同时访问它们。

- 某些 FreeRTOS 移植允许中断嵌套，但中断嵌套会增加复杂性并降低可预测性。中断越短，嵌套的可能性就越小。

中断服务例程必须记录中断原因并清除中断。中断引起的任何其他处理通常可以在任务中执行，从而使中断服务例程尽快退出。这被称为“延迟中断处理”，因为中断引起的处理被“推迟”到 ISR 之外的任务中。

将中断处理推迟到任务中还允许应用程序编写者相对于应用程序中的其他任务对处理进行优先级排序，并使用所有 FreeRTOS API 函数。

如果将中断处理推迟的任务的优先级高于任何其他任务的优先级，则处理将立即执行，就像处理是在 ISR 本身中执行的一样。图 7.1 显示了这种情况，其中任务 1 是一个普通应用任务，任务 2 是中断处理被推迟到的任务。


<a name="fig7.1" title="Figure 7.1 Completing interrupt processing in a high priority task"></a>

* * *
![](media/image48.png)
***Figure 7.1*** *Completing interrupt processing in a high priority task*
* * *

在图 7.1 中，中断处理在时间 t2 开始，在时间 t4 结束，但仅在时间 t2 和 t3 之间的时间花费在 ISR 中。如果没有使用延迟中断处理，则在时间 t2 和 t4 之间的整个时间段都将花费在 ISR 中。

关于何时最好在 ISR 中执行所有中断处理以及何时最好将部分处理推迟到任务中，没有绝对的规则。当满足以下条件时，将处理推迟到任务中最为有用：

- 中断引起的处理不是微不足道的。例如，如果中断只是存储模拟到数字转换的结果，则几乎可以肯定这最好在 ISR 内部执行，但是如果转换结果还必须通过软件滤波器，则可能最好在任务中执行滤波器。

- 中断处理需要执行无法在 ISR 内部执行的操作，例如写入控制台或分配内存。

- 中断处理是非确定性的——即事先不知道处理将花费多长时间。

以下各节将描述和演示到目前为止本章中介绍的概念，包括可以用来实现延迟中断处理的 FreeRTOS 特性。


## 7.4 用于同步的二进制信号量

二进制信号量 API 的中断安全版本可用于在特定中断发生时解除对任务的阻塞，从而有效地将任务与中断同步。这允许大多数中断事件处理在同步任务中实现，仅在 ISR 中保留非常快速和简短的部分。如前一节所述，二进制信号量用于将中断处理“推迟”到任务中[^14]。

[^14]: 使用直接任务通知从中断中解除对任务的阻塞比使用二进制信号量更高效。直接任务通知将在第 10 章“任务通知”中介绍。

如前面图 7.1 所示，如果中断处理在时间上特别关键，则可以设置推迟处理任务的优先级，以确保该任务始终抢占系统中的其他任务。然后，可以在 ISR 中实现对 `portYIELD_FROM_ISR()` 的调用，确保 ISR 直接返回到中断处理被推迟到的任务。这将确保整个事件处理连续执行（没有中断），就像它全部在 ISR 内部实现一样。图 7.2 重复了图 7.1 中的场景，但文本已更新为描述如何使用信号量控制推迟处理任务的执行。


<a name="fig7.2" title="Figure 7.2 Using a binary semaphore to implement deferred interrupt processing"></a>

* * *
![](media/image49.png)
***Figure 7.2*** *Using a binary semaphore to implement deferred interrupt processing*
* * *

推迟处理任务使用信号量的阻塞式“获取”调用作为进入阻塞状态以等待事件发生的方式。当事件发生时，ISR 使用对同一信号量的“给予”操作来解除任务的阻塞，以便可以继续所需的事件处理。

“获取信号量”和“给予信号量”是根据其使用场景具有不同含义的概念。在此中断同步场景中，二进制信号量可以被概念化为一个长度为 1 的队列。队列一次最多可以包含一个项目，因此始终为空或满（因此为二进制）。通过调用 `xSemaphoreTake()`，中断处理被推迟到的任务有效地尝试从队列中读取，带有阻塞时间，如果队列为空，则导致任务进入阻塞状态。当事件发生时，ISR 使用 `xSemaphoreGiveFromISR()` 函数将令牌（信号量）放入队列中，使队列变为满。这导致任务退出阻塞状态并移除令牌，队列再次变为空。当任务完成处理后，它再次尝试从队列中读取，发现队列为空，重新进入阻塞状态以等待下一个事件。此序列在图 7.3 中演示。

图 7.3 显示中断“给予”信号量，即使它没有先“获取”信号量，任务“获取”信号量，但从不将其返回。这就是为什么该场景被描述为在写入和从队列中读取是概念上相似的。它经常引起混淆，因为它不遵循其他信号量使用场景的相同规则，在这些场景中，获取信号量的任务必须始终将其返回——例如第 8 章“资源管理”中描述的场景。


<a name="fig7.3" title="Figure 7.3 Using a binary semaphore to synchronize a task with an interrupt"></a>

* * *
![](media/image50.png)
***Figure 7.3*** *Using a binary semaphore to synchronize a task with an interrupt*
* * *


### 7.4.1 xSemaphoreCreateBinary() API 函数

FreeRTOS 还包括 `xSemaphoreCreateBinaryStatic()` 函数，该函数在编译时静态分配创建二进制信号量所需的内存：所有 FreeRTOS 信号量的句柄都存储在 `SemaphoreHandle_t` 类型的变量中。

在信号量可以使用之前，必须先创建它。要创建二进制信号量，请使用 `xSemaphoreCreateBinary()` API 函数[^15]。

[^15]: 一些信号量 API 函数实际上是宏，而不是函数。为简单起见，在本书中将它们统称为函数。


<a name="list7.3" title="Listing 7.3 The xSemaphoreCreateBinary() API function prototype"></a>

```c
SemaphoreHandle_t xSemaphoreCreateBinary( void );
```
***Listing 7.3*** *The xSemaphoreCreateBinary() API function prototype*

**xSemaphoreCreateBinary() 返回值**

- 返回值

  如果返回 NULL，则表示由于 FreeRTOS 无法分配信号量数据结构所需的堆内存不足，因此无法创建信号量。

  如果返回非 NULL 值，则表示信号量已成功创建。返回的值应存储为创建的信号量的句柄。


### 7.4.2 xSemaphoreTake() API 函数

“获取”信号量意味着“获得”或“接收”信号量。只有在信号量可用时，才能获取信号量。

除递归互斥锁外，所有类型的 FreeRTOS 信号量都可以使用 `xSemaphoreTake()` 函数“获取”。

`xSemaphoreTake()` 不能在中断服务程序中使用。


<a name="list7.4" title="Listing 7.4 The xSemaphoreTake() API function prototype"></a>

```c
BaseType_t xSemaphoreTake( SemaphoreHandle_t xSemaphore, TickType_t xTicksToWait );
```
***Listing 7.4*** *The xSemaphoreTake() API function prototype*

**xSemaphoreTake() 参数和返回值**

- `xSemaphore`

  正在“获取”的信号量。

  信号量通过 `SemaphoreHandle_t` 类型的变量引用。必须显式创建它才能使用。

- `xTicksToWait`

  任务在信号量不可用时应在阻塞状态中等待信号量的最长时间。

  如果 `xTicksToWait` 为零，则如果信号量不可用，`xSemaphoreTake()` 将立即返回。

  块时间以滴答周期为单位指定，因此它所代表的绝对时间取决于滴答频率。宏 `pdMS_TO_TICKS()` 可用于将以毫秒为单位指定的时间转换为以滴答为单位的时间。

  将 `xTicksToWait` 设置为 `portMAX_DELAY` 将导致任务在没有超时的情况下无限期等待信号量（前提是 FreeRTOSConfig.h 中将 `INCLUDE_vTaskSuspend` 设置为 1）。

- 返回值

  可能有两种返回值：

  - `pdPASS`

    仅当调用 `xSemaphoreTake()` 成功获取信号量时，才会返回 `pdPASS`。

    如果指定了块时间（`xTicksToWait` 不为零），则可能是调用任务被置于阻塞状态以等待信号量，但信号量在块时间到期之前变为可用。

  - `pdFALSE`

    信号量不可用。

    如果指定了块时间（`xTicksToWait` 不为零），则调用任务将被置于阻塞状态以等待信号量变为可用，但块时间在此之前已到期。


### 7.4.3 xSemaphoreGiveFromISR() API 函数

二进制信号量和计数信号量[^16]可以使用 `xSemaphoreGiveFromISR()` 函数“给予”。

[^16]: 计数信号量将在本书后面的章节中介绍。

`xSemaphoreGiveFromISR()` 是 `xSemaphoreGive()` 的中断安全版本，因此具有本章开头描述的 `pxHigherPriorityTaskWoken` 参数。


<a name="list" title="Listing 7.5 The xSemaphoreGiveFromISR() API function prototype"></a>

```c
BaseType_t xSemaphoreGiveFromISR( SemaphoreHandle_t xSemaphore,
                                  BaseType_t *pxHigherPriorityTaskWoken );
```
***Listing 7.5*** *The xSemaphoreGiveFromISR() API function prototype*

**xSemaphoreGiveFromISR() 参数和返回值**

- `xSemaphore`

  正在“给予”的信号量。

  信号量通过 `SemaphoreHandle_t` 类型的变量引用，必须显式创建才能使用。

- `pxHigherPriorityTaskWoken`

  可能有一个或多个任务在信号量上被阻塞，等待信号量变为可用。调用 `xSemaphoreGiveFromISR()` 可以使信号量变为可用，从而导致等待信号量的任务离开阻塞状态。如果调用 `xSemaphoreGiveFromISR()` 导致任务离开阻塞状态，并且解除阻塞的任务的优先级高于当前执行任务（被中断的任务）的优先级，则在内部，`xSemaphoreGiveFromISR()` 将 `*pxHigherPriorityTaskWoken` 设置为 `pdTRUE`。

  如果 `xSemaphoreGiveFromISR()` 将此值设置为 `pdTRUE`，则通常应在中断退出之前执行上下文切换。这将确保中断直接返回到最高优先级的就绪状态任务。

- 返回值

  可能有两种返回值：

  - `pdPASS`

    仅当调用 `xSemaphoreGiveFromISR()` 成功时，才会返回 `pdPASS`。

  - `pdFAIL`

    如果信号量已经可用，则无法再次给予信号量，`xSemaphoreGiveFromISR()` 将返回 `pdFAIL`。


<a name="example7.1" title="Example 7.1 Using a binary semaphore to synchronize a task with an interrupt"></a>
---
***Example 7.1*** *Using a binary semaphore to synchronize a task with an interrupt*

---

此示例使用二进制信号量从中断服务例程解除对任务的阻塞，有效地将任务与中断同步。

一个简单的周期性任务用于每 500 毫秒生成一次软件中断。出于方便，使用软件中断，因为在某些目标环境中挂钩到真实中断的复杂性。图 7.6 显示了周期性任务的实现。请注意，任务在生成中断之前和之后都会打印出一条字符串。这允许在执行示例时从输出中观察到执行顺序。


<a name="list7.6" title="Listing 7.6 Implementation of the task that periodically generates a software interrupt in Example 7.1"></a>

```c
/* The number of the software interrupt used in this example. The code
   shown is from the Windows project, where numbers 0 to 2 are used by the
   FreeRTOS Windows port itself, so 3 is the first number available to the
   application. */
#define mainINTERRUPT_NUMBER 3

static void vPeriodicTask( void *pvParameters )
{
    const TickType_t xDelay500ms = pdMS_TO_TICKS( 500UL );

    /* As per most tasks, this task is implemented within an infinite loop. */
    for( ;; )
    {
        /* Block until it is time to generate the software interrupt again. */
        vTaskDelay( xDelay500ms );

        /* Generate the interrupt, printing a message both before and after
           the interrupt has been generated, so the sequence of execution is
           evident from the output.

           The syntax used to generate a software interrupt is dependent on
           the FreeRTOS port being used. The syntax used below can only be
           used with the FreeRTOS Windows port, in which such interrupts are
           only simulated. */
        vPrintString( "Periodic task - About to generate an interrupt.\r\n" );
        vPortGenerateSimulatedInterrupt( mainINTERRUPT_NUMBER );
        vPrintString( "Periodic task - Interrupt generated.\r\n\r\n\r\n" );
    }
}
```
***Listing 7.6*** *Implementation of the task that periodically generates a software interrupt in Example 7.1*


图 7.7 显示了中断处理被推迟到的任务的实现——通过使用二进制信号量与软件中断同步的任务。再次，在任务的每次迭代中打印出一条字符串，因此在执行示例时从输出中可以明显看出任务和中断的执行顺序。

应该注意的是，尽管图 7.7 中显示的代码对于示例 7.1 是足够的，但对于由硬件外设生成中断的场景来说，它是不够的。后面的子章节将描述如何更改代码结构，以使其适用于硬件生成的中断。


<a name="list7.7." title="Listing 7.7 The implementation of the task to which the interrupt processing is deferred (the task that..."></a>

```c
static void vHandlerTask( void *pvParameters )
{
    /* As per most tasks, this task is implemented within an infinite loop. */
    for( ;; )
    {
        /* Use the semaphore to wait for the event. The semaphore was created
           before the scheduler was started, so before this task ran for the
           first time. The task blocks indefinitely, meaning this function
           call will only return once the semaphore has been successfully
           obtained - so there is no need to check the value returned by
           xSemaphoreTake(). */
        xSemaphoreTake( xBinarySemaphore, portMAX_DELAY );

        /* To get here the event must have occurred. Process the event (in
           this Case, just print out a message). */
        vPrintString( "Handler task - Processing event.\r\n" );
    }
}
```
***Listing 7.7*** *The implementation of the task to which the interrupt processing is deferred (the task that synchronizes with the interrupt) in Example 7.1*


图 7.8 显示了 ISR。它所做的很少，仅仅是“给予”信号量以解除对中断处理被推迟到的任务的阻塞。

请注意 `xHigherPriorityTaskWoken` 变量的用法。在调用 `xSemaphoreGiveFromISR()` 之前将其设置为 `pdFALSE`，然后在调用 `portYIELD_FROM_ISR()` 时用作参数。如果在 `xSemaphoreGiveFromISR()` 中 `xHigherPriorityTaskWoken` 等于 `pdTRUE`，则将请求上下文切换。如果在 ISR 执行期间 `xHigherPriorityTaskWoken` 仍为 `pdFALSE`，则调用 `portYIELD_FROM_ISR()` 将没有效果。与大多数 FreeRTOS 移植不同，Windows 移植要求 ISR 返回一个值，`portYIELD_FROM_ISR()` 宏的实现包含返回语句，因此图 7.8 中没有显示显式返回值。


<a name="list7.8" title="Listing 7.8 The ISR for the software interrupt used in Example 7.1"></a>

```c
static uint32_t ulExampleInterruptHandler( void )
{
    BaseType_t xHigherPriorityTaskWoken;

    /* The xHigherPriorityTaskWoken parameter must be initialized to
       pdFALSE as it will get set to pdTRUE inside the interrupt safe
       API function if a context switch is required. */
    xHigherPriorityTaskWoken = pdFALSE;

    /* 'Give' the semaphore to unblock the task, passing in the address of
       xHigherPriorityTaskWoken as the interrupt safe API function's
       pxHigherPriorityTaskWoken parameter. */
    xSemaphoreGiveFromISR( xBinarySemaphore, &xHigherPriorityTaskWoken );

    /* Pass the xHigherPriorityTaskWoken value into portYIELD_FROM_ISR().
       If xHigherPriorityTaskWoken was set to pdTRUE inside
       xSemaphoreGiveFromISR() then calling portYIELD_FROM_ISR() will request
       a context switch. If xHigherPriorityTaskWoken is still pdFALSE then
       calling portYIELD_FROM_ISR() will have no effect. Unlike most FreeRTOS
       ports, the Windows port requires the ISR to return a value - the return
       statement is inside the Windows version of portYIELD_FROM_ISR(). */
    portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
}
```
***Listing 7.8*** *The ISR for the software interrupt used in Example 7.1*

`main()` 函数创建二进制信号量，创建任务，安装中断处理程序，并启动调度程序。其实现如图 7.9 所示。

安装中断处理程序的函数的语法特定于 FreeRTOS Windows 移植，可能与其他 FreeRTOS 移植不同。有关所使用移植所需语法的更多信息，请参阅 FreeRTOS.org 网站上的特定于移植的文档页面，以及 FreeRTOS 下载中提供的示例。


<a name="list7.9" title="Listing 7.9 The implementation of main() for Example 7.1"></a>

```c
int main( void )
{
    /* Before a semaphore is used it must be explicitly created. In this
       example a binary semaphore is created. */
    xBinarySemaphore = xSemaphoreCreateBinary();

    /* Check the semaphore was created successfully. */
    if( xBinarySemaphore != NULL )
    {
        /* Create the 'handler' task, which is the task to which interrupt
           processing is deferred. This is the task that will be synchronized
           with the interrupt. The handler task is created with a high priority
           to ensure it runs immediately after the interrupt exits. In this
           case a priority of 3 is chosen. */
        xTaskCreate( vHandlerTask, "Handler", 1000, NULL, 3, NULL );

        /* Create the task that will periodically generate a software
           interrupt. This is created with a priority below the handler task
           to ensure it will get preempted each time the handler task exits
           the Blocked state. */
        xTaskCreate( vPeriodicTask, "Periodic", 1000, NULL, 1, NULL );

        /* Install the handler for the software interrupt. The syntax necessary
           to do this is dependent on the FreeRTOS port being used. The syntax
           shown here can only be used with the FreeRTOS windows port, where
           such interrupts are only simulated. */
        vPortSetInterruptHandler( mainINTERRUPT_NUMBER,
                                  ulExampleInterruptHandler );

        /* Start the scheduler so the created tasks start executing. */
        vTaskStartScheduler();
    }

    /* As normal, the following line should never be reached. */
    for( ;; );
}
```
***Listing 7.9*** *The implementation of main() for Example 7.1*


当执行示例 7.1 时，产生的输出如图 7.4 所示。如预期的那样，`vHandlerTask()` 在中断生成后立即进入运行状态，因此该任务的输出插入了周期性任务的输出中。图 7.5 提供了进一步的解释。


<a name="fig7.4" title="Figure 7.4 The output produced when Example 7.1 is executed"></a>
<a name="fig7.5" title="Figure 7.5 The sequence of execution when Example 7.1 is executed"></a>

* * *
![](media/image51.jpg)
***Figure 7.4*** *The output produced when Example 7.1 is executed*

![](media/image52.png)
***Figure 7.5*** *The sequence of execution when Example 7.1 is executed*
* * *


### 7.4.4 改进示例 7.1 中使用的任务的实现

示例 7.1 使用二进制信号量将任务与中断同步。执行顺序如下：

1. 中断发生。

1. ISR 执行并“给予”信号量以解除任务的阻塞。

1. 任务在 ISR 之后立即执行，并“获取”信号量。

1. 任务处理事件，然后尝试再次“获取”信号量——由于信号量尚不可用而进入阻塞状态（另一个中断尚未发生）。

示例 7.1 中使用的推迟中断处理任务的结构仅在中断发生频率相对较低时是足够的。要理解原因，请考虑如果在任务完成对第一个事件的处理之前发生了第二个，然后是第三个中断，会发生什么：

- 当第二个 ISR 执行时，信号量将为空，因此 ISR 将给予信号量，并且任务将在完成对第一个事件的处理后立即处理第二个事件。该场景如图 7.6 所示。

- 当第三个 ISR 执行时，信号量已经可用，ISR 将无法再次给予信号量，因此任务将无法得知第三个事件的发生。该场景如图 7.7 所示。


<a name="fig7.6" title="Figure 7.6 The scenario when one interrupt occurs before the task has finished processing the first event"></a>
<a name="fig7.7" title="Figure 7.7 The scenario when two interrupts occur before the task has finished processing the first event"></a>

* * *
![](media/image53.png)
***Figure 7.6*** *The scenario when one interrupt occurs before the task has finished processing the first event*

![](media/image54.png)
***Figure 7.7*** *The scenario when two interrupts occur before the task has finished processing the first event*
* * *

示例 7.1 中的推迟中断处理任务的结构是这样的，它在每次调用 `xSemaphoreTake()` 之间仅处理一个事件。这对于示例 7.1 是足够的，因为生成中断的操作是由软件触发的，并且发生在可预测的时间。在实际应用中，中断是由硬件生成的，并且在不可预测的时间发生。因此，为了最小化丢失中断的可能性，推迟中断处理任务的结构必须是这样的，在每次调用 `xSemaphoreTake()` 之间处理所有已经存在的事件[^17]。图 7.10 显示了如何构建 UART 的推迟中断处理程序。

[^17]: 或者，可以使用计数信号量或直接任务通知来计算事件。计数信号量将在下一节中介绍。直接任务通知将在第 10 章“任务通知”中介绍。由于直接任务通知在运行时和 RAM 使用方面最有效，因此它们是首选方法。

示例 7.1 中的推迟中断处理还有一个弱点；它在调用 `xSemaphoreTake()` 时没有使用超时。相反，任务将 `portMAX_DELAY` 作为 `xSemaphoreTake()` 的 `xTicksToWait` 参数，这导致任务在没有超时的情况下无限期等待信号量。由于示例代码简化了示例结构，因此通常在示例代码中使用无限超时，因为这使示例更易于理解。然而，在实际应用中，无限超时通常是不好的做法，因为它们使得在错误发生时难以恢复。例如，考虑一个任务在等待中断给予信号量，但硬件错误状态阻止中断被生成：

- 如果任务在没有超时的情况下等待，它将无法得知错误状态，并将永远等待。

- 如果任务在超时的情况下等待，则当超时到期时，`xSemaphoreTake()` 将返回 `pdFAIL`，然后任务可以在下次执行时检测并清除错误。此场景也在图 7.10 中演示。


<a name="list7.10" title="Listing 7.10 The recommended structure of a deferred interrupt processing task, using a UART receive..."></a>

```c
static void vUARTReceiveHandlerTask( void *pvParameters )
{
    /* xMaxExpectedBlockTime holds the maximum time expected between two
       interrupts. */
    const TickType_t xMaxExpectedBlockTime = pdMS_TO_TICKS( 500 );

    /* As per most tasks, this task is implemented within an infinite loop. */
    for( ;; )
    {
        /* The semaphore is 'given' by the UART's receive (Rx) interrupt.
           Wait a maximum of xMaxExpectedBlockTime ticks for the next
           interrupt. */
        if( xSemaphoreTake( xBinarySemaphore, xMaxExpectedBlockTime ) == pdPASS)
        {
            /* The semaphore was obtained. Process ALL pending Rx events before
               calling xSemaphoreTake() again. Each Rx event will have placed a
               character in the UART's receive FIFO, and UART_RxCount() is
               assumed to return the number of characters in the FIFO. */
            while( UART_RxCount() > 0 )
            {
                /* UART_ProcessNextRxEvent() is assumed to process one Rx
                   character, reducing the number of characters in the FIFO
                   by 1. */
                UART_ProcessNextRxEvent();
            }

            /* No more Rx events are pending (there are no more characters in
               the FIFO), so loop back and call xSemaphoreTake() to wait for
               the next interrupt. Any interrupts occurring between this point
               in the code and the call to xSemaphoreTake() will be latched in
               the semaphore, so will not be lost. */
        }
        else
        {
            /* An event was not received within the expected time. Check for,
               and if necessary clear, any error conditions in the UART that
               might be preventing the UART from generating any more
               interrupts. */
            UART_ClearErrors();
        }
    }
}
```
***Listing 7.10*** *The recommended structure of a deferred interrupt processing task, using a UART receive handler as an example*


## 7.5 计数信号量

正如二进制信号量可以被视为长度为一的队列，计数信号量可以被视为长度大于一的队列。任务对存储在队列中的数据不感兴趣——只对队列中的项目数量感兴趣。
`configUSE_COUNTING_SEMAPHORES` 必须在 FreeRTOSConfig.h 中设置为 1，才能使用计数信号量。

每当“给予”计数信号量时，它的队列中的另一个空间就会被使用。队列中的项目数量就是信号量的“计数”值。

计数信号量通常用于两件事：

1. 计数事件[^18]

   在此场景中，事件处理程序每次发生事件时都会“给予”信号量，从而导致信号量的计数值在每次“给予”时递增。任务每次处理事件时都会获取信号量，从而导致信号量的计数值在每次“获取”时递减。计数值是已发生事件数量与已处理事件数量之间的差异。此机制如图 7.8 所示。

   用于计数事件的计数信号量在创建时初始计数值为零。

   [^18]: 使用直接任务通知计数事件比使用计数信号量更高效。直接任务通知将在第 10 章中介绍。

2. 资源管理。

   在此场景中，计数值指示可用资源的数量。要获取对资源的控制，任务必须先获取信号量，这会递减信号量的计数值。当计数值达到零时，表示没有空闲资源。当任务完成对资源的使用后，它会将信号量“给予”回去，从而递增信号量的计数值。

   用于管理资源的计数信号量的初始计数值应等于可用资源的数量。第 7 章介绍了使用信号量管理资源。


<a name="fig7.8" title="Figure 7.8 Using a counting semaphore to 'count' events"></a>

* * *
![](media/image55.png)
***Figure 7.8*** *Using a counting semaphore to 'count' events*
* * *

### 7.5.1 xSemaphoreCreateCounting() API 函数

FreeRTOS 还包括 `xSemaphoreCreateCountingStatic()` 函数，该函数在编译时静态分配创建计数信号量所需的内存：所有 FreeRTOS 信号量的句柄都存储在 `SemaphoreHandle_t` 类型的变量中。

在信号量可以使用之前，必须先创建它。要创建计数信号量，请使用 `xSemaphoreCreateCounting()` API 函数。


<a name="list7.11" title="Listing 7.11 The xSemaphoreCreateCounting() API function prototype"></a>

```c
SemaphoreHandle_t xSemaphoreCreateCounting( UBaseType_t uxMaxCount,
                                            UBaseType_t uxInitialCount );
```
***Listing 7.11*** *The xSemaphoreCreateCounting() API function prototype*


**xSemaphoreCreateCounting() 参数和返回值**

- `uxMaxCount`

   信号量将计数的最大值。为了继续队列类比，`uxMaxCount` 值实际上是队列的长度。

   当信号量用于计数或锁存事件时，`uxMaxCount` 是可以锁存的最大事件数。

   当信号量用于管理对资源集合的访问时，`uxMaxCount` 应设置为可用资源的总数。

- `uxInitialCount`

  信号量创建后初始的计数值。

  当信号量用于计数或锁存事件时，`uxInitialCount` 应设置为零（因为在创建信号量时我们假设尚未发生任何事件）。

  当信号量用于管理对资源集合的访问时，`uxInitialCount` 应设置为等于 `uxMaxCount`（因为在创建信号量时我们假设所有资源都是可用的）。

- 返回值

  如果返回 NULL，则信号量无法创建，因为 FreeRTOS 无法分配信号量数据结构所需的堆内存不足。第 3 章提供了有关堆内存管理的更多信息。

  如果返回非 NULL 值，则表示信号量已成功创建。返回的值应存储为创建的信号量的句柄。


<a name="example7.2" title="Example 7.2 Using a counting semaphore to synchronize a task with an interrupt"></a>
---
***Example 7.2*** *Using a counting semaphore to synchronize a task with an interrupt*

---

示例 7.2 通过使用计数信号量取代二进制信号量，改进了示例 7.1 的实现。`main()` 函数被更改为在调用 `xSemaphoreCreateCounting()` 时取代对 `xSemaphoreCreateBinary()` 的调用。新的 API 调用如图 7.12 所示。


<a name="list7.12" title="Listing 7.12 The call to xSemaphoreCreateCounting() used to create the counting semaphore in Example 7.2"></a>

```c
/* Before a semaphore is used it must be explicitly created. In this example a
   counting semaphore is created. The semaphore is created to have a maximum
   count value of 10, and an initial count value of 0. */
xCountingSemaphore = xSemaphoreCreateCounting( 10, 0 );
```
***Listing 7.12*** *The call to xSemaphoreCreateCounting() used to create the counting semaphore in Example 7.2*


为了模拟以高频率发生多个事件，中断服务例程被更改为每次中断“给予”信号量多次。每个事件都被锁存到信号量的计数值中。修改后的中断服务例程如图 7.13 所示。


<a name="list7.13" title="Listing 7.13 The implementation of the interrupt service routine used by Example 7.2"></a>

```c
static uint32_t ulExampleInterruptHandler( void )
{
    BaseType_t xHigherPriorityTaskWoken;

    /* The xHigherPriorityTaskWoken parameter must be initialized to pdFALSE
       as it will get set to pdTRUE inside the interrupt safe API function if
       a context switch is required. */
    xHigherPriorityTaskWoken = pdFALSE;

    /* 'Give' the semaphore multiple times. The first will unblock the deferred
       interrupt handling task, the following 'gives' are to demonstrate that
       the semaphore latches the events to allow the task to which interrupts
       are deferred to process them in turn, without events getting lost. This
       simulates multiple interrupts being received by the processor, even
       though in this case the events are simulated within a single interrupt
       occurrence. */
    xSemaphoreGiveFromISR( xCountingSemaphore, &xHigherPriorityTaskWoken );
    xSemaphoreGiveFromISR( xCountingSemaphore, &xHigherPriorityTaskWoken );
    xSemaphoreGiveFromISR( xCountingSemaphore, &xHigherPriorityTaskWoken );

    /* Pass the xHigherPriorityTaskWoken value into portYIELD_FROM_ISR().
       If xHigherPriorityTaskWoken was set to pdTRUE inside
       xSemaphoreGiveFromISR() then calling portYIELD_FROM_ISR() will request
       a context switch. If xHigherPriorityTaskWoken is still pdFALSE then
       calling portYIELD_FROM_ISR() will have no effect. Unlike most FreeRTOS
       ports, the Windows port requires the ISR to return a value - the return
       statement is inside the Windows version of portYIELD_FROM_ISR(). */
    portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
}
```
***Listing 7.13*** *The implementation of the interrupt service routine used by Example 7.2*

示例 7.2 中的所有其他函数保持不变。

执行示例 7.2 时产生的输出如图 7.9 所示。如所见，解除对中断处理的推迟的任务每次中断生成时处理所有三个（模拟）事件。事件被锁存到信号量的计数值中，允许任务依次处理它们。


<a name="fig7.9" title="Figure 7.9 The output produced when Example 7.2 is executed"></a>

* * *
![](media/image56.jpg)
***Figure 7.9*** *The output produced when Example 7.2 is executed*
* * *


## 7.6 将工作推迟到 RTOS 守护任务

到目前为止，所呈现的延迟中断处理示例要求应用程序编写者为每个使用延迟处理技术的中断创建一个任务。还可以使用 `xTimerPendFunctionCallFromISR()`[^19] API 函数将中断处理推迟到 RTOS 守护任务，从而无需为每个中断创建单独的任务。将中断处理推迟到守护任务称为“集中式延迟中断处理”。

[^19]: 守护任务最初被称为定时器服务任务，因为它最初仅用于执行软件定时器回调函数。因此，`xTimerPendFunctionCall()` 在 timers.c 中实现，并且根据函数名称前缀约定，函数名称前缀为“Timer”。

第 6 章描述了与软件定时器相关的 FreeRTOS API 函数如何通过定时器命令队列发送命令到守护任务。`xTimerPendFunctionCall()` 和 `xTimerPendFunctionCallFromISR()` API 函数使用相同的定时器命令队列向守护任务发送“执行函数”命令。因此，实际执行该函数的时间取决于守护任务相对于应用程序中其他任务的优先级。


集中式延迟中断处理的优点包括：

- 更低的资源使用

  它消除了为每个延迟中断创建单独任务的需要。

- 简化的用户模型

  延迟中断处理函数是标准 C 函数。

集中式延迟中断处理的缺点包括：

- 灵活性较差

  无法单独设置每个延迟中断处理任务的优先级。每个延迟中断处理函数以守护任务的优先级执行。如第 6 章所述，守护任务的优先级由 FreeRTOSConfig.h 中的 `configTIMER_TASK_PRIORITY` 编译时配置常量设置。

- 确定性较差

  `xTimerPendFunctionCallFromISR()` 将命令发送到定时器命令队列的末尾。已经在定时器命令队列中的命令将在守护任务处理 `xTimerPendFunctionCallFromISR()` 发送的“执行函数”命令之前被处理。

不同中断具有不同的时间约束，因此在同一应用程序中通常同时使用两种中断处理推迟方法。


### 7.6.1 xTimerPendFunctionCallFromISR() API 函数

`xTimerPendFunctionCallFromISR()` 是 `xTimerPendFunctionCall()` 的中断安全版本。两个 API 函数都允许应用程序编写者提供的函数由 RTOS 守护任务执行，因此在守护任务的上下文中执行。发送到守护任务的函数及其输入参数的值通过定时器命令队列传递。因此，实际执行该函数的时间取决于守护任务相对于应用程序中其他任务的优先级。


<a name="list7.14" title="Listing 7.14 The xTimerPendFunctionCallFromISR() API function prototype"></a>

```c
BaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t
                                          xFunctionToPend,
                                          void *pvParameter1,
                                          uint32_t ulParameter2,
                                          BaseType_t *pxHigherPriorityTaskWoken );
```
***Listing 7.14*** *The xTimerPendFunctionCallFromISR() API function prototype*


<a name="list7.15" title="Listing 7.15 The prototype to which a function passed in the xFunctionToPend parameter of xTimerPendFunctionCallFromISR()..."></a>

```c
void vPendableFunction( void *pvParameter1, uint32_t ulParameter2 );
```
***Listing 7.15*** *The prototype to which a function passed in the xFunctionToPend parameter of xTimerPendFunctionCallFromISR() must conform*


**xTimerPendFunctionCallFromISR() 参数和返回值**

- `xFunctionToPend`

  指向将在守护任务中执行的函数的指针（实际上只是函数名称）。该函数的原型必须与图 7.15 中的相同。

- `pvParameter1`

  将作为该函数的 `pvParameter1` 参数传递给守护任务中执行的函数的值。该参数具有 `void *` 类型，以允许传递任何数据类型。例如，整数类型可以直接转换为 `void *`，或者 `void *` 可以指向结构。

- `ulParameter2`

  将作为该函数的 `ulParameter2` 参数传递给守护任务中执行的函数的值。

- `pxHigherPriorityTaskWoken`

  `xTimerPendFunctionCallFromISR()` 将命令写入定时器命令队列。如果 RTOS 守护任务处于阻塞状态以等待定时器命令队列上的数据变为可用，则写入定时器命令队列将导致守护任务离开阻塞状态。如果守护任务的优先级高于当前执行任务（被中断的任务）的优先级，则在内部，`xTimerPendFunctionCallFromISR()` 将 `*pxHigherPriorityTaskWoken` 设置为 `pdTRUE`。

  如果 `xTimerPendFunctionCallFromISR()` 将此值设置为 `pdTRUE`，则必须在中断退出之前执行上下文切换。这将确保中断直接返回到守护任务，因为守护任务将是最高优先级的就绪状态任务。

- 返回值

  有两种可能的返回值：

  - `pdPASS`

    如果“执行函数”命令已写入定时器命令队列，则返回 `pdPASS`。

  - `pdFAIL`

    如果由于定时器命令队列已满而无法将“执行函数”命令写入定时器命令队列，则返回 `pdFAIL`。第 6 章描述了如何设置定时器命令队列的长度。


<a name="example7.3" title="Example 7.3 Centralized deferred interrupt processing"></a>
---
***Example 7.3*** *Centralized deferred interrupt processing*

---

示例 7.3 提供了与示例 7.1 类似的功能，但不使用信号量，也不创建专门的任务来执行中断引起的处理。相反，处理由 RTOS 守护任务执行。

示例 7.3 中使用的中断服务例程如图 7.16 所示。它调用 `xTimerPendFunctionCallFromISR()` 将指向 `vDeferredHandlingFunction()` 函数的指针传递给守护任务。延迟中断处理由 `vDeferredHandlingFunction()` 函数执行。

中断服务例程每次执行时都会递增一个名为 `ulParameterValue` 的变量。当 `vDeferredHandlingFunction()` 在守护任务中执行时，`ulParameterValue` 将作为 `ulParameter2` 的值传递给 `vDeferredHandlingFunction()`。该函数的另一个参数 `pvParameter1` 在本例中未使用。


<a name="list7.16" title="Listing 7.16 The software interrupt handler used in Example 7.3"></a>

```c
static uint32_t ulExampleInterruptHandler( void )
{
    static uint32_t ulParameterValue = 0;
    BaseType_t xHigherPriorityTaskWoken;

    /* The xHigherPriorityTaskWoken parameter must be initialized to pdFALSE
       as it will get set to pdTRUE inside the interrupt safe API function if
       a context switch is required. */
    xHigherPriorityTaskWoken = pdFALSE;

    /* Send a pointer to the interrupt's deferred handling function to the
       daemon task. The deferred handling function's pvParameter1 parameter
       is not used so just set to NULL. The deferred handling function's
       ulParameter2 parameter is used to pass a number that is incremented by
       one each time this interrupt handler executes. */
    xTimerPendFunctionCallFromISR( vDeferredHandlingFunction, /* Function to execute */
                                   NULL, /* Not used */
                                   ulParameterValue, /* Incrementing value. */
                                   &xHigherPriorityTaskWoken );
    ulParameterValue++;

    /* Pass the xHigherPriorityTaskWoken value into portYIELD_FROM_ISR(). If
       xHigherPriorityTaskWoken was set to pdTRUE inside
       xTimerPendFunctionCallFromISR() then calling portYIELD_FROM_ISR() will
       request a context switch. If xHigherPriorityTaskWoken is still pdFALSE
       then calling portYIELD_FROM_ISR() will have no effect. Unlike most
       FreeRTOS ports, the Windows port requires the ISR to return a value -
       the return statement is inside the Windows version
       of portYIELD_FROM_ISR(). */
    portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
}
```
***Listing 7.16*** *The software interrupt handler used in Example 7.3*


`vDeferredHandlingFunction()` 的实现如图 7.17 所示。它打印出一条固定字符串及其 `ulParameter2` 参数的值。

`vDeferredHandlingFunction()` 必须具有图 7.15 中所示的原型，即使在本例中仅使用了一个参数。


<a name="list7.17" title="Listing 7.17 The function that performs the processing necessitated by the interrupt in Example 7.3"></a>

```c
static void vDeferredHandlingFunction( void *pvParameter1, uint32_t ulParameter2 )
{
    /* Process the event - in this case just print out a message and the value
       of ulParameter2. pvParameter1 is not used in this example. */
    vPrintStringAndNumber( "Handler function - Processing event ", ulParameter2 );
}
```
***Listing 7.17*** *The function that performs the processing necessitated by the interrupt in Example 7.3*


示例 7.3 的 `main()` 函数如图 7.18 所示。它比示例 7.1 中的 `main()` 函数更简单，因为它不需要创建信号量或专门的任务来执行延迟中断处理。

`vPeriodicTask()` 是生成软件中断的任务。它的优先级设置低于守护任务的优先级，以确保在守护任务离开阻塞状态后被守护任务抢占。


<a name="list7.18" title="Listing 7.18 The implementation of main() for Example 7.3"></a>

```c
int main( void )
{
    /* The task that generates the software interrupt is created at a priority
       below the priority of the daemon task. The priority of the daemon task
       is set by the configTIMER_TASK_PRIORITY compile time configuration
       constant in FreeRTOSConfig.h. */
    const UBaseType_t ulPeriodicTaskPriority = configTIMER_TASK_PRIORITY - 1;

    /* Create the task that will periodically generate a software interrupt. */
    xTaskCreate( vPeriodicTask, "Periodic", 1000, NULL, ulPeriodicTaskPriority,
                 NULL );

    /* Install the handler for the software interrupt. The syntax necessary to
       do this is dependent on the FreeRTOS port being used. The syntax shown
       here can only be used with the FreeRTOS windows port, where such
       interrupts are only simulated. */
    vPortSetInterruptHandler( mainINTERRUPT_NUMBER, ulExampleInterruptHandler );

    /* Start the scheduler so the created task starts executing. */
    vTaskStartScheduler();

    /* As normal, the following line should never be reached. */
    for( ;; );
}
```
***Listing 7.18*** *The implementation of main() for Example 7.3*


当执行示例 7.3 时，产生的输出如图 7.10 所示。守护任务的优先级高于生成软件中断的任务的优先级，因此一旦中断被生成，守护任务就会执行 `vDeferredHandlingFunction()`。这导致 `vDeferredHandlingFunction()` 输出的消息出现在周期性任务输出的两条消息之间，就像使用信号量解除对专用延迟中断处理任务的阻塞一样。图 7.11 提供了进一步的解释。


<a name="fig7.10" title="Figure 7.10 The output produced when Example 7.3 is executed"></a>
<a name="fig7.11" title="Figure 7.11 The sequence of execution when Example 7.3 is executed"></a>

* * *
![](media/image57.jpg)
***Figure 7.10*** *The output produced when Example 7.3 is executed*

![](media/image58.png)
***Figure 7.11*** *The sequence of execution when Example 7.3 is executed*
* * *


## 7.7 在中断服务例程中使用队列

二进制信号量和计数信号量用于传递事件。队列用于传递事件和传输数据。

`xQueueSendToFrontFromISR()` 是 `xQueueSendToFront()` 的安全版本，可在中断服务例程中使用，`xQueueSendToBackFromISR()` 是 `xQueueSendToBack()` 的安全版本，可在中断服务例程中使用，`xQueueReceiveFromISR()` 是 `xQueueReceive()` 的安全版本，可在中断服务例程中使用。


### 7.7.1 xQueueSendToFrontFromISR() 和 xQueueSendToBackFromISR() API 函数


<a name="list7.19" title="Listing 7.19 The xQueueSendToFrontFromISR() API function prototype"></a>

```c
BaseType_t xQueueSendToFrontFromISR( QueueHandle_t xQueue,
                                     const void *pvItemToQueue
                                     BaseType_t *pxHigherPriorityTaskWoken );
```
***Listing 7.19*** *The xQueueSendToFrontFromISR() API function prototype*


<a name="list7.20" title="Listing 7.20 The xQueueSendToBackFromISR() API function prototype"></a>

```c
BaseType_t xQueueSendToBackFromISR( QueueHandle_t xQueue,
                                    const void *pvItemToQueue
                                    BaseType_t *pxHigherPriorityTaskWoken );
```
***Listing 7.20*** *The xQueueSendToBackFromISR() API function prototype*


`xQueueSendFromISR()` 和 `xQueueSendToBackFromISR()` 在功能上是等效的。

**xQueueSendToFrontFromISR() 和 xQueueSendToBackFromISR() 参数和返回值**

- `xQueue`

  正在向其发送数据（写入）的队列的句柄。
  队列句柄是通过用于创建队列的 `xQueueCreate()` 调用返回的。

- `pvItemToQueue`

  指向要放入队列中的项的指针。

  队列将要容纳的每个项目的大小是在创建队列时定义的，因此这些字节将从 `pvItemToQueue` 复制到队列存储区。

- `pxHigherPriorityTaskWoken`

  可能有一个或多个任务被阻塞在队列上，等待数据变为可用。调用 `xQueueSendToFrontFromISR()` 或 `xQueueSendToBackFromISR()` 可以使数据变为可用，从而导致这样的任务离开阻塞状态。如果调用 API 函数导致任务离开阻塞状态，并且解除阻塞的任务的优先级高于当前执行任务（被中断的任务）的优先级，则在内部，API 函数将 `*pxHigherPriorityTaskWoken` 设置为 `pdTRUE`。

  如果 `xQueueSendToFrontFromISR()` 或 `xQueueSendToBackFromISR()` 将此值设置为 `pdTRUE`，则应在中断退出之前执行上下文切换。这将确保中断直接返回到最高优先级的就绪状态任务。

- 返回值

  有两种可能的返回值：

  - `pdPASS`

    仅当数据已成功发送到队列时，才会返回 `pdPASS`。

  - `errQUEUE_FULL`

    如果由于队列已满而无法将数据发送到队列，则返回 `errQUEUE_FULL`。


### 7.7.2 从 ISR 使用队列时的注意事项

队列提供了一种简单方便的方式将数据从中断传递到任务，但如果数据以高频率到达，则使用队列效率不高。

FreeRTOS 下载中的许多演示应用程序包括一个简单的 UART 驱动程序，该驱动程序使用队列将字符从 UART 的接收 ISR 传递出去。在这些演示中，出于两个原因使用队列：演示如何从 ISR 使用队列，以及故意增加系统负载以测试 FreeRTOS 移植。以这种方式使用队列的 ISR 绝对不是为了表示高效的设计，除非数据以较慢的速度到达，否则不建议在生产代码中复制这种技术。适合生产代码的更高效的技术包括：

- 使用直接内存访问（DMA）硬件接收和缓冲字符。此方法几乎没有软件开销。然后，可以使用直接任务通知来解除对处理缓冲区的任务的阻塞，仅在检测到传输中断时才进行处理。

  [^20]: 直接任务通知提供了从 ISR 中解除对任务的阻塞的最有效方法。直接任务通知将在第 10 章中介绍。

- 将每个接收到的字符复制到线程安全的 RAM 缓冲区[^21]。同样，可以使用直接任务通知来解除对处理缓冲区的任务的阻塞，处理缓冲区在接收到完整消息或检测到传输中断后进行处理。

  [^21]: FreeRTOS+TCP 提供的“流缓冲区”（[https://www.FreeRTOS.org/tcp](http://www.FreeRTOS.org/tcp)）可用于此目的。

- 直接在 ISR 中处理接收到的字符，然后使用队列将处理结果（而不是原始数据）发送到任务。这在图 5.4 中已经演示过。

<a name="example7.4" title="Example 7.4 Sending and receiving on a queue from within an interrupt"></a>
---
***Example 7.4*** *Sending and receiving on a queue from within an interrupt*

---

此示例演示了如何在同一中断中使用 `xQueueSendToBackFromISR()` 和 `xQueueReceiveFromISR()`。为了方便，中断由软件生成。

创建了一个周期性任务，该任务每 200 毫秒向队列发送五个数字。仅在发送完所有五个值后才生成软件中断。任务实现如图 7.21 所示。


<a name="list7.21" title="Listing 7.21 The implementation of the task that writes to the queue in Example 7.4"></a>

```c
static void vIntegerGenerator( void *pvParameters )
{
    TickType_t xLastExecutionTime;
    uint32_t ulValueToSend = 0;
    int i;

    /* Initialize the variable used by the call to vTaskDelayUntil(). */
    xLastExecutionTime = xTaskGetTickCount();

    for( ;; )
    {
        /* This is a periodic task. Block until it is time to run again. The
           task will execute every 200ms. */
        vTaskDelayUntil( &xLastExecutionTime, pdMS_TO_TICKS( 200 ) );

        /* Send five numbers to the queue, each value one higher than the
           previous value. The numbers are read from the queue by the interrupt
           service routine. The interrupt service routine always empties the
           queue, so this task is guaranteed to be able to write all five
           values without needing to specify a block time. */
        for( i = 0; i < 5; i++ )
        {
            xQueueSendToBack( xIntegerQueue, &ulValueToSend, 0 );
            ulValueToSend++;
        }

        /* Generate the interrupt so the interrupt service routine can read the
           values from the queue. The syntax used to generate a software
           interrupt is dependent on the FreeRTOS port being used. The syntax
           used below can only be used with the FreeRTOS Windows port, in which
           such interrupts are only simulated. */
        vPrintString( "Generator task - About to generate an interrupt.\r\n" );
        vPortGenerateSimulatedInterrupt( mainINTERRUPT_NUMBER );
        vPrintString( "Generator task - Interrupt generated.\r\n\r\n\r\n" );
    }
}
```
***Listing 7.21*** *The implementation of the task that writes to the queue in Example 7.4*


中断服务例程调用 `xQueueReceiveFromISR()` 直到所有写入周期性任务的值都被读取，队列为空。接收到的值的最后两位用于作为字符串数组的索引。然后使用对 `xQueueSendFromISR()` 的调用将指向相应索引位置的字符串的指针发送到另一个队列。中断服务例程的实现如图 7.22 所示。


<a name="list7.22" title="Listing 7.22 The implementation of the interrupt service routine used by Example 7.4"></a>

```c
static uint32_t ulExampleInterruptHandler( void )
{
    BaseType_t xHigherPriorityTaskWoken;
    uint32_t ulReceivedNumber;

    /* The strings are declared static const to ensure they are not allocated
       on the interrupt service routine's stack, and so exist even when the
       interrupt service routine is not executing. */

    static const char *pcStrings[] =
    {
        "String 0\r\n",
        "String 1\r\n",
        "String 2\r\n",
        "String 3\r\n"
    };

    /* As always, xHigherPriorityTaskWoken is initialized to pdFALSE to be
       able to detect it getting set to pdTRUE inside an interrupt safe API
       function.  Note that as an interrupt safe API function can only set
       xHigherPriorityTaskWoken to pdTRUE, it is safe to use the same
       xHigherPriorityTaskWoken variable in both the call to
       xQueueReceiveFromISR() and the call to xQueueSendToBackFromISR(). */
    xHigherPriorityTaskWoken = pdFALSE;

    /* Read from the queue until the queue is empty. */
    while( xQueueReceiveFromISR( xIntegerQueue,
                                 &ulReceivedNumber,
                                 &xHigherPriorityTaskWoken ) != errQUEUE_EMPTY )
    {
        /* Truncate the received value to the last two bits (values 0 to 3
           inclusive), then use the truncated value as an index into the
           pcStrings[] array to select a string (char *) to send on the other
           queue. */
        ulReceivedNumber &= 0x03;
        xQueueSendToBackFromISR( xStringQueue,
                                 &pcStrings[ ulReceivedNumber ],
                                 &xHigherPriorityTaskWoken );
    }

    /* If receiving from xIntegerQueue caused a task to leave the Blocked
       state, and if the priority of the task that left the Blocked state is
       higher than the priority of the task in the Running state, then
       xHigherPriorityTaskWoken will have been set to pdTRUE inside
       xQueueReceiveFromISR().

       If sending to xStringQueue caused a task to leave the Blocked state, and
       if the priority of the task that left the Blocked state is higher than
       the priority of the task in the Running state, then
       xHigherPriorityTaskWoken will have been set to pdTRUE inside
       xQueueSendToBackFromISR().

       xHigherPriorityTaskWoken is used as the parameter to portYIELD_FROM_ISR().
       If xHigherPriorityTaskWoken equals pdTRUE then calling portYIELD_FROM_ISR()
       will request a context switch. If xHigherPriorityTaskWoken is still pdFALSE then calling portYIELD_FROM_ISR() will have no effect.

       The implementation of portYIELD_FROM_ISR() used by the Windows port
       includes a return statement, which is why this function does not
       explicitly return a value. */
    portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
}
```
***Listing 7.22*** *The implementation of the interrupt service routine used by Example 7.4*


从中断服务例程接收字符指针的任务在消息到达时在队列上阻塞，打印出每个接收到的字符串。其实现如图 7.23 所示。


<a name="list7.23" title="Listing 7.23 The task that prints out the strings received from the interrupt service routine in Example 7.4"></a>

```c
static void vStringPrinter( void *pvParameters )
{
    char *pcString;

    for( ;; )
    {
        /* Block on the queue to wait for data to arrive. */
        xQueueReceive( xStringQueue, &pcString, portMAX_DELAY );

        /* Print out the string received. */
        vPrintString( pcString );
    }
}
```
***Listing 7.23*** *The task that prints out the strings received from the interrupt service routine in Example 7.4*

与往常一样，`main()` 创建所需的队列和任务，然后启动调度程序。其实现如图 7.24 所示。


<a name="list7.24" title="Listing 7.24 The main() function for Example 7.4"></a>

```c
int main( void )
{
    /* Before a queue can be used it must first be created. Create both queues
       used by this example. One queue can hold variables of type uint32_t, the
       other queue can hold variables of type char*. Both queues can hold a
       maximum of 10 items. A real application should check the return values
       to ensure the queues have been successfully created. */
    xIntegerQueue = xQueueCreate( 10, sizeof( uint32_t ) );
    xStringQueue = xQueueCreate( 10, sizeof( char * ) );

    /* Create the task that uses a queue to pass integers to the interrupt
       service routine. The task is created at priority 1. */
    xTaskCreate( vIntegerGenerator, "IntGen", 1000, NULL, 1, NULL );

    /* Create the task that prints out the strings sent to it from the
       interrupt service routine. This task is created at the higher
       priority of 2. */
    xTaskCreate( vStringPrinter, "String", 1000, NULL, 2, NULL );

    /* Install the handler for the software interrupt. The syntax necessary to
       do this is dependent on the FreeRTOS port being used. The syntax shown
       here can only be used with the FreeRTOS Windows port, where such
       interrupts are only simulated. */
    vPortSetInterruptHandler( mainINTERRUPT_NUMBER, ulExampleInterruptHandler );

    /* Start the scheduler so the created tasks start executing. */
    vTaskStartScheduler();

    /* If all is well then main() will never reach here as the scheduler will
       now be running the tasks. If main() does reach here then it is likely
       that there was insufficient heap memory available for the idle task
       to be created. Chapter 2 provides more information on heap memory
       management. */
    for( ;; );
}
```
***Listing 7.24*** *The main() function for Example 7.4*

当执行示例 7.4 时，产生的输出如图 7.12 所示。如所见，中断接收到所有五个整数，并响应产生五个字符串。图 7.13 对执行示例 7.4 时产生的输出进行了进一步的解释。


<a name="fig7.12" title="Figure 7.12 The output produced when Example 7.4 is executed"></a>
<a name="fig7.13" title="Figure 7.13 The sequence of execution produced by Example 7.4"></a>

* * *
![](media/image59.jpg)
***Figure 7.12*** *The output produced when Example 7.4 is executed*

![](media/image60.png)
***Figure 7.13*** *The sequence of execution produced by Example 7.4*
* * *


## 7.8 中断嵌套

任务优先级和中断优先级之间的混淆是很常见的。本节讨论中断优先级，即中断服务例程（ISR）相对于彼此的执行优先级。分配给任务的优先级与中断分配的优先级无关。硬件决定 ISR 何时执行，而软件决定任务何时执行。ISR 是响应硬件中断执行的，它将中断一个任务，但一个任务无法抢占 ISR。

支持中断嵌套的移植需要在 FreeRTOSConfig.h 中定义一个或两个常量。`configMAX_SYSCALL_INTERRUPT_PRIORITY` 和 `configMAX_API_CALL_INTERRUPT_PRIORITY` 都定义了相同的属性。较旧的 FreeRTOS 移植使用 `configMAX_SYSCALL_INTERRUPT_PRIORITY`，较新的 FreeRTOS 移植使用 `configMAX_API_CALL_INTERRUPT_PRIORITY`。

**控制中断嵌套的常量**

- `configMAX_SYSCALL_INTERRUPT_PRIORITY` 或 `configMAX_API_CALL_INTERRUPT_PRIORITY`

  设置可以从中断安全 FreeRTOS API 函数调用的最高中断优先级。

- `configKERNEL_INTERRUPT_PRIORITY`

  设置滴答中断使用的中断优先级，必须始终设置为最低的中断优先级。

  如果所使用的 FreeRTOS 移植不使用 `configMAX_SYSCALL_INTERRUPT_PRIORITY` 常量，则任何使用中断安全 FreeRTOS API 函数的中断也必须在 `configKERNEL_INTERRUPT_PRIORITY` 定义的优先级下执行。

每个中断源都有一个数字优先级和一个逻辑优先级：

- 数字优先级

  数字优先级就是分配给中断优先级的数字。例如，如果中断被分配优先级 7，则其数字优先级就是 7。同样，如果中断被分配优先级 200，则其数字优先级就是 200。

- 逻辑优先级

  中断的逻辑优先级描述了该中断相对于其他中断的优先级。

  如果两个优先级不同的中断同时发生，则处理器将执行具有更高逻辑优先级的中断的 ISR，然后才会执行具有较低逻辑优先级的中断的 ISR。

  一个中断可以打断（嵌套）任何具有较低逻辑优先级的中断，但不能打断（嵌套）任何具有相等或更高逻辑优先级的中断。

中断的数字优先级与逻辑优先级之间的关系取决于处理器体系结构；在某些处理器上，分配给中断的数字优先级越高，该中断的逻辑优先级就越高，而在其他处理器体系结构上则相反。

通过将 `configMAX_SYSCALL_INTERRUPT_PRIORITY` 设置为高于 `configKERNEL_INTERRUPT_PRIORITY` 的逻辑中断优先级，可以创建完整的中断嵌套模型。这在图 7.14 中得到了证明，该图显示了以下场景：

- 处理器具有七个唯一的中断优先级。
- 分配数字优先级 7 的中断的逻辑优先级高于分配数字优先级 1 的中断。
- `configKERNEL_INTERRUPT_PRIORITY` 设置为 1。
- `configMAX_SYSCALL_INTERRUPT_PRIORITY` 设置为 3。


<a name="fig7.14" title="Figure 7.14 Constants affecting interrupt nesting behavior"></a>

* * *
![](media/image61.png)
***Figure 7.14*** *Constants affecting interrupt nesting behavior*
* * *

图 7.14 说明：

- 使用优先级 1 到 3（包括 3）的中断，在内核或应用程序处于关键段时被禁止执行。以这些优先级运行的 ISR 可以使用中断安全的 FreeRTOS API 函数。关键段在第 8 章中描述。

- 使用优先级 4 或更高的中断不受关键段的影响，因此调度程序所做的任何事情都不会阻止这些中断立即执行——在硬件本身的限制内。以这些优先级执行的 ISR 不能使用任何 FreeRTOS API 函数。

- 通常，需要非常严格的时间精度的功能（例如电机控制）将使用高于 `configMAX_SYSCALL_INTERRUPT_PRIORITY` 的优先级，以确保调度程序不会给中断响应时间引入抖动。


### 7.8.1 针对 ARM Cortex-M[^22] 和 ARM GIC 用户的说明

[^22]: 本节仅部分适用于 Cortex-M0 和 Cortex-M0+ 内核。

Cortex-M 处理器上的中断配置令人困惑，容易出错。为了帮助您的开发，FreeRTOS Cortex-M 移植会自动检查中断配置，但仅在定义了 `configASSERT()` 的情况下。`configASSERT()` 在 11.2 节中描述。

ARM Cortex 内核和 ARM 通用中断控制器（GIC）使用数字上较低的优先级编号来表示逻辑上较高的优先级中断。这可能看起来违反直觉，并且很容易忘记。如果您希望分配给中断一个逻辑上较低的优先级，则必须分配给它一个数字上较高的值。如果您希望分配给中断一个逻辑上较高的优先级，则必须分配给它一个数字上较低的值。

Cortex-M 中断控制器允许使用最多八位来指定每个中断的优先级，因此最低优先级为 255。零是最高优先级。然而，Cortex-M 微控制器通常仅实现八位中的一部分。实际实现的位数取决于微控制器系列。

当仅实现八位中的一部分时，仅高位字节的最高有效位可以使用——将最低有效位设置为未实现。未实现的位可以取任何值，但通常设置为 1。这在图 7.15 中得到了证明，该图显示了优先级为二进制 101 的值是如何存储在实现了四个优先级位的 Cortex-M 微控制器中的。


<a name="fig7.15" title="Figure 7.15 How a priority of binary 101 is stored by a Cortex-M microcontroller that implements four priority bits"></a>

* * *
![](media/image62.png)
***Figure 7.15*** *How a priority of binary 101 is stored by a Cortex-M microcontroller that implements four priority bits*
* * *

在图 7.15 中，二进制值 101 已被移入最高有效的四个位，因为最低有效的四个位未实现。未实现的位被设置为 1。

某些库函数期望在将优先级值写入 Cortex-M 寄存器之前，将其移位到实现的（最高有效）位中。当使用此类函数时，图 7.15 中的优先级可以指定为十进制 95。十进制 95 是将二进制 101 向上移位四位以形成二进制 101nnnn（其中“n”是未实现的位），并将未实现的位设置为 1 以形成二进制 1011111。

某些库函数期望在将优先级值写入 Cortex-M 寄存器之前，将其移位到实现的（最高有效）位中。当使用此类函数时，图 7.15 中的优先级必须指定为十进制 5。十进制 5 是二进制 101 的移位值，没有任何移位。

`configMAX_SYSCALL_INTERRUPT_PRIORITY` 和 `configKERNEL_INTERRUPT_PRIORITY` 必须以允许直接写入 Cortex-M 寄存器的方式进行指定，因此在优先级值移位到实现的位之后。

`configKERNEL_INTERRUPT_PRIORITY` 必须始终设置为最低可能的中断优先级。未实现的优先级位可以设置为 1，因此该常量可以始终设置为 255，无论实际实现了多少个优先级位。

Cortex-M 中断的默认优先级为零——最高可能的优先级。使用 FreeRTOS API 的中断的优先级不得留在默认值。
