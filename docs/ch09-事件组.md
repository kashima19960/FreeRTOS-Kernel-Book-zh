# 9 事件组

## 9.1 章节介绍与范围

前文已经指出，实时嵌入式系统必须对事件作出响应。此前章节介绍了 FreeRTOS 中用于
向任务传递事件的特性，如信号量与队列，它们都具有以下属性：

- 允许任务在 *Blocked* 状态等待单个事件发生。

- 当事件发生时只唤醒一个任务，即等待该事件的最高优先级任务。

事件组是 FreeRTOS 的另一项特性，用于向任务传递事件。不同于队列与信号量：

- 事件组允许任务在 *Blocked* 状态等待一个或多个事件的组合发生。

- 当事件发生时，会唤醒所有等待同一事件或事件组合的任务。

事件组这些独特特性使其适用于：
多任务同步、向多个任务广播事件、让任务等待一组事件中的任意一个发生，以及让任务等待
多个动作完成。

事件组还有助于降低 RAM 占用，因为常常可以用一个事件组替代多个二值信号量。

事件组功能是可选的。要使用事件组功能，请将 FreeRTOS 源文件 event_groups.c
加入工程构建。


### 9.1.1 范围

本章旨在帮助读者理解：

- 事件组的实际用途。
- 事件组相对于其他 FreeRTOS 特性的优缺点。
- 如何在事件组中置位。
- 如何在 *Blocked* 状态等待事件组中的位被置位。
- 如何使用事件组同步一组任务。


## 9.2 事件组的特性

### 9.2.1 事件组、事件标志与事件位

事件“标志”是一个布尔值（1 或 0），用于指示事件是否发生。事件“组”是一组事件标志。

事件标志只能为 1 或 0，因此可用单个 bit 存储事件标志状态，并用单个变量存储事件组
所有事件标志状态。事件组中每个事件标志由 `EventBits_t` 类型变量中的一个 bit 表示。
因此事件标志也称为事件“位”。若 `EventBits_t` 变量中的某 bit 置为 1，则该 bit 所代表
的事件已发生；若置为 0，则该事件未发生。

图 9.1 展示事件标志如何映射到 `EventBits_t` 变量中的 bit。


<a name="fig9.1" title="Figure 9.1 Event flag to bit number mapping in a variable of type EventBits_t"></a>

* * *
![](media/image71.png)
***图 9.1*** *事件标志与 EventBits_t 变量中 bit 编号的映射*
* * *

例如，若事件组值为 0x92（二进制 1001 0010），则只有事件位 1、4 和 7 置位，
表示仅这些位对应的事件已发生。图 9.2 展示一个 `EventBits_t` 变量，其中事件位 1、4、7
置位，其他位清零，因此事件组值为 0x92。


<a name="fig9.2" title="Figure 9.2 An event group in which only bits 1, 4 and 7 are set, and all the other event flags are clear, making the event group's value 0x92"></a>

* * *
![](media/image72.png)
***图 9.2*** *仅 1、4、7 位为 1 的事件组，事件组值为 0x92*
* * *

事件组中各 bit 的含义由应用编写者定义。例如，可以创建一个事件组并：

- 定义 bit 0 表示“收到来自网络的消息”。

- 定义 bit 1 表示“有消息可发送到网络”。

- 定义 bit 2 表示“中止当前网络连接”。


### 9.2.2 EventBits_t 数据类型的更多信息

事件组中事件位数量取决于 FreeRTOSConfig.h 中的编译期常量
`configTICK_TYPE_WIDTH_IN_BITS`[^24]：

[^24]: `configTICK_TYPE_WIDTH_IN_BITS` 配置用于保存 RTOS tick 计数的类型，
看似与事件组无关。其对 `EventBits_t` 类型的影响源于 FreeRTOS 的内部实现。
尽管将 `configTICK_TYPE_WIDTH_IN_BITS` 设为 `TICK_TYPE_WIDTH_16_BITS` 是可取的，
但仅应在处理器对 16 位类型效率显著高于 32 位类型时才这么做。

- 若 `configTICK_TYPE_WIDTH_IN_BITS` 为 `TICK_TYPE_WIDTH_16_BITS`，
  每个事件组有 8 个可用事件位。

- 若 `configTICK_TYPE_WIDTH_IN_BITS` 为 `TICK_TYPE_WIDTH_32_BITS`，
  每个事件组有 24 个可用事件位。

- 若 `configTICK_TYPE_WIDTH_IN_BITS` 为 `TICK_TYPE_WIDTH_64_BITS`，
  每个事件组有 56 个可用事件位。


### 9.2.3 多任务访问

事件组是独立对象，任何知晓其存在的任务或 ISR 都可访问它。多个任务可以设置同一
事件组的位，也可以从同一事件组读取位。


### 9.2.4 事件组的实际使用示例

FreeRTOS+TCP 的 TCP/IP 协议栈实现提供了一个事件组用法的实际例子，展示如何
同时简化设计并减少资源使用。

TCP 套接字必须响应多种事件，如 accept、bind、read、close 等。套接字在任一时刻
可能发生的事件取决于其状态。例如，一个套接字已创建但尚未绑定地址，则可能收到 bind
事件，但不会收到 read 事件（因为尚无地址可读数据）。

FreeRTOS+TCP 套接字状态保存在 `FreeRTOS_Socket_t` 结构体中，该结构体包含一个事件组，
为套接字需要处理的每类事件定义一个事件位。阻塞等待某事件或事件组合的
FreeRTOS+TCP API 调用，会直接阻塞在该事件组上。

该事件组还包含一个 “abort” 位，使 TCP 连接可在任何等待事件时刻被中止。


## 9.3 使用事件组进行事件管理

### 9.3.1 xEventGroupCreate() API 函数

FreeRTOS 还提供 `xEventGroupCreateStatic()`，用于在编译期静态分配创建事件组
所需内存：事件组在使用前必须显式创建。

事件组通过 `EventGroupHandle_t` 类型变量引用。`xEventGroupCreate()` 用于创建
事件组，并返回一个 `EventGroupHandle_t` 作为句柄。


<a name="list9.1" title="Listing 9.1 The xEventGroupCreate() API function prototype"></a>

```c
EventGroupHandle_t xEventGroupCreate( void );
```
***清单 9.1*** *xEventGroupCreate() API 函数原型*


**xEventGroupCreate() 返回值**

- 返回值

  若返回 NULL，则表示堆内存不足，无法为事件组分配数据结构。第 3 章提供
  更多堆内存管理信息。

  若返回非 NULL，则表示事件组创建成功，返回值应保存为该事件组句柄。


### 9.3.2 xEventGroupSetBits() API 函数

`xEventGroupSetBits()` 用于在事件组中置位一个或多个 bit，通常用于通知任务
这些 bit 所表示的事件已发生。

> *注意：不要在 ISR 中调用 `xEventGroupSetBits()`。应使用其中断安全版本
> `xEventGroupSetBitsFromISR()`。*


<a name="list9.2" title="Listing 9.2. The xEventGroupSetBits() API function prototype"></a>

```c
EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,

const EventBits_t uxBitsToSet );
```
***清单 9.2*** *xEventGroupSetBits() API 函数原型*


**xEventGroupSetBits() 参数与返回值**

- `xEventGroup`

  要置位的事件组句柄。该句柄由 `xEventGroupCreate()` 创建事件组时返回。

- `uxBitsToSet`

  需置位为 1 的事件位掩码。事件组值通过与 `uxBitsToSet` 进行按位 OR 更新。

  例如，将 `uxBitsToSet` 设为 0x04（二进制 0100）将使事件位 3 被置位（若原本未置位），
  其他位保持不变。

- 返回值

  `xEventGroupSetBits()` 返回时事件组的值。注意该返回值不一定包含 `uxBitsToSet`
  指定的位，因为这些位可能已被其他任务清除。


### 9.3.3 xEventGroupSetBitsFromISR() API 函数

`xEventGroupSetBitsFromISR()` 是 `xEventGroupSetBits()` 的中断安全版本。

释放信号量是确定性操作，因为已知最多只有一个任务会离开 *Blocked* 状态。
而设置事件组位时，无法预知会有多少任务离开 *Blocked* 状态，因此设置事件位是
非确定性操作。

FreeRTOS 的设计与实现规范不允许在 ISR 或中断禁用状态下执行非确定性操作。
因此 `xEventGroupSetBitsFromISR()` 不在 ISR 中直接置位，而是将动作延迟到
RTOS 守护任务执行。


<a name="list9.3" title="Listing 9.3 The xEventGroupSetBitsFromISR() API function prototype"></a>

```c
BaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup,
												  const EventBits_t uxBitsToSet,
												  BaseType_t *pxHigherPriorityTaskWoken );
```
***清单 9.3*** *xEventGroupSetBitsFromISR() API 函数原型*


**xEventGroupSetBitsFromISR() 参数与返回值**

- `xEventGroup`

  要置位的事件组句柄。该句柄由 `xEventGroupCreate()` 创建事件组时返回。

- `uxBitsToSet`

  需置位为 1 的事件位掩码。事件组值通过与 `uxBitsToSet` 进行按位 OR 更新。

  例如，将 `uxBitsToSet` 设为 0x05（二进制 0101）将使事件位 2 与事件位 0 被置位
  （若原本未置位），其他位保持不变。

- `pxHigherPriorityTaskWoken`

  `xEventGroupSetBitsFromISR()` 不在 ISR 中直接置位，而是通过定时器命令队列发送
  命令，由 RTOS 守护任务完成。若守护任务正阻塞在定时器命令队列上等待数据，
  写队列会使守护任务离开 *Blocked* 状态。若守护任务优先级高于当前执行任务
  （被中断的任务），则 `xEventGroupSetBitsFromISR()` 会将
  `*pxHigherPriorityTaskWoken` 置为 `pdTRUE`。

  若 `xEventGroupSetBitsFromISR()` 将该值置为 `pdTRUE`，则应在退出中断前执行
  上下文切换，确保中断直接返回到守护任务（最高优先级 *Ready* 任务）。

- 返回值

  有两种可能返回值：

  - `pdPASS`：仅当成功将数据写入定时器命令队列时返回。

  - `pdFALSE`：若定时器命令队列已满，无法写入“置位”命令，则返回。


### 9.3.4 xEventGroupWaitBits() API 函数

`xEventGroupWaitBits()` 允许任务读取事件组值，并在事件位未置位时可选择在
*Blocked* 状态等待事件组中的一个或多个位被置位。


<a name="list9.4" title="Listing 9.4 The xEventGroupWaitBits() API function prototype"></a>

```c
EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup,
											const EventBits_t uxBitsToWaitFor,
											const BaseType_t xClearOnExit,
											const BaseType_t xWaitForAllBits,
											TickType_t xTicksToWait );
```
***清单 9.4*** *xEventGroupWaitBits() API 函数原型*

调度器判断任务是否进入 *Blocked* 状态以及何时离开 *Blocked* 状态的条件称为
“解除阻塞条件”。解除阻塞条件由 `uxBitsToWaitFor` 与 `xWaitForAllBits`
参数组合指定：

- `uxBitsToWaitFor` 指定要测试的事件位。

- `xWaitForAllBits` 指定使用按位 OR 还是按位 AND 测试。

若在调用 `xEventGroupWaitBits()` 时解除阻塞条件已经满足，则任务不会进入
*Blocked* 状态。

表 6 给出了导致任务进入或离开 *Blocked* 状态的示例条件。表 6 仅显示事件组与
`uxBitsToWaitFor` 值的最低四位，其余位默认为 0。

<a name="tbl6" title="Table 6 The Effect of the uxBitsToWaitFor and xWaitForAllBits Parameters"></a>

* * *
| 当前事件组值 | uxBitsToWaitFor 值 | xWaitForAllBits 值 | 结果行为 |
| -------------------------- | --------------------- | --------------------- | ------------------ |
| 0000 | 0101 | pdFALSE | 调用任务进入 *Blocked* 状态，因为事件组中 bit 0 与 bit 2 都未置位；当 bit 0 或 bit 2 任意一个被置位时离开 *Blocked* 状态。 |
| 0100 | 0101 | pdTRUE | 调用任务进入 *Blocked* 状态，因为 bit 0 与 bit 2 未同时置位；当 bit 0 与 bit 2 同时置位时离开 *Blocked* 状态。 |
| 0100 | 0110 | pdFALSE | 调用任务不会进入 *Blocked* 状态，因为 xWaitForAllBits 为 pdFALSE 且 uxBitsToWaitFor 指定的两位中已有一位置位。 |
| 0100 | 0110 | pdTRUE | 调用任务进入 *Blocked* 状态，因为 xWaitForAllBits 为 pdTRUE 且 uxBitsToWaitFor 指定的两位中仅一位置位；当 bit 1 与 bit 2 同时置位时离开 *Blocked* 状态。 |

***表 6*** *uxBitsToWaitFor 与 xWaitForAllBits 参数的影响*
* * *

调用任务通过 `uxBitsToWaitFor` 指定要测试的位，且很可能在解除阻塞条件满足后
需要将这些位清零。事件位可用 `xEventGroupClearBits()` 清除，但在以下情况下，
手动清除会引入竞争条件：

- 有多个任务使用同一事件组。
- 事件位由其他任务或 ISR 置位。

`xClearOnExit` 参数用于避免潜在竞争条件。若 `xClearOnExit` 设为 `pdTRUE`，
则事件位的测试与清除对调用任务而言是原子操作（不可被其他任务或中断打断）。

**xEventGroupWaitBits() 参数与返回值**

- `xEventGroup`

  要读取事件位的事件组句柄。该句柄由 `xEventGroupCreate()` 创建事件组时返回。

- `uxBitsToWaitFor`

  指定要测试的事件位掩码。

  例如，若调用任务希望等待事件位 0 和/或事件位 2 置位，则可将 `uxBitsToWaitFor`
  设为 0x05（二进制 0101）。更多示例见表 6。

- `xClearOnExit`

  若调用任务的解除阻塞条件满足且 `xClearOnExit` 为 `pdTRUE`，则在调用任务
  退出 `xEventGroupWaitBits()` 前，会将 `uxBitsToWaitFor` 指定的事件位清零。

  若 `xClearOnExit` 为 `pdFALSE`，则 `xEventGroupWaitBits()` 不改变事件组中的位。

- `xWaitForAllBits`

  `uxBitsToWaitFor` 指定要测试的事件位，`xWaitForAllBits` 指定当
  `uxBitsToWaitFor` 指定的位中任意一个置位即解除阻塞，还是必须全部置位才解除阻塞。

  若 `xWaitForAllBits` 为 `pdFALSE`，则任务会在 `uxBitsToWaitFor` 指定的任意一位
  置位时离开 *Blocked* 状态（或在 `xTicksToWait` 超时后离开）。

  若 `xWaitForAllBits` 为 `pdTRUE`，则任务仅在 `uxBitsToWaitFor` 指定的所有位
  都置位时离开 *Blocked* 状态（或在 `xTicksToWait` 超时后离开）。

  示例见表 6。

- `xTicksToWait`

  任务在 *Blocked* 状态等待解除阻塞条件满足的最长时间。

  若 `xTicksToWait` 为 0，或调用 `xEventGroupWaitBits()` 时解除阻塞条件已满足，
  则立即返回。

  阻塞时间以 tick 为单位，绝对时间取决于 tick 频率。
  可使用 `pdMS_TO_TICKS()` 将毫秒转换为 tick。

  若 FreeRTOSConfig.h 中 `INCLUDE_vTaskSuspend` 设为 1，将 `xTicksToWait` 设为
  `portMAX_DELAY` 会使任务无限期等待（无超时）。

- 返回值

  若 `xEventGroupWaitBits()` 因解除阻塞条件满足而返回，则返回值为条件满足时
  的事件组值（若 `xClearOnExit` 为 `pdTRUE`，则在自动清零之前）。此时返回值也
  满足解除阻塞条件。

  若 `xEventGroupWaitBits()` 因 `xTicksToWait` 超时而返回，则返回值为超时发生时
  的事件组值。此时返回值不满足解除阻塞条件。


### 9.3.5 xEventGroupGetStaticBuffer() API 函数

`xEventGroupGetStaticBuffer()` 提供获取静态创建事件组所用缓冲区指针的方法。
该缓冲区与创建事件组时提供的缓冲区相同。

*注意：不要在 ISR 中调用 `xEventGroupGetStaticBuffer()`。*


<a name="list9.5" title="Listing 9.5 The xEventGroupGetStaticBuffer() API function prototype"></a>

```c
BaseType_t xEventGroupGetStaticBuffer( EventGroupHandle_t xEventGroup,

StaticEventGroup_t ** ppxEventGroupBuffer );
```
***清单 9.5*** *xEventGroupGetStaticBuffer() API 函数原型*


**xEventGroupGetStaticBuffer() 参数与返回值**

- `xEventGroup`

  要获取缓冲区的事件组。该事件组必须由 `xEventGroupCreateStatic()` 创建。

- `ppxEventGroupBuffer`

  用于返回事件组数据结构缓冲区指针，即创建时提供的同一缓冲区。

- 返回值

  有两种可能返回值：

  - `pdTRUE`：成功获取缓冲区。

  - `pdFALSE`：未能成功获取缓冲区。

<a name="example9.1" title="Example 9.1 Experimenting with event groups"></a>
---
***示例 9.1*** *使用事件组进行实验*

---

该示例演示如何：

- 创建事件组。
- 在 ISR 中设置事件组位。
- 在任务中设置事件组位。
- 在事件组上阻塞等待。

通过先将 `xEventGroupWaitBits()` 的 `xWaitForAllBits` 设为 `pdFALSE` 运行示例，
再将 `xWaitForAllBits` 设为 `pdTRUE` 运行示例，演示 `xWaitForAllBits` 参数的效果。

事件位 0 与事件位 1 由任务设置，事件位 2 由 ISR 设置。三个位使用清单 9.6 的
`#define` 语句赋予描述性名称。


<a name="list9.6" title="Listing 9.6 Event bit definitions used in Example 9.1"></a>

```c
/* Definitions for the event bits in the event group. */
#define mainFIRST_TASK_BIT ( 1UL << 0UL )  /* Event bit 0, set by a task */
#define mainSECOND_TASK_BIT ( 1UL << 1UL ) /* Event bit 1, set by a task */
#define mainISR_BIT ( 1UL << 2UL )         /* Event bit 2, set by an ISR */
```
***清单 9.6*** *示例 9.1 使用的事件位定义*


清单 9.7 展示设置事件位 0 与事件位 1 的任务实现。任务循环运行，依次设置位，
两次 `xEventGroupSetBits()` 调用之间延时 200ms。每次置位前都会输出字符串，
便于在控制台观察执行顺序。


<a name="list9.7" title="Listing 9.7 The task that sets two bits in the event group in Example 9.1"></a>

```c
static void vEventBitSettingTask( void *pvParameters )
{
	 const TickType_t xDelay200ms = pdMS_TO_TICKS( 200UL );

	 for( ;; )
	 {
		  /* Delay for a short while before starting the next loop. */
		  vTaskDelay( xDelay200ms );

		  /* Print out a message to say event bit 0 is about to be set by the
			  task, then set event bit 0. */
		  vPrintString( "Bit setting task -\t about to set bit 0.\r\n" );
		  xEventGroupSetBits( xEventGroup, mainFIRST_TASK_BIT );

		  /* Delay for a short while before setting the other bit. */
		  vTaskDelay( xDelay200ms );

		  /* Print out a message to say event bit 1 is about to be set by the
			  task, then set event bit 1. */
		  vPrintString( "Bit setting task -\t about to set bit 1.\r\n" );
		  xEventGroupSetBits( xEventGroup, mainSECOND_TASK_BIT );
	 }
}
```
***清单 9.7*** *示例 9.1 中设置两个事件位的任务*


清单 9.8 展示 ISR 的实现，它设置事件组中的 bit 2。同样，置位前会输出字符串以便
观察执行顺序。但由于不应在 ISR 中直接输出，故使用 `xTimerPendFunctionCallFromISR()`
将输出延迟到 RTOS 守护任务上下文执行。

与前例一样，ISR 由一个简单的周期任务触发软件中断。本例每 500ms 生成一次中断。


<a name="list9.8" title="Listing 9.8 The ISR that sets bit 2 in the event group in Example 9.1"></a>

```c
static uint32_t ulEventBitSettingISR( void )
{
	 /* The string is not printed within the interrupt service routine, but is
		 instead sent to the RTOS daemon task for printing. It is therefore
		 declared static to ensure the compiler does not allocate the string on
		 the stack of the ISR, as the ISR's stack frame will not exist when the
		 string is printed from the daemon task. */
	 static const char *pcString = "Bit setting ISR -\t about to set bit 2.\r\n";
	 BaseType_t xHigherPriorityTaskWoken = pdFALSE;

	 /* Print out a message to say bit 2 is about to be set. Messages cannot
		 be printed from an ISR, so defer the actual output to the RTOS daemon
		 task by pending a function call to run in the context of the RTOS
		 daemon task. */
	 xTimerPendFunctionCallFromISR( vPrintStringFromDaemonTask,
											  ( void * ) pcString,
											  0,
											  &xHigherPriorityTaskWoken );

	 /* Set bit 2 in the event group. */
	 xEventGroupSetBitsFromISR( xEventGroup,
										 mainISR_BIT,
										 &xHigherPriorityTaskWoken );

	 /* xTimerPendFunctionCallFromISR() and xEventGroupSetBitsFromISR() both
		 write to the timer command queue, and both used the same
		 xHigherPriorityTaskWoken variable. If writing to the timer command
		 queue resulted in the RTOS daemon task leaving the Blocked state, and
		 if the priority of the RTOS daemon task is higher than the priority of
		 the currently executing task (the task this interrupt interrupted) then
		 xHigherPriorityTaskWoken will have been set to pdTRUE.

		 xHigherPriorityTaskWoken is used as the parameter to
		 portYIELD_FROM_ISR(). If xHigherPriorityTaskWoken equals pdTRUE, then
		 calling portYIELD_FROM_ISR() will request a context switch. If
		 xHigherPriorityTaskWoken is still pdFALSE, then calling
		 portYIELD_FROM_ISR() will have no effect.

		 The implementation of portYIELD_FROM_ISR() used by the Windows port
		 includes a return statement, which is why this function does not
		 explicitly return a value. */

	 portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
}
```
***清单 9.8*** *示例 9.1 中设置事件位 2 的 ISR*


清单 9.9 展示调用 `xEventGroupWaitBits()` 阻塞等待事件组的任务实现。该任务会
对事件组中被置位的每一位输出一条字符串。

`xEventGroupWaitBits()` 的 `xClearOnExit` 参数设为 `pdTRUE`，因此导致
`xEventGroupWaitBits()` 返回的事件位会在返回前自动清除。


<a name="list9.9" title="Listing 9.9 The task that blocks to wait for event bits to become set in Example 9.1"></a>

```c
static void vEventBitReadingTask( void *pvParameters )
{
	 EventBits_t xEventGroupValue;
	 const EventBits_t xBitsToWaitFor = ( mainFIRST_TASK_BIT  |
													  mainSECOND_TASK_BIT |
													  mainISR_BIT );

	 for( ;; )
	 {
		  /* Block to wait for event bits to become set within the event
			  group. */
		  xEventGroupValue = xEventGroupWaitBits( /* The event group to read */
																xEventGroup,

																/* Bits to test */
																xBitsToWaitFor,

																/* Clear bits on exit if the
																	unblock condition is met */
																pdTRUE,

																/* Don't wait for all bits. This
																	parameter is set to pdTRUE for the
																	second execution. */
																pdFALSE,

																/* Don't time out. */
																portMAX_DELAY );

		  /* Print a message for each bit that was set. */
		  if( ( xEventGroupValue & mainFIRST_TASK_BIT ) != 0 )
		  {
				vPrintString( "Bit reading task -\t Event bit 0 was set\r\n" );
		  }

		  if( ( xEventGroupValue & mainSECOND_TASK_BIT ) != 0 )
		  {
				vPrintString( "Bit reading task -\t Event bit 1 was set\r\n" );
		  }

		  if( ( xEventGroupValue & mainISR_BIT ) != 0 )
		  {
				vPrintString( "Bit reading task -\t Event bit 2 was set\r\n" );
		  }
	 }
}
```
***清单 9.9*** *示例 9.1 中阻塞等待事件位的任务*


`main()` 创建事件组与任务后启动调度器。实现见清单 9.10。读取事件组的任务
优先级高于写事件组的任务，确保每次解除阻塞条件满足时读取任务都会抢占写任务。


<a name="list9.10" title="Listing 9.10 Creating the event group and tasks in Example 9.1"></a>

```c
int main( void )
{
	 /* Before an event group can be used it must first be created. */
	 xEventGroup = xEventGroupCreate();

	 /* Create the task that sets event bits in the event group. */
	 xTaskCreate( vEventBitSettingTask, "Bit Setter", 1000, NULL, 1, NULL );

	 /* Create the task that waits for event bits to get set in the event
		 group. */
	 xTaskCreate( vEventBitReadingTask, "Bit Reader", 1000, NULL, 2, NULL );

	 /* Create the task that is used to periodically generate a software
		 interrupt. */
	 xTaskCreate( vInterruptGenerator, "Int Gen", 1000, NULL, 3, NULL );

	 /* Install the handler for the software interrupt. The syntax necessary
		 to do this is dependent on the FreeRTOS port being used. The syntax
		 shown here can only be used with the FreeRTOS Windows port, where such
		 interrupts are only simulated. */
	 vPortSetInterruptHandler( mainINTERRUPT_NUMBER, ulEventBitSettingISR );

	 /* Start the scheduler so the created tasks start executing. */
	 vTaskStartScheduler();

	 /* The following line should never be reached. */
	 for( ;; );
	 return 0;
}
```
***清单 9.10*** *示例 9.1 中创建事件组与任务*


当 `xEventGroupWaitBits()` 的 `xWaitForAllBits` 参数设为 `pdFALSE` 时，
示例 9.1 的输出如图 9.3 所示。可见，由于 `xWaitForAllBits` 设为 `pdFALSE`，
读取事件组的任务在任何事件位置位时都会立即离开 *Blocked* 状态并执行。


<a name="fig9.3" title="Figure 9.3 The output produced when Example 9.1 is executed with xWaitForAllBits set to pdFALSE"></a>

* * *
![](media/image73.jpg)
***图 9.3*** *xWaitForAllBits= pdFALSE 时示例 9.1 的输出*
* * *

当 `xEventGroupWaitBits()` 的 `xWaitForAllBits` 参数设为 `pdTRUE` 时，
示例 9.1 的输出如图 9.4 所示。可见，由于 `xWaitForAllBits` 设为 `pdTRUE`，
读取事件组的任务只有在三个事件位全部置位后才离开 *Blocked* 状态。


<a name="fig9.4" title="Figure 9.4 The output produced when Example 9.1 is executed with xWaitForAllBits set to pdTRUE"></a>

* * *
![](media/image74.jpg)
***图 9.4*** *xWaitForAllBits= pdTRUE 时示例 9.1 的输出*
* * *


## 9.4 使用事件组进行任务同步

有时应用设计要求两个或更多任务彼此同步。例如，任务 A 接收到事件后，将部分处理
委派给任务 B、任务 C 与任务 D。若任务 A 在 B、C、D 完成前不能接收下一个事件，
则这四个任务需同步。每个任务在完成自身处理后到达“同步点”，只有当其他任务也
完成处理后才可继续。任务 A 只有在四个任务都到达同步点后才能接收下一事件。

一个更具体的例子来自 FreeRTOS+TCP 的演示工程。该示例让两个任务共享一个 TCP
socket；一个任务向 socket 发送数据，另一个任务从同一 socket 接收数据[^25]。
任一任务在确信对方不再访问 socket 前都不能关闭 socket。若其中任一任务希望关闭
socket，则必须告知另一任务并等待其停止使用 socket 后再继续。清单 9.10 的伪代码
展示了发送任务希望关闭 socket 的场景。

[^25]: 在撰写本书时，这是单个 FreeRTOS+TCP socket 在任务间共享的唯一方式。

清单 9.10 的场景相对简单，因为只有两个任务需要同步。但可见若其他任务也依赖
socket 打开，则同步场景会更复杂，需要更多任务参与。


<a name="list9.11" title="Listing 9.11 Pseudo code for two tasks that synchronize with each other to ensure a shared TCP socket..."></a>

```c
void SocketTxTask( void *pvParameters )
{
	 xSocket_t xSocket;
	 uint32_t ulTxCount = 0UL;

	 for( ;; )
	 {
		  /* Create a new socket. This task will send to this socket, and another
			  task will receive from this socket. */
		  xSocket = FreeRTOS_socket( ... );

		  /* Connect the socket. */
		  FreeRTOS_connect( xSocket, ... );

		  /* Use a queue to send the socket to the task that receives data. */
		  xQueueSend( xSocketPassingQueue, &xSocket, portMAX_DELAY );

		  /* Send 1000 messages to the socket before closing the socket. */
		  for( ulTxCount = 0; ulTxCount < 1000; ulTxCount++ )
		  {
				if( FreeRTOS_send( xSocket, ... ) < 0 )
				{
					 /* Unexpected error - exit the loop, after which the socket
						 will be closed. */
					 break;
				}
		  }

		  /* Let the Rx task know the Tx task wants to close the socket. */
		  TxTaskWantsToCloseSocket();

		  /* This is the Tx task's synchronization point. The Tx task waits here
			  for the Rx task to reach its synchronization point. The Rx task will
			  only reach its synchronization point when it is no longer using the
			  socket, and the socket can be closed safely. */
		  xEventGroupSync( ... );

		  /* Neither task is using the socket. Shut down the connection, then
			  close the socket. */
		  FreeRTOS_shutdown( xSocket, ... );
		  WaitForSocketToDisconnect();
		  FreeRTOS_closesocket( xSocket );
	 }
}
/*-----------------------------------------------------------*/

void SocketRxTask( void *pvParameters )
{
	 xSocket_t xSocket;

	 for( ;; )
	 {
		  /* Wait to receive a socket that was created and connected by the Tx
			  task. */
		  xQueueReceive( xSocketPassingQueue, &xSocket, portMAX_DELAY );

		  /* Keep receiving from the socket until the Tx task wants to close the
			  socket. */
		  while( TxTaskWantsToCloseSocket() == pdFALSE )
		  {
			  /* Receive then process data. */
			  FreeRTOS_recv( xSocket, ... );
			  ProcessReceivedData();
		  }

		  /* This is the Rx task's synchronization point - it only reaches here
			  when it is no longer using the socket, and it is therefore safe for
			  the Tx task to close the socket. */
		  xEventGroupSync( ... );
	 }
}
```
***清单 9.11*** *两个任务通过同步确保共享 TCP socket 不再被任一任务使用后再关闭 socket 的伪代码*


事件组可用于创建同步点：

- 每个参与同步的任务在事件组中分配一个唯一事件位。

- 每个任务到达同步点时设置自身事件位。

- 设置自身事件位后，各任务阻塞在事件组上等待其他同步任务的事件位也置位。

但在该场景中不能使用 `xEventGroupSetBits()` 与 `xEventGroupWaitBits()`。若使用它们，
设置事件位（表示任务到达同步点）与测试事件位（判断其他任务是否到达同步点）将
作为两个独立操作执行。考虑任务 A、B、C 使用事件组同步的场景：

1. 任务 A、任务 B 已到达同步点，其事件位已置位，并在 *Blocked* 状态等待任务 C 的
	事件位置位。

2. 任务 C 到达同步点，调用 `xEventGroupSetBits()` 置位自身事件位。其事件位置位后，
	任务 A 与任务 B 离开 *Blocked* 状态，并清除所有三个事件位。

3. 任务 C 随后调用 `xEventGroupWaitBits()` 等待三个事件位，但此时它们已被清除，
	任务 A 与任务 B 已离开同步点，导致同步失败。

要用事件组成功创建同步点，事件位置位与随后的事件位测试必须作为一个不可中断的
原子操作完成。`xEventGroupSync()` 就是为此目的提供的 API。


### 9.4.1 xEventGroupSync() API 函数

`xEventGroupSync()` 允许两个或多个任务使用事件组进行同步。它允许任务在一个
不可中断的操作中设置事件位，并等待同一事件组中某组合事件位被置位。

`xEventGroupSync()` 的 `uxBitsToWaitFor` 参数指定调用任务的解除阻塞条件。
若 `xEventGroupSync()` 因解除阻塞条件满足而返回，则 `uxBitsToWaitFor` 指定的
事件位会在返回前被清零。


<a name="list9.12" title="Listing 9.12 The xEventGroupSync() API function prototype"></a>

```c
EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup,
									  const EventBits_t uxBitsToSet,
									  const EventBits_t uxBitsToWaitFor,
									  TickType_t xTicksToWait );
```
***清单 9.12*** *xEventGroupSync() API 函数原型*


**xEventGroupSync() 参数与返回值**

- `xEventGroup`

  需要设置与测试事件位的事件组句柄。该句柄由 `xEventGroupCreate()` 创建事件组时返回。

- `uxBitsToSet`

  需置位为 1 的事件位掩码。事件组值通过与 `uxBitsToSet` 进行按位 OR 更新。

  例如，将 `uxBitsToSet` 设为 0x04（二进制 0100）将使事件位 2 被置位（若原本未置位），
  其他位保持不变。

- `uxBitsToWaitFor`

  指定要测试的事件位掩码。

  例如，若调用任务希望等待事件位 0、1、2 置位，则将 `uxBitsToWaitFor` 设为 0x07
  （二进制 111）。

- `xTicksToWait`

  任务在 *Blocked* 状态等待解除阻塞条件满足的最长时间。

  若 `xTicksToWait` 为 0，或调用 `xEventGroupSync()` 时解除阻塞条件已满足，则立即返回。

  阻塞时间以 tick 为单位，绝对时间取决于 tick 频率。
  可使用 `pdMS_TO_TICKS()` 将毫秒转换为 tick。

  若 FreeRTOSConfig.h 中 `INCLUDE_vTaskSuspend` 设为 1，将 `xTicksToWait` 设为
  `portMAX_DELAY` 会使任务无限期等待（无超时）。

- 返回值

  若 `xEventGroupSync()` 因解除阻塞条件满足而返回，则返回值为条件满足时的事件组值
  （在自动清零之前）。此时返回值也满足解除阻塞条件。

  若 `xEventGroupSync()` 因 `xTicksToWait` 超时而返回，则返回值为超时发生时的
  事件组值，此时返回值不满足解除阻塞条件。


<a name="example9.2" title="Example 9.2 Synchronizing tasks"></a>
---
***示例 9.2*** *任务同步*

---

示例 9.2 使用 `xEventGroupSync()` 同步同一任务实现的三个实例。任务参数用于传入
各实例在调用 `xEventGroupSync()` 时要设置的事件位。

任务在调用 `xEventGroupSync()` 前后各输出一次消息，并附带时间戳，便于观察
输出中的执行顺序。使用伪随机延时，以防所有任务同时到达同步点。

任务实现见清单 9.12。


<a name="list9.13" title="Listing 9.13 The implementation of the task used in Example 9.2"></a>

```c
static void vSyncingTask( void *pvParameters )
{
	 const TickType_t xMaxDelay = pdMS_TO_TICKS( 4000UL );
	 const TickType_t xMinDelay = pdMS_TO_TICKS( 200UL );
	 TickType_t xDelayTime;
	 EventBits_t uxThisTasksSyncBit;
	 const EventBits_t uxAllSyncBits = ( mainFIRST_TASK_BIT  |
													 mainSECOND_TASK_BIT |
													 mainTHIRD_TASK_BIT );

	 /* Three instances of this task are created - each task uses a different
		 event bit in the synchronization. The event bit to use is passed into
		 each task instance using the task parameter. Store it in the
		 uxThisTasksSyncBit variable. */
	 uxThisTasksSyncBit = ( EventBits_t ) pvParameters;

	 for( ;; )
	 {
		  /* Simulate this task taking some time to perform an action by delaying
			  for a pseudo random time. This prevents all three instances of this
			  task reaching the synchronization point at the same time, and so
			  allows the example's behavior to be observed more easily. */
		  xDelayTime = ( rand() % xMaxDelay ) + xMinDelay;
		  vTaskDelay( xDelayTime );

		  /* Print out a message to show this task has reached its synchronization
			  point. pcTaskGetTaskName() is an API function that returns the name
			  assigned to the task when the task was created. */
		  vPrintTwoStrings( pcTaskGetTaskName( NULL ), "reached sync point" );

		  /* Wait for all the tasks to have reached their respective
			  synchronization points. */
		  xEventGroupSync( /* The event group used to synchronize. */
								 xEventGroup,

								 /* The bit set by this task to indicate it has reached
									 the synchronization point. */
								 uxThisTasksSyncBit,

								 /* The bits to wait for, one bit for each task taking
									 part in the synchronization. */
								 uxAllSyncBits,

								 /* Wait indefinitely for all three tasks to reach the
									 synchronization point. */
								 portMAX_DELAY );

		  /* Print out a message to show this task has passed its synchronization
			  point. As an indefinite delay was used the following line will only
			  be executed after all the tasks reached their respective
			  synchronization points. */
		  vPrintTwoStrings( pcTaskGetTaskName( NULL ), "exited sync point" );
	 }
}
```
***清单 9.13*** *示例 9.2 使用的任务实现*

`main()` 创建事件组与三个任务后启动调度器。实现见清单 9.14。


<a name="list9.14" title="Listing 9.14 The main() function used in Example 9.2"></a>

```c
/* Definitions for the event bits in the event group. */

#define mainFIRST_TASK_BIT ( 1UL << 0UL ) /* Event bit 0, set by the 1st task */
#define mainSECOND_TASK_BIT( 1UL << 1UL ) /* Event bit 1, set by the 2nd task */
#define mainTHIRD_TASK_BIT ( 1UL << 2UL ) /* Event bit 2, set by the 3rd task */

/* Declare the event group used to synchronize the three tasks. */
EventGroupHandle_t xEventGroup;

int main( void )
{
	 /* Before an event group can be used it must first be created. */
	 xEventGroup = xEventGroupCreate();

	 /* Create three instances of the task. Each task is given a different
		 name, which is later printed out to give a visual indication of which
		 task is executing. The event bit to use when the task reaches its
		 synchronization point is passed into the task using the task parameter. */
	 xTaskCreate( vSyncingTask, "Task 1", 1000, mainFIRST_TASK_BIT, 1, NULL );
	 xTaskCreate( vSyncingTask, "Task 2", 1000, mainSECOND_TASK_BIT, 1, NULL );
	 xTaskCreate( vSyncingTask, "Task 3", 1000, mainTHIRD_TASK_BIT, 1, NULL );

	 /* Start the scheduler so the created tasks start executing. */
	 vTaskStartScheduler();

	 /* As always, the following line should never be reached. */
	 for( ;; );
	 return 0;
}
```
***清单 9.14*** *示例 9.2 的 main() 函数*

示例 9.2 的输出如图 9.5 所示。可见尽管每个任务在不同（伪随机）时间到达同步点，
但它们在同一时刻离开同步点[^26]（即最后一个任务到达同步点的时刻）。

[^26]: 图 9.5 展示了 FreeRTOS Windows 移植上的运行结果，该移植不具备严格实时性
（尤其在使用 Windows 系统调用向控制台输出时），因此会出现一定时间偏差。


<a name="fig9.5" title="Figure 9.5 The output produced when Example 9.2 is executed"></a>

* * *
![](media/image75.jpg)
***图 9.5*** *示例 9.2 的输出*
* * *
