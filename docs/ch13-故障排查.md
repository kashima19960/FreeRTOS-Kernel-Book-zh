# 13 故障排查

## 13.1 章节介绍与范围

本章总结了 FreeRTOS 新用户最常见的问题。首先重点讨论多年来支持请求中最频繁的三类
问题：中断优先级设置错误、栈溢出、`printf()` 使用不当。随后以 FAQ 风格简要介绍
其他常见错误、可能原因与解决方案。

> *使用 `configASSERT()` 可以立即捕获并定位最常见的错误来源，从而提升效率。
> 强烈建议在开发或调试 FreeRTOS 应用时定义 `configASSERT()`。
> `configASSERT()` 见 12.2 节。*


## 13.2 中断优先级

> *注意：这是支持请求中排名第一的原因，多数移植中定义 `configASSERT()` 可立即捕获此错误！*

如果所用 FreeRTOS 移植支持中断嵌套，且中断服务例程使用 FreeRTOS API，那么该中断的
优先级 *必须* 设置为不高于 `configMAX_SYSCALL_INTERRUPT_PRIORITY`（见 7.8 节“中断嵌套”）。
否则临界区将失效，进而导致间歇性故障。

在以下处理器上运行 FreeRTOS 时应特别小心：

- 中断优先级默认最高（例如部分 ARM Cortex 处理器，可能还有其他处理器）。
	在此类处理器上，使用 FreeRTOS API 的中断优先级不能留为默认值。

- 数值大的优先级表示逻辑低优先级（看似反直觉，容易混淆）。这同样适用于 ARM Cortex
	处理器，可能还有其他处理器。

- 例如，在此类处理器上，优先级 5 的中断可被优先级 4 的中断打断。因此若
	`configMAX_SYSCALL_INTERRUPT_PRIORITY` 设为 5，则使用 FreeRTOS API 的中断
	只能分配数值优先级大于或等于 5。此时优先级 5 或 6 有效，而优先级 3 肯定无效。

	![](media/image91.png)

- 不同库对中断优先级的指定方式不同。尤其是面向 ARM Cortex 的库，优先级在写入
	硬件寄存器前会进行位移。有的库自行移位，有的库要求在传参前完成移位。

- 同一架构的不同实现，支持的中断优先级位数不同。例如某厂商 Cortex-M 处理器实现
	3 位优先级，另一厂商实现 4 位优先级。

- 定义中断优先级的位可能被拆分为“抢占优先级”和“子优先级”。请确保所有位都用于
	抢占优先级，不使用子优先级。

在一些 FreeRTOS 移植中，`configMAX_SYSCALL_INTERRUPT_PRIORITY` 的替代名称为
`configMAX_API_CALL_INTERRUPT_PRIORITY`。


## 13.3 栈溢出

栈溢出是第二常见的支持请求来源。FreeRTOS 提供多种功能用于捕获和调试栈相关问题[^28]。

[^28]: 这些功能在 FreeRTOS Windows 移植中不可用。


### 13.3.1 uxTaskGetStackHighWaterMark() API 函数

每个任务都有自己的栈，栈大小在创建任务时指定。`uxTaskGetStackHighWaterMark()`
用于查询任务距离溢出其栈空间的程度，该值称为栈“高水位”。


<a name="list13.1" title="Listing 13.1 The uxTaskGetStackHighWaterMark() API function prototype"></a>

```c
UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask );
```
***清单 13.1*** *uxTaskGetStackHighWaterMark() API 函数原型*

**uxTaskGetStackHighWaterMark() 参数与返回值**

- `xTask`

	需要查询栈高水位的任务句柄（目标任务）。可参考 `xTaskCreate()` 的 `pxCreatedTask`
	参数获取任务句柄。

	任务可通过传入 NULL 查询自身栈高水位。

- 返回值

	任务执行与中断处理期间，栈使用量会变化。`uxTaskGetStackHighWaterMark()` 返回
	自任务开始执行以来剩余栈空间的最小值，即栈使用达到最大（最深）时的未使用栈空间。
	高水位越接近 0，任务越接近栈溢出。

也可使用 `uxTaskGetStackHighWaterMark2()` 代替 `uxTaskGetStackHighWaterMark()`，
两者区别仅在返回类型。


<a name="list13.2" title="Listing 13.2 The uxTaskGetStackHighWaterMark2() API function prototype"></a>

```c
configSTACK_DEPTH_TYPE uxTaskGetStackHighWaterMark2( TaskHandle_t xTask );
```
***清单 13.2*** *uxTaskGetStackHighWaterMark2() API 函数原型*

使用 `configSTACK_DEPTH_TYPE` 可让应用编写者控制用于栈深的类型。

### 13.3.2 运行时栈检查——概述

FreeRTOS 提供三种可选的运行时栈检查机制，由 FreeRTOSConfig.h 中的编译期常量
`configCHECK_FOR_STACK_OVERFLOW` 控制。所有方法都会增加上下文切换耗时。

栈溢出钩子（或回调）函数在内核检测到栈溢出时被调用。要使用栈溢出钩子：

1. 在 FreeRTOSConfig.h 中将 `configCHECK_FOR_STACK_OVERFLOW` 设为 1、2 或 3（见下文）。

1. 按清单 13.3 的函数名与原型提供钩子函数实现。


<a name="list13.3" title="Listing 13.3 The stack overflow hook function prototype"></a>

```c
void vApplicationStackOverflowHook( TaskHandle_t *pxTask, signed char *pcTaskName );
```
***清单 13.3*** *栈溢出钩子函数原型*

栈溢出钩子用于更容易捕获与调试栈错误，但一旦发生栈溢出，通常无法恢复。
钩子函数参数传入发生栈溢出的任务句柄与任务名。

栈溢出钩子在中断上下文中调用。

某些微控制器在检测到非法内存访问时会触发故障异常，因此可能在内核调用栈溢出钩子前
就触发故障。


### 13.3.3 运行时栈检查——方法 1

当 `configCHECK_FOR_STACK_OVERFLOW` 设为 1 时选择方法 1。

任务每次被切出时，其完整执行上下文会保存到栈上，这通常是栈使用达到峰值的时刻。
当 `configCHECK_FOR_STACK_OVERFLOW` 设为 1 时，内核在保存上下文后检查栈指针是否
仍在有效栈空间内。若栈指针超出范围，则调用栈溢出钩子。

方法 1 执行快，但可能遗漏发生在上下文切换之间的栈溢出。


### 13.3.4 运行时栈检查——方法 2

方法 2 在方法 1 的基础上增加额外检查，当 `configCHECK_FOR_STACK_OVERFLOW` 设为 2 时启用。

任务创建时，其栈会填充已知模式。方法 2 检查任务栈末尾有效的 20 字节是否仍保持该
模式，若任一字节改变，则调用栈溢出钩子。

方法 2 不如方法 1 快，但依然较快（仅检查 20 字节）。通常能捕获所有栈溢出，
但极小概率会漏检。

### 13.3.4 运行时栈检查——方法 3

当 `configCHECK_FOR_STACK_OVERFLOW` 设为 3 时选择方法 3。

此方法仅在部分移植中可用。可用时，该方法启用 ISR 栈检查；检测到 ISR 栈溢出时
会触发断言。注意此时不会调用栈溢出钩子，因为钩子针对任务栈而非 ISR 栈。

## 13.4 printf() 与 sprintf() 的使用

通过 `printf()` 记录日志是常见错误来源。开发者往往未意识到该问题，于是为调试加入
更多 `printf()`，反而使问题加剧。

许多交叉编译器供应商提供适合小型嵌入式系统的 `printf()` 实现。即便如此，该实现
可能不是线程安全的，可能不适合在 ISR 中使用，并且取决于输出目的地，执行时间可能很长。

如果没有针对小型嵌入式系统优化的 `printf()` 实现而使用通用实现，则需特别小心：

- 仅仅引入 `printf()` 或 `sprintf()` 就可能显著增大可执行文件体积。

- `printf()` 与 `sprintf()` 可能调用 `malloc()`，若未使用 heap_3 以外的分配方案
	可能无效。详见 3.2 节“示例内存分配方案”。

- `printf()` 与 `sprintf()` 可能需要远大于平时的栈空间。


### 13.4.1 printf-stdarg.c

许多 FreeRTOS 示例工程使用名为 printf-stdarg.c 的文件，它提供一个最小、栈高效的
`sprintf()` 实现，可替代标准库版本。多数情况下，这能显著降低调用 `sprintf()`
及相关函数的任务栈需求。

printf-stdarg.c 还提供一种机制以逐字符输出 `printf()`，虽然速度较慢，但可进一步
降低栈使用。

注意：并非所有 FreeRTOS 下载包中的 printf-stdarg.c 都实现了 `snprintf()`。
未实现的版本会忽略缓冲区大小参数，直接映射到 `sprintf()`。

printf-stdarg.c 是开源文件，但版权归第三方所有，因此许可与 FreeRTOS 分离。
许可条款位于源文件顶部。


## 13.5 其他常见错误来源

### 13.5.1 现象：给示例添加一个简单任务导致示例崩溃

创建任务需要从堆中分配内存。许多示例工程将堆大小配置为刚好足够创建示例任务——
任务创建后剩余堆内存不足以再创建任务、队列、事件组或信号量。

空闲任务（以及可能的 RTOS 守护任务）会在调用 `vTaskStartScheduler()` 时自动创建。
若堆内存不足以创建这些任务，`vTaskStartScheduler()` 将返回。在
`vTaskStartScheduler()` 后加一个空循环 `[ for(;;); ]` 可使该错误更易调试。

要添加更多任务，必须增加堆大小或移除现有示例任务。可增大的堆大小始终受 RAM 限制。
详见 3.2 节“示例内存分配方案”。


### 13.5.2 现象：在中断中使用 API 导致应用崩溃

除非 API 名称以 “...FromISR()” 结尾，否则不要在 ISR 中调用 API 函数。
特别是，除非使用中断安全宏，否则不要在中断中创建临界区。详见 7.2 节
“在 ISR 中使用 FreeRTOS API”。

在支持中断嵌套的移植中，不要在优先级高于 `configMAX_SYSCALL_INTERRUPT_PRIORITY`
的中断中使用任何 API 函数。详见 7.8 节“中断嵌套”。


### 13.5.3 现象：应用有时在 ISR 内崩溃

首先检查中断是否导致栈溢出。有些移植只检查任务栈溢出，而不检查中断栈溢出。

不同移植与编译器对中断定义和使用方式不同。因此其次要检查 ISR 使用的语法、宏与
调用约定是否与所用移植文档完全一致，并与随移植提供的示例应用一致。

若处理器使用“数值低优先级代表逻辑高优先级”，确保为每个中断分配的优先级正确，
因为这看似反直觉。若处理器默认将中断优先级设为最高，确保未保留默认值。
详见 7.8 节“中断嵌套”和 13.2 节“中断优先级”。


### 13.5.4 现象：调度器尝试启动第一个任务时崩溃

确保已安装 FreeRTOS 中断处理程序。请参考所用移植文档及移植示例应用。

某些处理器必须先进入特权模式才能启动调度器。最简单的方式是在 C 启动代码中
（调用 main() 之前）将处理器切换到特权模式。


### 13.5.5 现象：中断意外保持禁用，或临界区嵌套不正确

若在调度器启动前调用 FreeRTOS API，系统会故意保持中断禁用，直到第一个任务开始
执行才重新使能。这样可避免系统初始化期间、调度器尚未启动且可能处于不一致状态时，
中断调用 FreeRTOS API 导致崩溃。

不要通过 `taskENTER_CRITICAL()` 与 `taskEXIT_CRITICAL()` 之外的方法修改
微控制器中断使能位或优先级标志。这些宏会记录嵌套深度，确保中断仅在嵌套完全
解除后才重新使能。注意某些库函数本身可能会使能/禁用中断。


### 13.5.6 现象：调度器启动前应用就崩溃

可能引发上下文切换的 ISR 不允许在调度器启动前执行。同样，任何试图向 FreeRTOS
对象（如队列或信号量）发送/接收的 ISR 也不应在调度器启动前执行。
上下文切换只能在调度器启动后发生。

许多 API 在调度器启动前不可调用。建议在调用 `vTaskStartScheduler()` 之前仅创建
任务、队列、信号量等对象，而不要使用这些对象。


### 13.5.7 现象：在调度器挂起或临界区中调用 API 导致应用崩溃

调度器通过 `vTaskSuspendAll()` 挂起，通过 `xTaskResumeAll()` 恢复（解除挂起）。
临界区通过 `taskENTER_CRITICAL()` 进入，通过 `taskEXIT_CRITICAL()` 退出。

不要在调度器挂起期间或在临界区内调用 API 函数。

## 13.6 额外调试步骤

若遇到上述常见问题之外的故障，可尝试以下调试步骤：

- 在应用的 FreeRTOSConfig 中定义 `configASSERT()`，启用 malloc 失败检查与栈溢出检查。
- 检查 FreeRTOS API 返回值是否成功。
- 检查与调度器相关的配置（如 `configUSE_TIME_SLICING`、`configUSE_PREEMPTION`）
	是否满足应用需求。
- [此页面](https://www.freertos.org/Debugging-Hard-Faults-On-Cortex-M-Microcontrollers.html)
	提供 Cortex-M 微控制器 Hard Fault 调试细节。
